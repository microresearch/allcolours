#+OPTIONS: num:nil
#+OPTIONS: toc:nil

* notes 

    O
    |
(---+---)
    |
    0

sync and divination: 4 layers // binary figure

moon/crescents - new moon - half - full - half 

  M

R   P

MODE: X | ADC | FREEZE | NOTES
-------------------------------
N: 
R:
P:
R+P: 

////

*Basic mode to implement:* (each mode is defined by ADCs and freeze behaviour)

NADA: GEOMANTIC: ADC->mode // freeze as freeze (in other modes as fake swop? invert etc) - NONinvert is take value from top, but what is "fake swop"?
REC: ADC->overlay to other tape // freeze as swop main tape... // further REC adds sections to main tape...// what we hear is voltage+overlay
PLAY: ADC->speed // freeze is swop // do we add to list on swop/play-play? yes try that
REC+PLAY: ADC->speed/bounce/rec to other // freeze is swop // what does voltage do (overlay same tape minormodes here)

Q of global speed... *new top ADC is global control. also we have sync functions*

NADA = no tape

- ghost hands
- detached hand swop//cut off hand
- inversion - up is down // down is up

- ways of adding to play list, operations on play list (and how is it doubled or not?)
- operations on tape and across 2 tapes
- sync/detach etc...
- chop/silence/insert etc... or is that operation on play list

* divination ideas

The geomantic figure Via, or “Way”. This figure has all elements
active, revealing its dynamic nature; its linear form resembles a
road, at the changes afoot due to time and circumstance. It takes and
transforms every other figure and force into its opposite. It is a
figure of complete change, upheaval, and reversal; it is good with bad
figures and bad with good figures, though it is considerably more
favorable in matters requiring total reassessment and journeys of any
kind. It often shows a solitary time and path, between homes, cities,
and worlds.

- moons from the top
- which of four ADC has hardest press, how we could interpret 4 presses as binary/geomantic figure!? - through geomantic modes

*how can VIA be informed by concepts of AION and CHRONOS - divisibility of time/no present and all present/all depth*

all present is NADA mode... endless presence

- divination methods, concepts of time: Franz and synchronicity-divination /Deleuze - aion and chronos

* HW/timing

- HW Connectors upper and lower:
SL 2X40G SMD2,54
BL 2X50G7 2,54	

- divider: 470K // another value now we have 12V

- filter: 15K and 47nF = 220 Hz (did we decide against 50Hz filter?)

- software: main divider of 24: 21 seconds recording length

- Latest all working but make sure we fix to MMBT3906 in BOM/assembly!

* TODO:

UPDATE all notes for HW, speeds and basic mode, plan of action!

- DONEre-test all VCA, noise and voltages
- new finger tests - Kaffe: triggers, length of trigger, new voltage?

- DONEnew speed mode to test
- DONEcondense and print older/newer notes/here
- DONEdefine basic HW and timing, filters below

- define minor modes 
- define and test basic mode and add/catalogue all modes - translate previous major modes into new scheme
- test suggested new modes without minor modes
- wrap together

** minor modes in each state //these are not bits or bits as say options not binary

So minor modes define use of toggle, speed, newADC for major modes...

Nada: add global from top, +invert voltage+, ghosts and mirrors - but does these stick around? yes - as livevalue function now
Rec:
Play:
RP:

new: ghosts and mirrors for all:define these/how they operate

So each section can set a minormode which could also stick around - eg. NADA minors handle how we deal with voltages...

*** Speeds = P, RP

- sync speeds to top newADC or not
- 4 types speed: logspeed and logfast, + new logfast_stop and logspeed_stop

*** etc? 

- R,P,RP: to reset or not
- ALL@ sensitivity?
- RP: overlay: extend overlay past end of recording
- R,P,RP: detach/unsync (how that happens - as it needs to unsync to a time - so ie. re-sync to say Freeze) - options for what freeze toggle does in certain modes
// detach is not really minormode...
detach would be to stop/start/move play/rec head... with freeze/toggle or with newADC

see: strip for overlay options there - and how those change with 2 tapes?

also as minormodes modify the major mode so they depend on this!

*** types of overlay

	    if (overoverlay==0){ //usual - now swopped for >
	      if (real[daccount]>values[daccount]) values[daccount]=real[daccount]; // only if is more than
	    }
	    else if (overoverlay==1){ // mod
	      values[daccount]+=real[daccount];
	      if (values[daccount]>4095) values[daccount]=4095;
	    }
	    else if (overoverlay==2){
	      values[daccount]+=real[daccount];
	      values[daccount]=values[daccount]%4096;
	    }
	    else if (overoverlay==3){
	      subs=values[daccount]-real[daccount];
	      values[daccount]=abs(subs);
	    }


*** older and expanding

- what minormodes we have so far? in [0]?

	//Rec - 
	
	//R+P: overlay
	overoverlay=((overminor>>1)&3); // 4 types of overlay
	overrec=((overminor>>3)&3); // types of recorded overlay 
	+overspeedmod=((overminor>>5)&1);// as playspeedmod+
	+ now it would have speeds also as play: 2 types speed: logspeed and logfast  

	//Play
	playoverlay=((playminor>>1)&3); // 4 types of live overlay
	playspeed=((playminor>>3)&1); // 2 types speed: logspeed and logfast  
	+playfreeze=((playminor>>4)&1); // 2 types freeze+
	+playspeedmod=((playminor>>5)&2);  // 2 types:  add recorded speed to real, of if real> // but this was for recorded speed only+


** suggested test major modes

- new major mode: we are always recording in NADA, and in REC we select what to add to the tape, and in PLAY we play these???
- basic mode above
- use newADC as a kind of filter of the tape: doesn't let playback value through below newADC threshold (silence or stops tape/speed thresholding)...
- see 21/12/2023 below..

** start to define new approach// see latest notebook and diary notes below

States are: N, R, P, RP (enum)
Active position/voltage can change state and minor/major modes and undergo full reset. Inactive position stays in its mode (eg. plays) until active/changes
There are two tapes (0 and 1) for each position 
There is a list of playbacks for each position which reference start and end on a tape, and which tape (0 or 1)
Rec just adds to end of tape/wrapping round until full reset
Major modes are ported in and allow for recursive/fractal dismemberments and dislocations...
Pressing newADC in NADA zooms us into a new major mode (geomantic operation)

Minor modes // and they stay// are changed in all state... so each state adds its own options...

N: how we handle voltages: add global from top, invert voltage, ghosts and mirrors(?), sensitivity?
R: only reset R or not on entry into R + N options // or leave that reset... // for newADc also type of overlay
P, RP: 4 types of live overlay, speedsync, speedarrays
RP: 4 types of recorded overlay 

//older summary
- 2 tapes
- list of playbacks/gestures: list references layer (0 or 1): how do we manipulate list? 
- rec just adds to end of tape/wrapping round until full reset
- no recording of speed just of the effects of speed
- all minormodes: which ones stay across each state
- do we record newADC gestures?  
- activation/press per section of sections so maybe R,P, RP and M(mode sel) are not global!

* diary notes

** 6/4.2024

*Maybe first mode has no playlist - is really the most simple possible IMPLEMENT/test*

- *In RP: types of recorded overlays, and length of overlay to fix*

from strip.c

	    // different overlays
	    if (overrec==0){
	      if (rec_cnt[daccount]<MAXREC) recordings[daccount][rec_cnt[daccount]]=(recordings[daccount][rec_cnt[daccount]]&TOPS) + values[daccount]; // keep top values...
	      else recordings[daccount][rec_cnt[daccount]-MAXREC]=(recordings[daccount][rec_cnt[daccount]-MAXREC]&4095)+(values[daccount]<<16); // top bits
	      rec_cnt[daccount]++;
	      if (rec_cnt[daccount]>ender[daccount]) { // other micromodes here to extend maybe???
		rec_cnt[daccount]=0;
	    }
	    }
	    else if (overrec==1){
	      tmp=(recordings[daccount][rec_cnt[daccount]]&4095) + real[daccount];
	      if (tmp>4095) tmp=4095;
	      if (rec_cnt[daccount]<MAXREC) recordings[daccount][rec_cnt[daccount]]=(recordings[daccount][rec_cnt[daccount]]&TOPS) + tmp; 
	      else recordings[daccount][rec_cnt[daccount]-MAXREC]=(recordings[daccount][rec_cnt[daccount]-MAXREC]&4095)+(tmp<<16); // top bits
	      rec_cnt[daccount]++;
	      if (rec_cnt[daccount]>ender[daccount]) { // other micromodes here to extend maybe???
		rec_cnt[daccount]=0;
	    }
	    }
	    else if (overrec==2){
	      if ((int)play_cnt[daccount]<MAXREC) recordings[daccount][(int)play_cnt[daccount]]=(recordings[daccount][(int)play_cnt[daccount]]&TOPS) + values[daccount];
	      else recordings[daccount][(int)play_cnt[daccount]-MAXREC]=(recordings[daccount][(int)play_cnt[daccount]-MAXREC]&4095)+(values[daccount]<<16); // top bits	      
	    }
	    else if (overrec==3){
	      tmp=(recordings[daccount][(int)play_cnt[daccount]]&4095) + real[daccount];
	      if (tmp>4095) tmp=4095;
	      if ((int)play_cnt[daccount]<MAXREC) recordings[daccount][(int)play_cnt[daccount]]=(recordings[daccount][(int)play_cnt[daccount]]&TOPS) + tmp;
	      else recordings[daccount][(int)play_cnt[daccount]-MAXREC]=(recordings[daccount][(int)play_cnt[daccount]-MAXREC]&4095)+(tmp<<16); // top bits	      
	    }


- latest notebook notes for playlist:

problem with playlist is how we accommodate additions to rec... as we only add what we have from beginning in playlist...

options:
- new rec adds to playlist?
- we reboot playlist every time we have new rec

- playlist more as a journey -> R.P. so can be reset by R (or not, depends on mode)
- perhaps have now soft and hard resets - eg. soft resets rec and play tapes but doesn't change other mode stuff...

/////

- test2.c in progress: walking through a playlist seems to work...

-> port into 2024.c DONE: to test - *we need to have playlist[0] established as reclength somewhere?*

how we deal with layer changes... should be easy...

port code... need to watch start and length

offset/start is issue or not in the test code?

DONE: BUT now we need to add in: add/rec to play list... eg. section x is added when it is played to the end or as we leave...

TESTED in test2.c adding as we go along but not sure how we deal with leaving... (as +1 is the next one in list)... watch we don't go over 118
last when we leave will be added next turn round...

** 5/4/2024

TODO: implement our basic first mode with all opts... and test all mode changes etc IN PROGRESS

= implement playlist in P, sketch out RP when we have that list: needs to be in speedsample... as can be overlaps...

maybe test first on lap///

// so playlist is: playlist which has start, length, layer, playfull which is number of elements and playcnt which is our counter into these

notebook notes:

- DONE: different modes for R,P,N, RP for each section and state [4] - check minors - yes these are the same: fingers[dacc].majormode[fingers[dacc].state]
- DONE: NADA basis - to test options there... also global sync is now to the final voltage at [6] TESTED

*double bounce - see diagram in notebook*

- simple operations across tapes and list which lead to recursive (writes over/to itself) or dislocated/dismembered results...
- for bounces key is speed and start/ends of bounce// also playlist
- did we write down slippage mode in R, maybe in RP where we slide across
- *for newADC in base mode above we need type of overlay in R!*
- what was self/island mode where we write to same tape in some part which repeats and how to adapt to 2 tapes // translate all prveioud major modes and new ideas here

** 4/4/2024

- added ACTIVE/toggle into latest code/to test there. Seems to work so far!

** 2/2/2024 

*note what we need to reset for new mode/mode change and for resett*

- TODO: pull out as much as possible from mode/switches// also use of function pointers for minormode options..
//
- DONE-all positions set as active at the start
- DONE-arrays for minor modes and states:       uint32_t minormode[4]; // N, R, P, RP // and use mask for each - say lowest x bits
- DONESENSESHIFT etc. is now no longer global so goes into STRUCT - but what is sensitivity for CTRL = 0,1,2,3 as these are VCA which don't have sensitivty
*so now sensitivity is for newADC and for Voltage -> manual*

** 1/2/2024

- embarked on new test code with all basics to test
- DONE - in test.c code: TODO: DONEimplement and test activation by way of extended TOGGLE/FREEZE - maybe a bit longer-adjusted to 300!
- port in basic rec/play/overlay from 1123 and test!
- lots to do/test eg. reset on entry into states
- where to put switch - inside functions

//

stm32f4xx_it_2024.c

new code base with:
- structure for each position/voltage inc. state of each (N, P, R, RP), all lists, and minor modes
- rework major and minors

- what is kept across states in minormodes? (eg, speedlog, type etc) - see below
- if we de-activate a position/voltage it stays in its mode. eg. R, P etc
- logic of minormodes as much as possible outside main switches/modes
- playlist: when do we play full list if P just adds to that list on each new entry
- does playlist reference layer?

** 31/1/2024

- +tested new moon panel fine...+
- how to code more clearly latest modes/layers and micromodes - structure?
- how much of micromodes stays across states - eg, speedlog across P and R+P is the same choice?

done but need to test//TODO: somehow we lost pointer/speedref code: TO TEST: DONE	    // minormode speed as a pointer now

** 25/1/2024

mode: R/P/RP?: (both layers play/record or swop layers): offsets/slide or detach:

- newADC offsets layer in time: offset as offset (newADC adds). offset as speed
- notion of alternate realities implies modes which record same gesture to both layers and then merge, manipulate, offset these. What ops?

** 24/1/2024

- list minormodes for basic set ups - in progress

- playback or overlay mix of tape/s at 2 different speeds (where we get these from?)

- detachment using newADC - we can unsync - shift play head to a new
  position instantly. delay rec for as long as we hold newADC or
  accelerate recording (speed again but not recorded)

how that last would work as it would leave blanks - or these are interpolated? -> *new major mode to try*

//
TO TEST: DONE	    // minormode speed as a pointer now

** 17/1/2024

Trial/decide on:
- Activate section: long freeze press (to test) - so we have 8 sections activated
- Geomantic code = mode select with newADC only in NADA: so we have 4 sections for that...
- Activated groups have R, and P. Do we have Mode on X or X is SEL, and where do we put modes?  mode is on X.

- +ORDERED: aisler /// moon figures for panel!TESTED+

** 16/1/2024 ++

- tested new speed arrays: logfast_stop and logspeed_stop which can now be added to the list of minormodes

- //decide on: modeXbutton[M] as mode or as extra action eg. SEL and then mode is on ADC

- notion of activation of a section (so next RMP is undertaken for those sections):
eg.
.press freeze and R,M,P (no freeze in that case): hold RMP->freeze->release - TRIAL: that seems to work in test code!
.press freeze for a longer time renders section active? // could be>>>???

- *is question of whether we activate section or not*

/////

NON:press newADC and R,M,P ->

DONE/18/1/TRIAL: ! press M/P/R ! new ADC goes up/down ! release button // enters that mode (and ADC is ignored) // we can't ignore as it just drops...

*either we activate a section (how to do multiple sections) and then press R,M,P for activated section... or we just have RMP for that section... which is more versatile*

is activation/local RMP across 4 or 8 sections - if we use ADC then is only 4!

** 13/1/2024 +notebook notes

- new top ADC as global control, added to by local values
- sync: sync speed as a minor mode? ie. all speeds add from top (what was [6] is now new ADC at top)
- divination

operations on list
operations on tapes - see latest notebook

eg. newADC runs through/scrolls through list of segments as index into tape

- NADA - micromodes sets use of touch/voltage (eg. add global from top, inversion, ghosts and mirrors) which stays through all...

BUT... *Q is that micromodes is global and major modes are local if they are determined by newADC*

solutions/questions:
- way of activating mode button locally? idea of active regions?

XXXthat modes are only selected by MODE button when that region is active (is being touched?)

- newADC for all modes/minor modes but then we lose newADC?
 or use mode X button as RESETT and as a new action (like REC, PLAY but could be SELECT/DIVINE)

Q of independent mode for each section? are modes global and where do we have them?

- that VIA needs to be more driven by impulses...

- *new major mode: we are always recording in NADA, and in REC we select what to add to the tape, and in PLAY we play these???*

// what is function of MODE button
// what is function on newADC

- we need major and minor modes to be selected, we need some kind of selection/divining mechanism
- major/minor should be local to voltage/or section (no to global modes)
- but would be nice to have extra mode (but how do we select to enter that)...
- changing major mode resets most things... minor modes not... so is it odd if only happens when we are active?

other possibles: simultaneous presses, gestures on newADC

- *touch based divination - what as simple mechanism can be (an unknown, non-causal mechanism for synchronicity)*

/ that there is a series of 4 anti-clockwise sections, make more of sections (that they can also mirror each, contribute to each other in the section)...

TODO:
- test major mode above: list of experimental modes
- trials for active section/voltage mode selects: IN PROGRESS
- TESTED/DONE:test new speed scheme // array

** 8/1/2024

- removed senseshift but still needed offset reductionDONE

TODO:

- HW tests:

- test voltages...

- FIXED with move of init code: +offset of 1.1V? on voltages (but not after programming???) offset is in DAC writing... (not in ADC)!+
+if we use DAC_OutputBuffer_Enable then we have 100mV offset... but we did not have this before...+

- noise seems ok on voltages...

- test VCAs (ADC is filled crescent)

no noise

- test new ADC:

all fine

toggles:

- none really working well, sticky and jittery. why? cold/dry weather but how to adjust... 

// we have 3.3M pulldown but what was it in the previous board? *4.7M - we just now replaced the one on MODE - changed on schematic*

and we extended delay and BRK -- but extending delay causes jump when we touch 

// 256 operates ok,,, but 300mV offset
// 24 gives 200mV
8 seems the limit but no toggle

*r71 is now 1K: changed on schematic* and we test removal of diode but we should leave it...

*now we have DELB as 42 and is fine... but still odd offset - negative at top and positive at bottom??? leave for now as is not terrible... and is worse with changes to GPIO*

// now in TEST_TOGGLES we have all of them in one so does not repeat delay

timer of toggle now:

- resett seems to work and we will only use short tap or reset...

- SW tests:

- mode 0 in 1123 not working now...??? as probably due to toggles!

- fix up test modes for next week: stm32f4xx_it_test.c

* recent notes

- *this is for NADA: new ADC as accelerating through modes (so is not ADC value=mode) as a *journey* // length of press and speed-> position
- DONE/TRAIL* - this is also a new model for speed - no press=no advance/hold voltage/record voltage
- we can also use this to mark sections - fwdwind and mark

** 21/12/2023

latest notebook notes:

PLAY
- one tap: loop selection. next tap /next tap: add now marked section to playlist

- eg. to cut up gestures we just keep what is there as long as we hold freeze or as long as new ADC is > level

is cut up into play list or as re-record to tape 1 or 2

- playlist is single but has 2 strands? tape 1 or 2 - and indications to mix, add etc...

or we have 2 playlists or *just one and all depends on current tape?*

control gesture->>>[--------------] tape 1
                   [--------------] tape 2

parallel gestures which can repeat/mirror/combine/bump one to other. swop

parallel worlds/gestures - rise, dip, slope etc...

** 13/12/2023

more on gestures:

eg. to cut up a gesture we just keep what is there as long as we hold freeze/cut out the other // or as long as new ADC > x

in play list...??? but is more a question of tape and of re-recording

- is a single playlist or we have 2? single with 2 strands/refs to tape 1 or 2 and indications to merge/add etc???

** 11/12/2023 - *that VIA must be divinatory*

that divination is also a form of compression

from 4 cards each of 4 bits (total 16 bits, 2 bytes) to a future or a past...

that VIA/module offers possible algorithmic futures for the gestures // 2 layers, 2 futures

// how we understand and interpret a gesture?

as a set of values, individual values are meaningful, or as a relation between values over time - the last peak, rising, falling etc.

in dark interpreter they become values/codes within software but this approach is not working as ...

record and devise gesture maps / mapping journeys

** 10/12/2023

- how we can use new gesture from ADC pad as controlling option 
- to summarise what we are controlling -> - - *Play list and rec tape per layer*

so control is over the play list (single?)
modes describe interaction between layers eg. bounce etc...

*or we go full geomantic with new ADC gesture across all 4 parts in diamond shape*...

more notes/ again towards defining behaviours...

- *Play and list and rec tape per layer*

*rec:* - just adds and overlaps and is as a tape would be

*play list:* eg. [0-10][0-10][20-160]

how we manage this list in play mode... 

is it cumulative (add in and out to the list) but we need then 2 modes in play mode (and to toggle between and to toggle layer (or that is just in NADA)

2 play modes: select = play tape and select//add to list, play list only (what we toggle there - remove from list?)

//

headless
fingerless
handless

** 28/11/2023

- 2 layers // 2 code streams

- freeze in NADA freezes any mode change for that section - so modes
  can be per section (how could be also per current layer that we freeze on)

- freeze in NADA toggles layer??? how do we know which?

- NADA always records (to one or to both layers) and play sets START and END (do we have code for that): speedsamplestart
Q. of how we add to this in the case of an overlap - see above

- *long and short taps on freezer for different behaviours* [could also be on rec and play]

*that there can be the tape itself and a list of (playback) references
into that tape* // for example we can have list of repeated segments
or long looping part (how many times it loops) - how to implement
this, and also how on the record side...

record list, play list... how we handle these... and this is for each layer?

record list is additive

play list is determined by modes in play and touches...

** 27/11/2023

2 sides // 2 sides each of the 4 // hermaphrodite 2 layers

- major modes can differ across functions (rec, play etc)

*does it make sense if there are also different mode for each layer?*

demonic/good hermaphrodite...

- detach could be in minor modes...

- review and define from all notes... review minormodes

*we mention slowing a gesture - slow speed to other side... TODO* or we slow recording on one side?

// notebooks:

- layer operations:

1: [][][]
2: [    ]

whichever is longer// *we can reset length of one/both layer*, hold/slide/desync one layer...

define properties of layers: 

add/subtract/merge etc.

these are all modes which operate on same enlarging set of
gestures... [Q also if we can say remove last recorded bit - we just
need to record its start and end, but what if it is an overlap - makes it tricky? - still q of list of gestures]

one layer is a ghost and we can swap that designation...

ops: remove silence for voltages...???

*cycling through alternate ways of reading recorded gestures*

*algorithmic easter egg*

add or subtract gestures in play mode

detachment

*still todo modes above esp. - *still could do thing where we start to repeat say first section (or a define island) and overlay this on same tape!*


** 24/11/2023

- 2 layers //4 sides // each of 2 layers each

That VCA and voltage are not/should they be/ fixed to one side 

eg. they can reflect - so say we can add VCA and voltage and output on both // does that make sense...

swop them around... but they have quite different functions... so maybe doesn't make sense... 

** 22/11/2023

- if we sync counters across 2 layers then we have issue as one might go past end of other! // speedsampleL DEP!

** 21/11/2023

- struct for each layer DONE - what does it enable us to do, or what are issues/questions:

ending of each, sync of swopped playback as each speedplay has its own
counters (or these become one - for each layer: speedsampleL),
question of overlap for each layer, which layer on entry into play
etc, if layer is not there what we do in playback?, can have more
function pointers for different options also...

/////
- question still of list (as it should also indicate the layer) - we need list to be able to remove! *DISCARDED for NOW*

- 2 layers/tapes: speeds, slide across

*what cases we need to code for // eg.*

-record playback speed change on layer 1-> layer 2

but how do we get feedback for this...

*now in new file but not toggle// always NO USE OF TOGGLE:
toggle starts to record to layer2(overlay) speed changes from layer1 and we hear those changes (we are in 1). toggle stops and stays with 2... so no overlay recorded. local and global speeds*

- rec toggles 1 or 2 to record to (but no feedback so how we know which?)
- play toggles which one but one maybe blank?

twinned layer operations: swop, merge/add/subtract/mix, bounce to/record from one to other with speeds, slide across, different speeds

list ops: add (new rec), remove, swop, copy/double, collapse=join, chop?as in cut silence and render as new lists, hide/unhide, detach

-islands and notes above and below...

** 19/11/2023

questions/thoughts:

- do we extend overlay? was marked as TODO minormode option in [0]
- what minormodes we have so far? in [0]?

	//rec -nada
	
	//overlay
	overoverlay=((overminor>>1)&3); // 2 types of overlay
	overrec=((overminor>>3)&3); // type of recorded overlay 
	overspeedmod=((overminor>>5)&1);// 

	//play
	playoverlay=((playminor>>1)&3); // 4 types of overlay
	playspeed=((playminor>>3)&1); // 2 types speed 
	playfreeze=((playminor>>4)&1); // 2 types freeze
	playspeedmod=((playminor>>5)&2);  //

*which of these we retain?* run through them

- how play and rec can be generic? what are the exceptions so far?

- how we could record slowing down of a gesture - needs a place to record into (layer or new entry in list)?

- if we have list and add to it what happens if we run out of space - last entry stops... (is not like a tape loop)

typedef struct listy_ { 
  uint32_t start[120];  
  uint32_t gap[120];
  uint32_t length[120];
  float speed[120];
} hands;

static hands fingers[8];
static uint32_t howmanyfingers[8]={0,0,0,0, 0,0,0,0};

** 19/10/2023 notebook notes

- operations on a list of gestures
- that each mode entails a set of operations on that list
- how can we have successive changes in repeated segments

** 26/10/2023

*To start to define new direction based on latest notes*

notebook notes:

- Q of new speed rec, all is overlay, or *speed global as [6] voltage and local voltages*... no doublings 
- so we can maintain, modify or erase overlay as we progress
- and use overlay as speed or not...
- additive switch/swop across 2 tapes (2 tapes, 2 speeds - how?)
- algorithmic control as pulse in to freezers/toggles, minimode
- *translate modes we have into ongoing series of transformations*

- what we can do with a list of gestures, list of modes: earlier idea of push/pop/ *stack* button... 

earlier idea was: Notes: frozen levels are saved to a stack and can be popped off the stack, various over-rides...????

circular stack of gestures - how to add, remove and what happens when we run out of room??? 

** 25/10/2023 *KEY*

- trying to re-think towards more fluidity// notebook notes:

1. We could pull out REC and NADA as these have no modes (but in REC we have double and other rec options, also if we reset)

as in REC we have no feedback on what we do. so it must be simple... but how we could signify a RESET there in further modes, to start again and not to add to!?

First mode (after full RESETT) is just record, no speed, and is always reset REC in this mode - but then we can leave it...

Then we change after that...

Question of no double record, no speed rec? and top bits are always ghost/overlay with voltage 6 as speed (and seperate its playback speed)

*So modes overlay and change what we have already recorded gesturally - but how can we move back or forwards through modes?? or is just fwd*

And do we keep micromodes (yes)... but these do not include reset on REC...

3. top [6]voltage is always control - so no freeze on that. but is also output so we can use it for sync...

4. *Options for algorithmic control*

So we can use external voltage input via fingers to trigger freeze/toggles! Write this up in manual...

What does this enable - 

5. Global gestures - eg. as offsets from lowest VCA or voltage - have those as groups, or we slide sync across them all

6. List of gestures, actions on gestures to list? overlay, repeat, move in the list, detach, slide, attach

7. How we control - with local voltage, with [6] and freeze/toggle[6], with local toggles, with timings of presses, with gestures??? with modeswitch

8. Maybe 2 resets - one full to mode 0/basic REC, other just resets counters and sequence... we had idea below...

To consider new scheme... so more like an instrument


* manual

** manual/description

ERD/VIA is the Way, the new modular life, severing hands from knobs
and tinkering, and establishing a new local skin regime of signals and
gestures for dis-embodied prostheses. VIA is a new touch and
finger-based un-controller for ERD and all modules, allowing voltage
control to be freed from erudite wiggling, and surrendered to purely
cut and segmented gestures. Voltages are placed on the surface of both
skin and module to facilitate cross-skin-s/pore-modulation and feedback.

Four identical sections allow touch and gesture to govern a single VCA
and a control voltage (CV) independently. Input, output and control
voltages can also be mixed by skin and gesture. Gestural sections can
be recorded and played back, chopped and cut, frozen, altered, sped
up, slowed down, repeated, severed, overlaid, ghosted and finally
dis-embodied and de-organised, all under touch and skin-feedback
control. Signals can be routed on the skin to act globally and
independently. 

//

The geomantic figure Via, or “Way”. This figure has all elements
active, revealing its dynamic nature; its linear form resembles a
road, at the changes afoot due to time and circumstance. It takes and
transforms every other figure and force into its opposite. It is a
figure of complete change, upheaval, and reversal; it is good with bad
figures and bad with good figures, though it is considerably more
favorable in matters requiring total reassessment and journeys of any
kind. It often shows a solitary time and path, between homes, cities,
and worlds.

Via has connections with the waning Moon and the element of
Water. Agrippa assigns it to the astrological sign of Cancer, although
Gerard of Cremona assigns it to Leo. It is an even, mobile, and
liminal figure. 

*Its inverse and converse figure is Populus, the People, while its reverse figure is itself.*

//

For manual: modes define operations on layers

one is always the ghost hand. a double of _____

switch ghost hands - 2nd layer

longer - what are the modes // how many modes?

basic operations - where we touch, what is vca, routing of signals,
freeze, micro/macro modes, rec/playback, lengths and timings!

instructions etc...

Image cards are cut out - disembodied hands, each of the 4 segments
cracked apart and somehow labelled... some uncut cards maybe to show
assembly/with text also on back for modes ... cut yourself out

** hardware

- +12v:75mA
- -12v:50mA
