#+OPTIONS: num:nil
#+OPTIONS: toc:nil

* notes 

    O
    |
(---+---)
    |
    0

sync and divination: 4 layers // binary figure

8 voltage areas/ 4 groups by newADC

moon/crescents - new moon - half - full - half 

note that lower crescents have voltage on them

note that OUTx is on pads (so after VCA) for feedback use...

NO!livevalue/overlay of globals??? - do we want that as can always hand sync

////

Q of global speed... *??? new top ADC is global control. also we have sync functions ????*

- ghost hands
- detached hand swop//cut off hand
- inversion - up is down // down is up

- ways of adding to play list/play zone, operations on play list/zone (and how is it doubled or not?)
- operations on tape and across 2 tapes
- sync/detach etc...
- chop/silence/insert etc... or is that operation on play list
- ghosts and orphans/blanks/silences

* 2024.002

*CTRL:*
- speed of playback, speed of selector
- gating on/off with threshold =  *stop/start playback*
- +how much we let through (volume of signal - see above) - also inversion of this amount+
- *TODO for CTRL:add to/subtract from value*: DONE:don't store limited/4095 value but only output* store up to 16 bits depending on mode/eg if % then just do that...
- marking of zones
- logical operations to list/zones, start and end, flow, attachments

[ops which change the value, ops which change the sequence of values]

*LAYER as ____ for the other:*

- speed, overlay/add-subtract, swop/why/how?, volume/VCA... depends on micromode?

so layer can be same as CTRL also above... and layer/ctrl can also be a gesture which determines operations... how we use both...

- feedback/recursion as layer can determine zones now...??? *how zones and zone parameters are determined*

layers can be swopped...

linked layers - so one layer is X for the other// *attachment* - swop and mark!

- layer as the sole playback value...???

*TOGGLES:*

Toggle for each position: short press = operation on position according to mode, longer press (1sec+) toggles position as active/inactive.

*GROUPS:*

- rec to groups as overlay
- that we want a gesture (CTRL or layer) to be able to move across sections

*ETC:*

- question of global time - time in a loop which we reference, extend that loop... time that x happens (now we just have delay which is cyclical also)
- roaming zones, ghosts, orphans, blanks/voids, spawnings

*PRESSES:*

Major and minor modes as changed for all active layers with the MODE button.
Shortest press increments minor, longer is for major.

Long and very long presses on mode are for soft and hard resets, again only for active positions.

Hard resets everything: check what that is - all modes, all counters, all states. All are now active....

Soft reset: resets rec counter to 0, playlist. We have to return to NADA mode as we can't say play on 0...

Toggle for each position: short press = operation on position according to mode, longer press (1sec+) toggles position as active/inactive.

newADC: mode dependent, eg. in nada: geomantic mode journey???, in P, R, RP: overlays...

*QUESTIONS/etc:*

- what were previous bounces (and where did they wrote to) eg.

REC+PLAY: ADC->speed/bounce/rec with overlay to other tape // freeze is swop // what does voltage do (overlay same tape minormodes here)

and bounce with extension past end/or looping bounce?

* Modes so far:

** micromodes

- do these include speed sync? no!

*TO FILL IN*

14/6 and brainstrom notes/modes:

Catalogue old and new modes and what we want to achieve/ how these fit with new zone model:

*0- basic mode and add to playlist: DONE*
NADA: GEOMANTIC: ADC->mode // freeze as freeze (in other modes as fake swop? invert etc) - NONinvert is take value from top, but what is "fake swop"?
REC: ADC->overlay to other tape // freeze as swop main tape... // further REC adds sections to main tape...// what we hear is voltage+overlay
PLAY: ADC->speed // freeze is swop // do we add to list on swop/play-play? yes try that
REC+PLAY: ADC->speed/bounce/rec with overlay to other tape // freeze is swop // what does voltage do (overlay same tape minormodes here)

// single play zone, option for bounce to extend the single zone // extend any zone with a rec!

*1- basic mode plays back playlist without add to playlist:*

IN progress: new major mode: we are always recording in NADA, and in
REC we select what to add to the tape, and in PLAY we play these, and
in RP?

//

Nada: add global from top, invert voltage, ghosts and mirrors - but does these stick around? yes - as livevalue function now

//

- use newADC as a kind of filter of the tape: doesn't let playback/record/re-record 
  value through below newADC threshold = silence or stops tape/speed
  thresholding = could either be playback value as 0/threshold or
  freeze tape/speed! for play we already have this in speed_stop arrays...

especially for bouncings!

//

resursive actions/dismemberments - how we can shift a whole range of zones - master zones which have functions and overlay others?

//

sync of sections - but also timing of sections - eg. with latest no_silence??

//

??//CTRL triggers recording of a zone in NADA

//

how to slide zones - ctrl can do this, but other layer how?

//

how much layer voltage can feedback onto layer selection and movements itself - recursion... layer and CTRL work together... threshold=layer...

//

*functions: overlay=add/subtract/VCA, invert, mask, bounce, speed, stop=gate/threshold=hold, zone itself params, spawn/multiple, mirror, ghost, blank-gap it, swop itself* - what else?

spawn blanks or copies or inverted mirrors

also write same data to both layers...

deal with other sections - *mobile gestures*

// *flip between bounce to same/other - that ops can be one zone on itself - how??? link to own zone layer???*

binary actions can work with a set threshold, threshold also from CTRL!

corewars: move, add, subtract, jump, conditionals

//

Q. of access to other sections and their counters??? groups...

//

*ghosts:*
- copies of other regions
- change to/insert in other regions playlists
- record to other tapes
- merge with others
- bounce/overlay 

*all is lists for play and record - and operations on lists*  
- what it means to mark as a ghost

*voids/orphans:*
- safe regions to be skipped over (but only makes sense if they are already recorded to)...
- swop zones between layers (now each layer has its own list of zones)
- offsets of rec zones across layers - so they are shifted, playlist can also have this?
- blanked areas - areas which are returned to 0 so we can write anew to them - new conception...

//

each section has: tape 1- each tape has -> list of zones // -> pointer to operations on list of zones...???
                       2-
//

from old playlist modes to rework for zones: P: adds to playlist and selection is within that - as in we zoom through
each element of playlist for start and end, can be recursive? adding
to itself and overwriting... how that works as it might span several
elements... and then these are all added?

//

CTRL selects when we bounce to other - threshold - other counter is running (sans overlay) or not

//

parallels rec and play zones - each play adds a zone (but where?)

//

We could pull out REC and NADA as these have no modes (but in REC we have double and other rec options, also if we reset)

as in REC we have no feedback on what we do. so it must be simple... but how we could signify a RESET there in further modes, to start again and not to add to!?

First mode (after full RESETT) is just record, no speed, and is always reset REC in this mode - but then we can leave it...

Then we change after that...

*So modes overlay and change what we have already recorded gesturally - but how can we move back or forwards through modes?? or is just fwd*

//older modes - also how we rework idea of sync of rec and overlay, live slidings and holds:

DONE5- [79]? - overlay one repeating section with different overlays REWORK mode 79, we can store original loop there(where?), and expand overlay in top bits ???*
so we store loop in bottom (so rec stays same) and expanding overlay is up to max length. decide what to do with speed but attempt as basic speed

- added but seems like playback 2 layers go out of sync TODO:this could also be exploited eg. freeze freezes/holds playback of overlay or we have 2 different speeds)*
we already have stopping/restarting with toggle here,,, but not *the 2 different speeds/how???*

- *modeX: record to both top and bottom and switch in play/overlay modes between - different lengths for each, merge, unmerge?*

- *we start to repeat say first section (or a defined island) and repeated overlay this on same tape! - overlay zone or parts of zone onto same layer*

- overlays: long and repeating overlay into one fixed section of playback (zone), loop overlay into fixed section of different lengths

* speculative/divination ideas

The geomantic figure Via, or “Way”. This figure has all elements
active, revealing its dynamic nature; its linear form resembles a
road, at the changes afoot due to time and circumstance. It takes and
transforms every other figure and force into its opposite. It is a
figure of complete change, upheaval, and reversal; it is good with bad
figures and bad with good figures, though it is considerably more
favorable in matters requiring total reassessment and journeys of any
kind. It often shows a solitary time and path, between homes, cities,
and worlds.

- moons from the top

*how can VIA be informed by concepts of AION and CHRONOS - divisibility of time/no present and all present/all depth*

- that now we have simultaneity of zones, sequential time and time of zone delay, ghost times

- divination methods, concepts of time: Franz(VF) and synchronicity-divination /Deleuze - aion and chronos
- how to implement scattering across space and time?

and from VF: 

So all these symbolic references to the meeting of those two worlds
seem to show that the world of time and the world of acausal
orderedness outside time, are two incompatible systems that cannot be
put together but are complementary. They are, that is, more than
complementary they are incompatible and we cannot imagine how they are
linked to each other, which is probably also the reason why we cannot
establish any law of synchronicity, for then the wheels would have to
be coordinated in a certain way.

The only place where the two systems link is at the hole in the centre, which means that they link in a nowhere, or in a hole.
This mysterious hole between the two worlds is in a one-sided way also represented in the Chinese incense clock.

These are the ghosts and orphans, the zones.

* HW/timing

- HW Connectors upper and lower:
SL 2X40G SMD2,54
BL 2X50G7 2,54	

- divider: 470K // another value now we have 12V

- filter: 15K and 47nF = 220 Hz (did we decide against 50Hz filter?)

- software: main divider of 24: 21 seconds recording length

- Latest all working but make sure we fix to MMBT3906 in BOM/assembly!

* TODO:

- DONEUPDATE all notes for HW, speeds and basic mode, plan of action!
- DONEre-test all VCA, noise and voltages
- DONEnew finger tests - Kaffe: triggers, length of trigger, new voltage?

- DONEnew speed mode to test
- DONEcondense and print older/newer notes/here
- DONEdefine basic HW and timing, filters below

- DONEdefine minor modes 
////PLAN

DONE- define and test basic mode: 20/2 
- *add/catalogue all modes - translate previous major modes into new scheme*
- test suggested new modes with/without minor modes
- wrap together

** minor modes in each state //these are not bits or bits as say options not binary

So minor modes define use of toggle, speed, newADC for major modes...

Nada: add global from top, invert voltage, ghosts and mirrors - but does these stick around? yes - as livevalue function now
Rec:
Play:
RP:

new: ghosts and mirrors for all:define these/how they operate

So each section can set a minormode which could also stick around - eg. NADA minors handle how we deal with voltages...

*** Speeds = P, RP

- sync speeds to top newADC or not
- 4 types speed: logspeed and logfast, + new logfast_stop and logspeed_stop

*** etc? 

- R,P,RP: to reset or not
- ALL@ sensitivity?
- RP: *overlay: extend overlay past end of recording = extend zone*
- R,P,RP: detach/unsync (how that happens - as it needs to unsync to a time - so ie. re-sync to say Freeze) - options for what freeze toggle does in certain modes
// detach is not really minormode...
detach would be to stop/start/move play/rec head... with freeze/toggle or with newADC

see: strip for overlay options there - and how those change with 2 tapes?

also as minormodes modify the major mode so they depend on this!

*** types of overlay

	    if (overoverlay==0){ //usual - now swopped for >
	      if (real[daccount]>values[daccount]) values[daccount]=real[daccount]; // only if is more than
	    }
	    else if (overoverlay==1){ // mod
	      values[daccount]+=real[daccount];
	      if (values[daccount]>4095) values[daccount]=4095;
	    }
	    else if (overoverlay==2){
	      values[daccount]+=real[daccount];
	      values[daccount]=values[daccount]%4096;
	    }
	    else if (overoverlay==3){
	      subs=values[daccount]-real[daccount];
	      values[daccount]=abs(subs);
	    }

*** older and expanding

- what minormodes we have so far? in [0]?

	//Rec - 
	
	//R+P: overlay
	overoverlay=((overminor>>1)&3); // 4 types of overlay
	overrec=((overminor>>3)&3); // types of recorded overlay 
	+overspeedmod=((overminor>>5)&1);// as playspeedmod+
	+ now it would have speeds also as play: 2 types speed: logspeed and logfast  

	//Play
	playoverlay=((playminor>>1)&3); // 4 types of live overlay
	playspeed=((playminor>>3)&1); // 2 types speed: logspeed and logfast  
	+playfreeze=((playminor>>4)&1); // 2 types freeze+
	+playspeedmod=((playminor>>5)&2);  // 2 types:  add recorded speed to real, of if real> // but this was for recorded speed only+


** CATALOGUE suggested major modes to implement and test

- DONE:xMode0:basic mode above+DONE - in testing
- *IN progress: new major mode: we are always recording in NADA, and in REC we select what to add to the tape, and in PLAY we play these, and in RP?*

most important is to have ability to rework what we just did live...
selection is key question

- use newADC as a kind of filter of the tape: doesn't let playback/record/re-record 
  value through below newADC threshold = silence or stops tape/speed
  thresholding = could either be playback value as 0/threshold or
  freeze tape/speed! for play we already have this in speed_stop arrays...

*eg.newADC sets a zone which can be defined (how?)*

- removal when not pressed newADC - again if is in R, P or RP...
- mode which removes silence...
- see 21/12/2023 below: - one tap: loop selection. next tap /next tap: add now marked section to playlist // how do we make selection? 3 taps?
----- port all previous mode ideas to new layer approach
- manipulations from notebook notes of layers and playlists
- properties of each position, layer and playlist and how these can be changed towards displacement and slippage eg. how we slip one tape across the other in RP mode
- like rehearsal and becomes active on press - hear what would happen if?
- writing over its own tape in specific areas - see islands - also overlay on itself and onto the other playback of itself
- ghosts and mirrors
- cutting and slicing/bouncing how?
- toggle recursive actions on the playlist...

** start to define new approach// see latest notebook and diary notes below // also for manual

States are: N, R, P, RP (enum)
Active position/voltage can change state and minor/major modes and undergo full and soft resets. Inactive position stays in its mode (eg. plays) until active/changes
There are two tapes (0 and 1) for each position 
x[[[There is a list of playbacks for each position which reference start and end on a tape, and which tape (0 or 1)
x[[[Rec just adds to end of tape/wrapping round until soft reset
Major modes are ported in and allow for recursive/fractal dismemberments and dislocations...
x[[[Pressing newADC in NADA zooms us into a new major mode (geomantic operation)

Each state has its own minormode +but+ and so do majormodes +apply to all states for each position+

Major and minor modes as changed for all active layers with the MODE button.
Shortest press increments minor, longer is for major.

Long and very long presses on mode are for soft and hard resets, again only for active positions.

Hard resets everything: check what that is - all modes, all counters, all states. All are now active....

Soft reset: resets rec counter to 0, playlist. We have to return to NADA mode as we can't say play on 0...

Toggle for each position: short press = operation on position according to mode, longer press (1sec+) toggles position as active/inactive.

newADC: mode dependent, eg in nada: geomantic mode journey, in P, R, RP: overlays...

////older

Minor modes // and they stay// are changed in all state... so each state adds its own options...
//NON!
N: how we handle voltages: add global from top, invert voltage, ghosts and mirrors(?), sensitivity?
R: only reset R or not on entry into R + N options // or leave that reset... // for newADc also type of overlay
P, RP: 4 types of live overlay, speedarrays
RP: 4 types of recorded overlay 

//older summary
- 2 tapes
- list of playbacks/gestures: list references layer (0 or 1): how do we manipulate list? 
- rec just adds to end of tape/wrapping round until full reset
- no recording of speed just of the effects of speed
- all minormodes: which ones stay across each state
- do we record newADC gestures?   
- activation/press per section of sections so maybe R,P, RP and M(mode sel) are not global!

** playing notes/ideas 22/2+

- hard to remember which is active or inactive ... would be nice to find a way to just be able to record one section on its own like instantly and not add to

local recording??? without active/inactive... in loop/rec mode where always records...

like mode is REC and local toggle starts and stops that (instead of active/inactive) but what of minormode and mode changes which depend on active/inactive

- DONEfull reset should work regardless of active or not and resets to active...

- how to say keep a steady offset overlay... (would be like freeze but...)

- to be able to kill one section - erase/reset only one part (i guess through not de-activating all - *shortcut to deactivate all???*)

- minormodes seem to work - test again

* diary notes

** 26/6

- fixes and fine in simulation but still clicks in all speeds
- also value still rising in overlay - to adjust senitivities

** 25/6

*fix: clicks at 1.0f and high speeds in playback??? - in test4.c playlodge has speed issues with more than one lodge TO FIX!*

- now clicks with basic speed...

To test:
- speeds with playlodge and multiple zones
- swopping again and options for RP

- micromodes... (<2sec press)... for each state and micromodes are now per layer and mode
- active/inactive and micromodes
- overlay and overlayx micromodes
- test new R modes - leave and come back in, overlap length
- modulations of incoming voltages with REC

- speeds in playback and micromodes there...

- *finish layers where necessary -*

/////// *playlodge is a mess with everything and speeds too*

- resolved a bit in test4.c for 1.0f but still speed issue - must be in playlodge - see how it sounds
- DONETODO: port in new bits//test speeds faster with extra zones

///

DONE:test//Fix swop layers as messy: implemented fullswop (was already in RP but have micromode for RP:

*TODO: swop P, swop R, swop both...*

we have: which layerzone list, which value, which upper/lower

permutations:

zone value lower/upper
0    live  lower 
0    ctrl  lower
0    live  upper
0    ctrl  upper

1    live  lower 
1    ctrl  lower
1    live  upper
1    ctrl  upper

8(3 bits)

At the moment we have:

R: f[d].masterL[0]

0: we use layer0 zones to write live to lower
1: we use layer1 zones to write CTRL to upper

layer0 is lower, live
layer1 is upper, CTRL

/* // swopps
layer1 is lower, live
layer0 is upper, CTRL
*/

then swop:
1: we use layer1 zones to write live to lower
0: we use layer0 zones to write CTRL to upper

layer1 is lower, live

so live is always lower

//altswop
1:use layer0 zones to write CTRL to lower
0:use layer1 zones to write live to upper
*so we just swop what is written to which - TODO as REC option*

//fullswop
1: we use layer1 zones to write live to upper
0: we use layer0 zones to write CTRL to lower


/////

P:

0: we use layer0 zones to read live from lower
1: we use layer1 zones to read CTRL from upper

then swop // different swop from rec one!
1: we use layer1 zones to read live from upper 
0: we use layer0 zones to read CTRL from lower

// altswop
use layer1 zones to read CTRL from lower
use layer0 zones to read live from upper

// fullswop we have I guess

NOTEbook notes:
- could be interesting to copy or overlap list of zones across each other eg. copy list of zones from one region to another 
- function to find which zones are within a region // other helper functions
- define blocks which are not overlaid
- mobile blocks
- split of layers so eg. one layer has say 3 zones defined by CTRL threshold and other has 1 zone which is continuous CTRL we used ...

** 24/6

DONE:Fix peak thing with BOTS as means that overlay can reduce things...
DONE:Re-organised overlays, some fixes...

overlayl: overlay of live value
overlay: for CTRL and CTRL layer no solo
overlayx: solo for reclodge and playlodge layerings
overlayRP: for RP live recorded overlaid onto rec

TODO:
- *Test all below and basic states, micromodes, speeds etc.*

Tests:
- DONEXXlayerswop/in NADA we have freeze: fixed
- DONEXXRP mode - should overlay? NOT! we need there new RP_options and reclodgex

//
*now we have overlayl which is for CTRL layer overlay - test with finished layers*
//

- *list overlays for each state!*

P: overlay of livevalue on playback, possible overlay of layer 2 on 1=overlayx //types of overlay/block/mask?
R: overlay value on what is there -> overlayx in reclodges
RP: as above. Q of what overlay is recorded/bounced// from/to

*overlayx has solo and is used in reclodge (overlay on rec) and playlodge (layers overlap)*

- questions of attachment and functions to resolve... also *how attachment works with swoppage...*

attachment of a function or by kind of slots? eg. speed slot: zone x on layer y... but don't have to fill all slots

also things like bounce as function. bounce to all current recording layers or assign layers (if we want to bounce to own layer)

*Some functions are in overlay. some more complex eg.threshold=stop-play*

Notebook notes:

- DONEas default in reclodges:RP default as overlay - but this needs to be done in reclodges* // types of overlay
- CTRL and CTRL layer can also be used for threshold=swop_layers and thus recursive
- list all such operations.

*Manipulations of zone parameters:*

as functions: ghost, spawn, mirror, gap, sliding and absolute/relative adjustments (relative to what?)

vs. *Manipulations of layers:*

speed, overlay (add, subtract, invert, VCA), swop itself, bounce to/from, stop/start

functions:

- spawn or mirror a (new) zone...
- use this parameter to change the start point of a zone (and if end is before?)
- as the speed of this zone...

Q. is zone y does this for zone x - how that attachment and designation works???

*real relative time // tape time*
- offset          //  start
- delay          //   end

*Trial functions or just parameter attachment*

eg. how do we trigger a function - at a threshold for a zone???
- we pass through at CTRL speed as a depth of the sequence of zones ...

CTRL (zone possibly) as a zoom through params and stop - speed through, absolute value, relative...

** 20/6

*Define/all infrastructure to test and catalogue... and move on to next stages...*

- CTRL and layers can manipulate:
- layer parameters such as speed etc. - or is that not playback params
- zone parameters such as start and end. ->recursion

Modes
Micromodes
Active/inactive
States/modes of operation: N, R, P, RP
Resets for active - soft and hard (do we ever reset all values?) - now in resett! *to test*
Zones and layers: parameters of each... each layer has a list of zones...
Groupings (TODO)... /of/ Sections..
CTRL and voltage - how to express those?
Second layer as control or overlay layer... (define the masking)...

TODO:

DONE/TEST - implement micromodes per layer (and per state - but states have different main layers:
DONE/TEST - implement basic RP mode: just write/add new values to existing lodges, playback existing lodges (do we check that there are)...*

//and sensi has no layer -get rid of livevalue...DONE

- *FIXING layerswop but need to test*
- Note that R and P are only ones which have micromodes per layer (N and RP don't have as there are no layers there)...
- *check speeds with playlodge thoroughly*
- *re-test all new R modes and also leavings, overlap etc. test incoming voltages and modulations* 
- *test all micromodes in basic modes*

Notes:

P and R: rec/play zones // define and manipulate zones

RP: no overlay, overwrite/extend // overlay/extend // bounce // define zones or parameters of zones (play/rec zones)

** 19/6

NON: //For NADA we can have add rec zones on no_silence and CTRL...

- DONE:record silence gap as offset - to test R_addlodges_silence FIXED + TODO: add leaving function thereDONE

NOTES:

- realtime recording with CTRL and threshold - with/without silence=offset - use CTRL playback also to define these zones

split to resolve between: define zones, record/playback zones // in R, P and RP!

- define precisely the timeline of each zone: offset, delay, lenth=end-start

eg. if (f[d].pl[f[d].masterLP].lodges[x].delcntt>=

(f[d].pl[f[d].masterLP].lodges[x].offset+f[d].pl[f[d].masterLP].lodges[x].realend+f[d].pl[f[d].masterLP].lodges[x].delay-f[d].pl[f[d].masterLP].lodges[x].start))
f[d].pl[f[d].masterLP].lodges[x].delcntt=0;

offset
delay (offset+end-start+delay)
length= end=start (= its ref into the recordings)

Remember to add offset if we wish for silence in leaving func:

if (tmpx!=0) f[d].rl[f[d].masterLR].lodges[tmpx].offset=((f[d].rl[f[d].masterLR].lodges[tmpx-1].offset)+f[d].rl[f[d].masterLR].lodges[tmpx-1].realend)+f[d].rl[f[d].masterLR].lodges[tmpx].sil-(f[d].rl[f[d].masterLR].lodges[tmpx-1].start); // this is for playback

** 18/6

-DONE! TO TEST* FIXED in test4. but need to to implement: We need to reset cnt and delcntt in play - so play always starts from beginning... why/how to fix ???*
- do we want to abstract out rec and play zone lists or keep as is??? question is adding of new zones... or use rl's delcntt
// and get rid of list passings
- DONE:option to reset all playing list counters as we do now in 002.c

TODO: 
- test all new R modes which should now be fixed...
- rec mode which doesn't just add zones or extend zone: looping rec
  (but either need to have rec set already or set rec zones and loop with CTRL) -> list of x looping zones to set one after another...
- modes for manipulations of rec and play zones

** 17/6

TODO:

- DONE:mode: each succesive rec mode adds one zone
FIX: NOTE for all:   f[d].ind=1; // recording TODO: this will need always to be per layer and also for leaving functions*

- DONE;added-leaving functions// DONEto test - also re-test R_addlodges_nosilence*
- DONE:record silence gap as offset - *to test R_addlodges_silence
- DONE:as overlayx = how we playback overlapping zones (nature of overlap?)*


///
- new RP mode to work on - and define possibles here for RP: skew of timeframes of R and P
- add second layer in playzone
- trial attach function to zones

////

- keep NRPRP scheme
- which layer we bounce to (from which) if overlap?
- what we record to each layer eg. if we have /one/ playback value what do we write to both layers... [or is per layer? spcify bounce as linkage?)
- copy R->P zones
- all as operations on zones

- DONEnull end function to implement...
- DONEnumlodges is now 24!

** 15/6

- *bounce cannot bounce to 2 overlapping zones* - so we need to specify or just catch this...

** 14/6 ***

NOTES:

*Two definite tasks: define zones, play from/record to those zones (can be seperate or at same time?)*

- CTRL defines a zone, recorded CTRL defines a zone // function=define a zone

- function attachment: function attached to zone X , zone X does function on zone Y, but a zone is a set of values...
[is this like a macro? scheme macros...]

- ways of defining rec zones. play zones using CTRL

Q. of how much "feedback" to our actions we have:
eg. RP: 
1) just rec to zones and play zones (no overlay - so just write fresh which was micromode of overlay/erase)
2) overlay (add/subtract etc. according to micromode)
3) bounce playback one zone to another - is that a function?
4) manipulations of zone parameters

but we have R and P lists of zones - each with 2 layers...

In R and P we can also have zone manipulating parameters of another... what are parameters of a zone?

// - are these defined as major modes now?

** 13/6

TODO: 

////

- First mode should add one zone (but every time we enter it) - or extend the very last zone...?? or just the one zone...
// DONE-to test! we need to resolve this... if number of zones is zero do first one, otherwise we extend the last zone??? trial

- DONE/fixed and code ported to 002.c  -> simulate latest rec zones code

but only plays last zone or one only - and with playlodge in simulation is scrambled - as rec mismatches play with delays*
maybe we need to write a playlist at same time - or we use flag in reclist*

FIXED in test4 -> TODOportDONE - DONETESTIT-wierd and also TODO:fix on exit from rec we close the last rec*
DONME-to test-how to register leaving the rec function - did we have this before... but will need to add leaving functions*

////

linkages/functions: speed/stops, block/mask, overlay, mirror, set a new zone, set itself or opposing zone, spawn a new zone, kill a zone

corewars...

notes:

- RP possibles: no bounce, add to rec zone list only, overlay on zones, overlay and extend
- N: rec one: add to it, rec on no-silence - what CTRL does in N?
- R: add to reclist
- P?

Mode on top, micromode right, N>R>P>RP on left - and all have speeding through --->

*reclist:* 
- live adding to rec list of zones + rec in progress - in sequence so we don't overlap. last delay is always in future
- rec to fixed list of rec zones
- changing rec zone list as we rec to it

*zones:*
- defining list of zones
- zone parameters and linkages - real time and fake time of the tape
- layer 1 and 2 - also ctrl defines new type of rec zones - CTRL defines 2nd layer as in 1st new mode
- what kind of things we want to do with zones: use them as CTRL, as overlay, extend zone in RP

*how can zones and code become dislocated/dismembered code [by] hands - macro dismemberment*

layer 0: value
layer 1: CTRL/overlay - and can swop

** 12/6

Describe methods so far!

List of what we wanted to achieve with modes!

TODO: 
- DONEadd fractional increment in play... will need floats // where do we get speed from? can override...

- DONEabove-adding new zones in rec to trial: is that R mode - when we have a
  press we add that zone until we release.. add succesively with no
  delay, and add offset/delay to prev entries

//notes:

- *question of passivity/brainstorm approaches eg. in NADA, CTRL triggers recording of a zone,,, still Q of modes!???*

That N/R and P/RP are somehow divided - as the first two have no playback or feedback in a way

maybe rework RPmode knobs - major, minor, state and held length on all speeds through each

- what was earlier feedback/RP schemes? how do we achieve earlier modes with our new scheme?

- overlay or add to end of rec

- how we add to list of play zones?

- what we need to change when we add to rec zones (offset, delay?)

- add open-ended rec zone as in first one to check out

** 11/6

/////
- still odd on fast reset but how to resolve (strip down) - resolved a bit with priority
///

- *one set of values can shift/slide the other set of zones*

- if we have: offset and delay (delay as time of main looping) then
  for a sequential list if we add a zone then we add (length+offset)
  to each entry before that (as length of main loop increased)

*TODO/DONE/notes:*

- DONEtested zero point (>40) which doesn't seem to be effected by sensi setting (0,1,2)
- DONEtested all timings and seems fine...
- DONE: trial no interpolation in slow playback 002.c - we can work with this
- DONEtry zone list at static speed + solutions from notebook for no/interpolation - *now we have no interpolation*
- DONEfix new rec zone list with offset and delay - default is we just extend the first zone...
- DONEremove playlist and implement play zone list (start with basic single zone from rec) - *needs second CTRL layer still - is that a function, attachment?*
- DONEadd new overlays and test all micromodes:
- new overlay micromodes for:
-- gate/threshholding which stops play (of a zone?) - *so is more a function than overlay- how we can integrate that? overlays as functions*

or overlay function contains the playback... *or we just stop play with speed as 0.0*

-- DONE: 1.0f float VCA - TESTED - need more overlays there for 3 bits =8 (we have 5)

///////

- where are overlays happening???

-> livevalue: what it says...
-> overlayx: in reclodge to overlay onto tape (what was there?), option to erase value 
-> overlay: overlay of CTRL for other layer in Recbasic, overlay in playback for livevalue...

*so we need overlay as functions for playback - test linked layers... CTRL as global speed or overlay function???*

///

Questions:

- how we do speed per zone... is there speed from CTRL or from layer, and do we have a global stop of playback???
- how top have CTRL layer as a set of functions, and how overlay can be a function which can stop a zone playing???
- zone has values and a functionality...
- add linkages

- *how we have speed as layer - speed within playzones? again another function of a zone - attachment?*

** 10/6

- *major layer is voltage, other is ctrl/overlay! but when we have multiple overlapping zones: we add that overlap then take action*

+_trial list of play zones and abstract out layer access (eg. pass layer list to play):+
- +but we need to take care of speed and wrap around - how we advance in that case//fractionally+
+- pass list of zones to play function (so can also be rec list)+
+- also for rec zones is not really sequential as it loops (looping zone vs. once through/sequential zone)+

new notebook notes:

*global/local speeds, speeds as layer, as CTRL???*

- how much layer voltage can feedback onto layer selection and movements itself - recursion...
- abstract out layer access to help with swoppings (so is not fixed which one is lower and which upper)
- each mode is a kind of game or method of divination

- Q. of modes per state (NRPRP)? or not // given question of mismatch mode 0 (one zone) -> slidings etc in other modes
- tape time/delay time/real time

- do we need all those counters when we have counters in each zone?
- slidings of zones can be: change start point on tape, change delay (when we play that part)?

time on tape// recorded time vs. real time

- *possible new model with a single zone list for all sections (zone has section etc), all simultaneous and abstracted out completely (so just values)*

- CTRL, VOLTAGE-V, RECV, REC CTRL: CTRL is control and/or records to other layer (CTRL or overlay layer), voltage is overlay

*can control be just a kind of overlay?*

- auto cutups?
- global time scales or fake global????
- one layer on CTRL layer can mask the other
- bounce one section to multiple others - 
- spawn zones (like in corewars? how much we go in that direction?)
- *key question is control of zone parameters*
- *soft reset removes all zones*

CTRL as _____ eg speed
minor layer as eg. mask

how we select this and what if both are used?

*CTRL is a gesture which governs zones depending on mode - sliding of zones, attachment of zones*

how do we (not) control it?
what are the functions and parameters that need to be (not) controlled

if we say: zone x on layer1 is played back with speed controlled by
zone y on layer 2... (or layer1 is always playback and 2 is ctrl but
can be swopped)

Q of attachments - is this same as linkage? as a modus. eg. each zone has a function, a ghost, a multiplier, a spawner...

TODO:

- +draw/print new layout+ and work on this towards manual layouts
- list all overlays//- list of what CTRL can do? and CTRL/layer functionality - how much feedback we can have here?

do we define one layer as always CTRL/overlay? is control just a  kind of overlay?

- list what we want to achieve with modes - eg. repeating islands, feedback and recursion
- DONEtest zero ADC + increase max number of zones - where is set? 
- DONEtrial list of play zones and abstract out layer access (eg. pass layer list to play)
- DONEdraft second mode with zones - start rec on touch - or this as first mode: plain rec vs. zone list?
- consider new simultaneous model above...
- list overlays and CTRL/layer functions and test/play these
- list major mode and resolve zones and questions
- implement and test major modes
- HW ordered/jlcpcb
- manual -> set of cutup riso prints for hand colouring


** 7/6

- no gating but just start/stop gate - but we can maybe implement gating we talked of as a kind of generic overlay

- attachments of functions to zones... and links between zones, eg. this zone is the speed function for that zone...

- sliding of zones... tap and slide, tap and do something (how to tap? on newADC - define gestures but how do we recognise or genericise these?)

USE CTRL to slide, link, attach - but need kind of tap thing...

or just slide with ctrl as we play through it?

- what CTRL does in NADA?

- each mode has another concept of time... time as the constrained time of the loop length, repeating...

- copy zone list from say rec to play, copy a portion of the list, the time of the list...

- recursive actions in RP

- swop between zones (that is now about zones and not layers) can be live and sequential writing form one to the other or...
[question now of one list of zones which refs a layer or list of zones per layer?]

** 5/6 6/6 - +new scheme to remove R,P,RP and N - to use active and inactive+

6/6 revert to old R, P, RP, N scheme //and also keep timings and layout *RE_TEST*

- as we want to be able to deal with zones in R and in P

zones can be marked with CTRL

////

- DONEtesting test4.c and new 002.c - added delay code for zones/lodges and fixed overlap code

each layer has its own zone list - added linkage in code... but linkage defaults to zero= *fix - to indicate no linkage*

Note that *delay in zones for length of prev zone means we can have sequences*

- *zones* how playlist can also have overlaps? so that it is not sequential: same as zones with delays too? playlist become play zones (same format)

now we have same zone scheme for playlist - but is 2 sets per layer... one of them is the parameter!

*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX*

** 3/6 + to try to finish// notes overview...

*How to implement new scheme below: sequences of manipulations, other layer (and CTRL) as parameter, overlap playlists, access other sections, groupings and sync*

** 16/5

*Notebook notes:*

prev:
- multiple zones across layers
- how we can record to multiple sections/groups?
- how play can overlap? as zones also with delays

new:
- how zones and layers work? linkage. eg. we want this zone on layer 2 to be the speed for this zone on the same or another layer...
*linked zones* - but that is more about playback... Q of playlist and zones
- rec can also be sequential, play can also be overlapping

?list of: real time eg. 00. in, out -> now becomes delay, length if any, layer/section, linkage

//Q-TODO: simplest op for rec is to write value to: section/layer/array=location using whose_dacc_counter//

how to deal with any linkage if we swop layers... (link is both ways?)

Q if we go for timing (global) or just have say number in sequence like in playlist, and same number for simultaneous...

- mobile gesture is about VCA/volume but also about *attaching* voltage or gesture from one section to another - *mobile gestures cut up*

-> gesture/voltage <- control (also a gesture so recursive) - eg. VCA of a voltage, movement across sections...

- attach one section to another - press first then second within x seconds... or near-simultaneous press...

*Field of events and coincidences - synchronicity:*

- a programming scheme to mark these
- to link sections (microcosm) as zones. -> relations over time...

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

** 1/5 - last code was here _001.c

- what is other layer in basic rec that we have??? overlay CTRL on voltage ---> when should just be CTRL???

** 30/4

- added individual counters so speedsampleplay accesses any of the sections and keeps count... also added to some of playlist code
- *other layer can be: speed, overlay/add-subtract, swop?, volume/VCA... depends on micromode?*

** 29/4 

- minormodes and sync
- groupings
- DONE:TODO: add safety to all reads and writes
- // *DONE: to test* //abstract out access across all sections: but then we need individual counters - array of counters for each section
- major modes defined
- Q of simulation!

*past notebook notes:*

Key - to throw down a figure, a gesture across the board
- to throw down a set of rules
- a figure or set of figures which follows a set of rules

*mobile gesture:* gesture is mobile...

eg. gesture which is a "series of voltages over time" can move (dependent on voltage ???ctrl?)

*CTRL voltage determines amount of recorded voltage there* - manipulation of properties of *"series of voltages over time"*

*how to set parameter eg. speed of playback and jump to next mode? new scheme*

- parameter of how much we play back (like volume or VCA of the gesture) rather trhan speed/as well as speed, both!

+ logical ops, start/stop playback etc...

*micromode = +add/-subtract / for gate/VCA/thing also*

- operations on sets of recorded voltage/playback/ by CTRL/by TOGGLE:

by CTRL:
- speed of playback
- gating on/off with threshold (also/or stop/start playback)
- how much we let through (volume of signal - see above) - also inversion of this amount
- DEP:TODO:add to/subtract from value*: DONE:don't store limited/4095 value but only output* store up to 16 bits depending on mode/eg if % then just do that...
- logical operations to list

[ops which change the value, ops which change the sequence of values]

by TOGGLE:
- swop operational layer
- gate/hold but keep playing (how to record that stop/start/gating and be able to speed it up/slow it?)

*a framework which allows for these sequences of manipulations!*

- how to have different speeds for each zone (but zones are in rec, not in playback...) can playlist have overlaps, multiples and how???

*Q. also of zone and its double/other layer which might be speed - say: differing zones for each param*

rec: zones
play: playlist and operations

** 18/4

Notebook notes:

TODO:
- minormodes and sync
- *groupings* (use active/inactive as grouping, also VCA and voltage sync maybe as minormode - more about subtracting one from the other)

that certain modes can operate on active voltages/areas/sections as a 'group'

- add safety to all array accesses

- abstract out access/play to any section - so then we need array of counters for each section - counters to other sections...

each section needs array of counters etc. into others... TODO: maybe refactor layers and playlist, lodges in layers - they are???

- majormodes defines - past modes also
- Q of simulation... how, eg. test adding to playlist, play of playlist...

- shih diviners board - rotation of one wheel across another for example...
- crystalline fragmentation/cutup/disembodies/throw of figures across the board/ throw of gestures


** 11/4 ++

- now lodge just has start and end, no length... so just loops around start and end - TEST/DONE:TODO: fixit
- second set of options in R_options for 2nd layer overlay: DONE but makes for 6 bits on R_options *TO_TEST*

DEFINE overlays:

N: livevalue opts
P: livevalue and overlay
R: overlay of CTRL and overlay on what is on tape (for each layer so x2) 
RP: as P_opts and R_options above - but no CTRL overlay (as CTRL is used for speed) - added RP_options

** 10/4 ++

recent notebook notes...

RP/R: stations/zones
P: playlist

orphans and voids

*ghosts:*
- copies of other regions
- change to/insert in other regions playlists
- record to other tapes
- merge with others
- bounce/overlay 

*all is lists for play and record - and operations on lists*  
- what it means to mark as a ghost

*voids/orphans:*
- safe regions to be skipped over (but only makes sense if they are already recorded to)...
- swop zones between layers (now each layer has its own list of zones)
- offsets of rec zones across layers - so they are shifted, playlist can also have this?
- blanked areas - areas which are returned to 0 so we can write anew to them - new conception...

8 sides, each has state, each state has minor and major modes and active/unactive state
CV/VCA share CTRL_CV

TODO:
- recheck startup again and again... sometimes on very fast reset...
- clear up questions/TODO below

+ *do we really want overlay in live value with top/lowest anymore? possibly not but leave as is*

- helper functions to code: eg. making marker points, access to other regions/recordings/sections

---> playlist is independent of a section... free!

//how to make more of a connection between zones and playlist - also if/how rec zones overlap

eg. if we record to 2 overlapping zones what happens - depends on overlap??

rec->play as a circle/cycle...

- decide on majormodes: notate previous and planned modes for TODO, how to get there...
- fix on micromodes - we have sensitivity still...

** 3/4

- +on repeated starts sometimes fails start - was this always the case??? tried with delays in main and moved main reset but doesn't fix it...+

DONEclear up R_options and all as is confusing with overlays, *TO_TEST: DONEstill RP_opts TODO

- messy abstraction as just farmed all out to functions now... needs to be more generic zone handling...
- RP implemented but needs more tests and all options

** 29/3

- DONEbasic rec and play seems to work - test rec adds to..
- reclodge now has 2 values for each possible layer...

DONE +TEST: added swop now, and rec of ctrl overlay to other layer...+

- TEST adding to playlist with option: f[d].playlistm - still need to finish add to playlist on swop and leaving
- TODO: basic RP mode: define it from before:

// REC+PLAY: ADC->speed/bounce/rec to other // freeze is swop // what
does voltage do (overlay same tape minormodes here) - see options for
end of other layer...// and for stopping

** 24/3 

- draft of basic rec and play to test - but some lose ends eg. playlist and swopping of layers is a bit odd/// RP TODO

** 20/3 +++

- new codebase now 001: 

*generic playback: DONE/to test* 

//how we deal with playlist: play from playlist (there is none), add or not to playlist: when??? only on swop or on leaving only:

- if nothing in playlist rec will create the first one... so we always play from playlist
- testing in test3.c - should we loop back to start in playback or??? - depends on length 

play options: not to play playlist = playfull=1 (but keep old playfull - how that works when we need to inc it)

f[d].playlistm=1;// adding to playlist
f[d].playlistp=1;// play back from playlist

TODO:
DONE- we should add to playlist when we hit the length but there should be an option to add or not..???
DONE - option to loop playlist at a certain point (eg. change playfull - permanently?) - pass full to speedsampleplay

*TODO://add recording (zone list): trial

- starting to replace layers with zone list

*ZONES/lunar lodges:

- zones/ghost zones/limits/loops for layers eg. redirecting to multiple zones (how to tag these)... always rec to a zone...

new idea of zones (also lists of zones?) crossing a way across/through a zone. that in mode 2 we also define a certain kind of zone*

// so zones allow things to become more generic...

define generic operations like set a zone, play at point and overlay, record to a zone (on layer x), operations on zones, expand zone

- assign function to a zone, temporary zones
- stacks of operations????

recording to a list of zones = simultaneous* (we record the same to
each zone).. function. record_to_zone - but fits with different notions
of time as the playlist is successive and this is immediate but is in
the future - the to-be-played-back

- +does the zone list thus replace the two layers and their properties...?+ - but keep layers for playback

+each zone needs its counters, length, starts - wrap is always on end:+

- *we have to do overlay in rec...

// lodges[0].start/length/l=layer 

swop would now be more like add zone on layer X

add to list of zones, extend zone, operation on a zone

*how basic rec/play is implemented in zones: that there is a maximum of one zone

each section has: tape 1- each tape has -> list of zones // -> pointer to operations on list of zones...???
                       2-

how this differs from what we have now. what is on top of list-> the most recent zone (circular list?)


/////

function lists for each state rather than switch (in progress as example)

check latest notebook notes...

** 15/3

// ODO: fix speedsamples for wraps and mod0s - also so it has ending/wrap - and test this before going further

// define - so start and length are clear but end is where we wrap! and ending in playlist

- new generic version with zones and also assign of speedsample - see play example
- how we genericise eg. add playlist on swop?

** 14/3

*Modes are/should be independent - and for N, P, R, RP*

- so we need to resolve mode 2: 

what R does in this mode exactly?  //ADC: zooms through start and end
  (at each press start, next press start) zoom/stop and playback is
  bounced to other layer... trigger swops layers

N major mode can be to always record (to one layer only?) 

N as always recording to one layer in loop of x seconds (see below) so
is last x seconds// how that works for empty other layer and what if
we have rec already - do we just add on

- NewADC/V is consistent as a kind of zooming eg. to set N as always recording last x seconds to one layer (but we have no feedback on that)


- at the moment we have just:

typedef struct layers_ {
  uint32_t rec_cnt;
  uint32_t rec_end;
  uint32_t rec_start;
  uint32_t rec_length;
  uint32_t rec_fraglength;
  float play_cnt;
  uint32_t othercnt; // running playlists
  float cnt; // for new speedsample
  uint32_t (*speedsamp[4])(float speedy, uint32_t lengthy, uint32_t start, uint32_t end, uint32_t dacc, uint32_t *samples);
  void (*reclayer)(uint32_t value, uint32_t dacccount); // to add these
  uint32_t (*accessreclayer)(uint32_t daccount);
  uint32_t (*accessplaylayer)(uint32_t daccount);
} layers;

- cnt now is othercnt is: used to set playlist points...
- play_cnt is: count as we play

and for each finger we have:

      playl playlist[PLAYFULLY+1];// list of playbacks
      uint32_t playcnt; // for index into playlist as we play
      uint32_t playcntr; // for index into playlist as we record
      uint32_t playfull; // how many elements in the playlist

- playcnt index is playback index for playlist, playcntr is recording index into playlist

/////

VIA is a journey, a way - that starts with the simplest options and becomes more complex

to look for patterns also in the code: eg. from R, mode2 eg. in sketch.c (so have format now)

** 13/3 refresh

Latest note: That rec-start in mode 2 is more like rec_fragment start and end...

- TODO etc from below...

DONE/to test: Option in RP to stop rec/bounce on speedstop - as default or as option?*

DONE/to testTODO: check end-point in mode2*

*TO ADD: what happens in mode 2 P and RP?*

P: adds to playlist and selection is within that - as in we zoom through
each element of playlist for start and end, can be recursive? adding
to itself and overwriting... how that works as it might span several
elements... and then these are all added?

each tapstart/end adds to playlist -> length and start... how we do that!?

recall what is on playlist: start, length and layer...

RP: how that works as R is already over-recording, now with bounce of playlist above

////

- TODO: re-work all playlist and speedsamples with end and length now - adding playlist

///////////////////////

- Where we are up to and planning? finish mode 2 and full tests there: checking sanity of playlist
- Notebook notes on manipulations of playlist and of twin tapes:

//misc notes

- ghosted areas by newADC - that we can cut across this, in playback
  and in bounce (also in rec, that we either jump across these like
  holes on a tape, or we don't write to that area)

- bounce to other region in the same tape. also bounce offset - how this works with swop of layers in RP or not in this case.. taps or newadc define region
// *or flip between bounce to same/other*

- newADC selects when we bounce to other - threshold - other counter is running (sans overlay) or not

** 2/3

permutation of manipulations/to get past special modes/generic fingers in manipulation of parameters

** 1/3

*What can be disembodied///dismembered macros? // how - generation of dismembered code for dismembered hands and control*

-2 layers against each other
-->each with rec_end/start/length, play_cnt
-playlist with list of end/start/length and layer
-params for each position: each position has layer, playlist: note we can also manipulate length of playlist and count into playlist...

*finger cuts finger* finger eg. newADC into these parameters, eg length/loop set,..., 
 
//

*Testing latest prototype:*
- for some reason R71 on trigger was 10k and not 1k as on schematic - fixed...
- DONE-all fine! TODO: test all other functions:

voltages: all fine
VCAs and Cs: 1, 2, 3, 4 - 3 seemed have issues but now is fine...
mode/play/rec: all functional
freezers: V:X, VCA: 
check output -> circle: 1, 2, 3, 4 

** 29/2

- how to simplify abstraction of entry and exit from a state!?
- how much of operations on playlist really make sense - as most are quite directed/not divinatory and as we can't really "point" to a section...
- DONE:cutting down length of typing fingers->f, layer->l, daccount->d

DONE I think/TO TEST! TODO: we need to fix overlap/wrap: overend for playlist adding for new mod0 scheme*

// notes: if start+end==length / add playlist or in next length/points????

** 28/2

2024_000 and new macros - strip back: deal with case 0

Q if we should reset playlist in new majormodes // - we don't and should not!

//fixed:now we have crash in new mod0 with new changes...

- again more abstraction - to maybe sketch from 2024.c a new one with just singular mode of playlist and new mod0N

// trial mode 0 with new speedsample...

*can there be a generic speedsample -> opts like: add/don't add to playlist, play from playlist only?*

/////

NON- playlist[0]=0->rec-end ->add this one in init! where?

//

CHECKED:check sanity of start, end etc...so otherend is lengthy/RENAME, start is start and rec_end is end

** 27/2

- trying to think how could be more algorithmic, steering processes and less about recording/controlling...

a la SIR/skin/Dark interpreter... multiple processes

What we have: 

- 8 voltages across 8 positions each with voltage control and with toggle // length of press
- 4 groups of 2 positions with one voltage controller (newADC)
- 3 buttons, length of press.

*TODO:*

TESTING- fix othercnt in speedsampleFIXEDTOTESTXS and improve speedsample for wrap//

DONE:in progress: to test TODO: matching P and RP, Q of playlist?*

- attempt to code majormode below...:

N: always recording in a loop (to both layers?)

R/RP: trigger swops layers
ADC: zooms through start and end (at each press start, next press start) zoom/stop

and playback is bounced to other layer...

RP and P: Q of how this works for P ... see below

** 26/2

FIXED: +Does it make sense that majormodes are for each state? do they need to match up?+

+eg. if in NADA we are always recording then we need other modes to take advantage of this!!+

THUS: each position has a major mode across all states...

New majormode from notebook:

N: always recording in a loop
R/RP: trigger swops layers
ADC: zooms through start and end (at each press start, next press start) zoom/stop
P: Q of how this works for P ... 

RP: how that works as R is already over-recording, but we can base on playlist below...

P: adds to playlist and selection is within that - as in we zoom through
each element of playlist for start and end, can be recursive? adding
to itself and overwriting... how that works as it might span several
elements... and then these are all added?

** 23/2

FIXED?BUG where we don't rec or play// stays in NADA - or could just be that we record NADA!

*TODO: test minormodes again esp in RP with overlaysDONE_but do ongoing tests, test sensitivity esp. speed, could be ok... still think on more fragmented, decayed

// minormodes tested in P, R, RP

- that it is too sensitive - explore this, question of panel... particularly when it comes to speed
- no speed or other sync options as this can be done by hand, so reduce minormodesDONE
- reduce types of overlay to those which work best...

//overlay can hit top in RP so we have unusable loop - can just be modulus as only overlay??? but we can overdub/blank in next rec if we go over

- NON///tested///removed//speed is like acceleration - eg. additive, each press is an increment (but we also need to reduce // fixed inertia)...a

// DONEfixed minormode BRK toggle time to 8

** 22/2

- Thinking about a more dislocated/shattered panel - also some way to have different areas of sensitivity ???*

- DONEwe need to remove so many minormodes in R and RP as these are live so we don't have time to press
- Q of sync/reset of play/NOTrec counters:

TODO: option to sync/not sync play_cnt in P when we swop sidesDONE - TO TEST on lowest bit- tested but bit same length...

- USAGE: tests by hand of minormodes*

eg in RP: - 1 bit recend // 0MAXREC, 1rec_end of opposing... // DONE:TODO: test live switching between these opts...

- Q of sensitivity - less sensitive - but then we don't hit top  - linear it is? *should speed be log or linear?

DONEadjust speeds so not so extreme*

- test next major mode - playback of playlist and how we add TESTING - seems fine so far

???? Added new speedsample functions: still to finish and also to add play from playlist AND add to playlist*

- *catalogue all modes here - and notate/translate previous major modes into new scheme*

** 21/2

- test all options in first mode now: these hardcoded and then with presses

minormode options short press on mode...

// for manual to record all options now
N/V options: 3 bits // TESTED
- sensitivity
- overlay of sync to top voltage... invert voltage added // top syncs to lowest

P options: 5 bits // TESTED and fixed
- which speedarray: lowest 2 bits: {logfast, logspeed, logfast_stop, logspeed_stop}; 
//NON- speedsync to top: next 1 bit (and top now syncs to bottom)
- types of live overlay: next 2 bits

R options: 2 bits // TESTED
- type of overlay of newADC onto other tape...

RP options: 3 bits //TESTED and with bugfixes // TODO: remove 5 bits play so becomes 3 bits DONE
- first 5 bits as Play above NON!
- 1 bit recend // 0MAXREC, 1rec_end of opposing... // TODO: test live switching between these opts...*
- 2 bits overlay type

// note: in R and RP reclayers we added overend which is when we reach end, so rec_end is always held at max!

** 20/2

TODO:DONE

DONE - Define presses also for *MANUAL* but double check these:

Major and minor modes as changed for all active layers with the MODE button. Shortest press increments minor, longer is for major.

Long and very long presses on mode are for soft and hard resets, again only for active positions.

Soft reset: resets rec counter to 0, playlist...

Timings: minor: <2, major: 2<4, soft reset: 4<6, hard reset: >6 approx checked

DONE:check again  with test_toggles in daccount>8*

Toggle for each position: short press = operation on position according to mode, longer press (1sec+) toggles position as active/inactive.

- All RP options to implement: REC_END option as 1 bit done

- Define/port major modes across...

TESTS
- DONEactive/inactive toggle:

// fixed toggle in play now (as would toggle on longer press too) - keep this for other toggles (in R and RP)...

- DONETEST/DONEimplement and test all presses lengths

- DONETEST recording over 21 seconds

DONEwhy pressing rec changes voltage - as we overlay newADC/// fixed in offsets

DONE- TEST playlist// test end of playlist so far...

///////
TEST base mode below: test all options once we have these implemented

TEST: test option to use rec_end of other tape, or MAX_REC as end in RP

// what were the overlay options:

- RP options*: overwrite/add playback/bounce onto tape x until we hit rec_end (of which tape) or we over_run till MAX_REC

- DONE: check overlay options below and refine:

1bit
overwrite at rec
overlay rec at rec

DONEand adding/overlay options= no overlay, peak >4095, onlyifmorethan, modulus

- how to implement test: playback ONLY of playlist // play and new add of playlist

** 16/2

TO TEST!//DONE:- to port latest playlist into 2024.c and trial there -> playing of playlist // recording of playlist

*idea of daemons and hands/VIA*

** 15/2/204

*Playlist:*
- Simple adding of plays in test2.c works but we haven't tried simultaneous playback/recursions
- settings and operations on the playlist... eg. where the playlist itself is looping/loop points in the list...
- start and stop of play/rec of playlist (means it just loops)
- when do we advance playcnt? when we hit length?

///

Properties of each layer/position and relation to others... relational interface

Properties of each layer/position:

2 tapes with play/rec counters and speeds
playlist

Relation to others:

4 groups each with newADC
top global voltage

** 14/2/2024

Playlist issues:

// to resolve start and end still - new counter

- we need to re=think playlist as is somehow recursive now... and doesn't work in test.c, nor in 2024.c ...

each play adds to the list, but when do we play that list and does playing the list add to the list...
and how do we start the list

also start and ends in each case

-when we enter play we need to record our start which is play_cnt, when we exit record play_cnt which is our end (except in case of loop or swop)
-when we loop what happens?
[-when we swop sides - each has its own play_cnt]

////

- +DONEremoved +1 from playlist inside - does that make sense ????+NON
- fix playlist addings and test in test.c

adding to playlist happens: when we hit end of one cycleDONE, when we leave play, when we swop layers...

///////////////

- option to reset play counter
- start is where we loop back to - always adds to play counter so is offset,,,
- somehow to genericise ops again so is easier to read and make options...

TESTING: test active/inactive, finish minor and major modes

+ plan scheme to finish

notes: 
-inverted voltage does make sense
-address what makes sense for VCA eg. additives to peak not so important as is more about open/close 
-newADC can be fine addition to voltages...

** 13/2/2024

*Basic mode we have:*
- test basic operations and options so far
- *DONETODO: add to playlist on playDONE, DONEadd RP options for end of overlay and overlay

adding to playlist happens: when we hit end of one cycle, when we leave play, when we swop layers...

- basic mode overlays to other layer // never changes own layer - could be live overlay own layer and playback overlay with opts to other...

** 12/2/2024

- hand comparator??? eg. compare against newADC
- DONEfirst mode - can add to playlist for later modes. *next mode just plays that, doesn't add*
// but if we enter second with no playlist then just play rec...

** 9-10/2/2024

- option to sync/not sync play_cnt and rec_cnt in P, RP when we swop sides*

// new panel and assembled PCB ordered 12/2/2024

moving all now as below but how to align panel...

//done as moons- Q of star voltages around!?

- *re. kaffe - why is freeze working better than mode toggle? - need to test kaffe again with slower toggle option every 8*

** 8/2/2024
DONE//
- +Thinking of redo pcb with outs at top/row, ins in row beneath at top+

other opts - enlarge base and move jacks closer and far as possible out...

base width: 100mm
height as: 109mm 

swop V and C jacks and move to extremes...

or... enlarge base, extremes and have 8 top row, 4 in square on edges and shift... 

offsets of jacks->panel 

panel jack is: x:145.45 y:70.45
pcb jack is:   x:145.5  y:64 

x same, y=+6.45 - but they are now inverted...

offset of main 40 pin connector:
panel: x102.0 y104.2

-24.1, -1.3

former PCB:x126.1 y105.5

new PCB: 134, 130.57

new panel pos should be-> 109.9, 129.97

also idea to have odd star voltages scattered around...

//////

NOTE: if in mode 1 option to keep same play point/overlay point for
both layers (also note REC_END will be the same so option to use
either doesn't make sense) ???? ???

** 7/2/2024

Kaffe: test.c

- voltage and newADCs - with differing sensitivity

main voltages: 3 or 4v sense0 // 6v sens1 // 
lower on crescents etc...
cables issue!

2v max newADC // 3v on sens1

- basic toggles of mode/toggle:

freeze fine...
modetoggle - sometimes... but not great....

- longer press on mode and on toggles...

longer press on mode fine
longer press on toggle fine

///

- first major mode can just be rec and playback if we don't want extra options
- test activation/de-activation of modes as way of detach/de-sync
- DONE: major/minor reset:  perhaps have now soft and hard resets - eg. soft resets rec and play tapes but doesn't change other mode stuff...*
- full test of first basic mode and all options

///

- RP options*: overwrite/add playback/bounce onto tape x until we hit rec_end (of which tape) or we over_run till MAX_REC

- check overlay options below and refine:

// overwrite it with playback+real
// add real only to recordings // add real+playback // types of add/overlay
// add playback+real at playback place???
// add real only at playback place

TODO: check these options eg writing at playback spot...*

also type of that overlap as we have for live

-loop/play till rec_end (only option we have) overlay=till own rec_end
(1), other rec_end(2) - if exists, extend until stops (3)
+ more options with other mode eg. marking points with toggle

-check we have rec_cnt in active layerYES - we write/extend other layer to check too

** 6/2/2024

First mode has no playlist - is really the most simple possible IMPLEMENT/test*

-In RP: types of recorded overlays, and length of overlay to fix*

from strip.c // recheck

// overwrite it with playback+real/overlay
// add real only to recordings // just >4095
// add playback+real at playback place???
// add real only at playback place // just >4095

- latest notebook notes for playlist:

problem with playlist is how we accommodate additions to rec... as we only add what we have from beginning in playlist...

options:
- new rec adds to playlist?
- we reboot playlist every time we have new rec

- playlist more as a journey -> R.P. so can be reset by R (or not, depends on mode)


/////

- test2.c in progress: walking through a playlist seems to work...

-> port into 2024.c DONE: to test - *we need to have playlist[0] established as reclength somewhere?*

how we deal with layer changes... should be easy...

port code... need to watch start and length

offset/start is issue or not in the test code?

DONE: BUT now we need to add in: add/rec to play list... eg. section x is added when it is played to the end or as we leave...

TESTED in test2.c adding as we go along but not sure how we deal with leaving... (as +1 is the next one in list)... watch we don't go over 118
last when we leave will be added next turn round...

** 5/4/2024

TODO: implement our basic first mode with all opts... and test all mode changes etc IN PROGRESS

= implement playlist in P, sketch out RP when we have that list: needs to be in speedsample... as can be overlaps...

maybe test first on lap///

// so playlist is: playlist which has start, length, layer, playfull which is number of elements and playcnt which is our counter into these

notebook notes:

- DONE: different modes for R,P,N, RP for each section and state [4] - check minors - yes these are the same: fingers[dacc].majormode[fingers[dacc].state]
- DONE: NADA basis - to test options there... also global sync is now to the final voltage at [6] TESTED

*double bounce - see diagram in notebook*

- simple operations across tapes and list which lead to recursive (writes over/to itself) or dislocated/dismembered results...
- for bounces key is speed and start/ends of bounce// also playlist
- did we write down slippage mode in R, maybe in RP where we slide across
- *for newADC in base mode above we need type of overlay in R!*
- what was self/island mode where we write to same tape in some part which repeats and how to adapt to 2 tapes // translate all prveioud major modes and new ideas here

** 4/4/2024

- added ACTIVE/toggle into latest code/to test there. Seems to work so far!

** 2/2/2024 

*note what we need to reset for new mode/mode change and for resett*

- TODO: pull out as much as possible from mode/switches// also use of function pointers for minormode options..
//
- DONE-all positions set as active at the start
- DONE-arrays for minor modes and states:       uint32_t minormode[4]; // N, R, P, RP // and use mask for each - say lowest x bits
- DONESENSESHIFT etc. is now no longer global so goes into STRUCT - but what is sensitivity for CTRL = 0,1,2,3 as these are VCA which don't have sensitivty
*so now sensitivity is for newADC and for Voltage -> manual*

** 1/2/2024

- embarked on new test code with all basics to test
- DONE - in test.c code: TODO: DONEimplement and test activation by way of extended TOGGLE/FREEZE - maybe a bit longer-adjusted to 300!
- port in basic rec/play/overlay from 1123 and test!
- lots to do/test eg. reset on entry into states
- where to put switch - inside functions

//

stm32f4xx_it_2024.c

new code base with:
- structure for each position/voltage inc. state of each (N, P, R, RP), all lists, and minor modes
- rework major and minors

- what is kept across states in minormodes? (eg, speedlog, type etc) - see below
- if we de-activate a position/voltage it stays in its mode. eg. R, P etc
- logic of minormodes as much as possible outside main switches/modes
- playlist: when do we play full list if P just adds to that list on each new entry
- does playlist reference layer?

** 31/1/2024

- +tested new moon panel fine...+
- how to code more clearly latest modes/layers and micromodes - structure?
- how much of micromodes stays across states - eg, speedlog across P and R+P is the same choice?

done but need to test//TODO: somehow we lost pointer/speedref code: TO TEST: DONE	    // minormode speed as a pointer now

** 25/1/2024

mode: R/P/RP?: (both layers play/record or swop layers): offsets/slide or detach:

- newADC offsets layer in time: offset as offset (newADC adds). offset as speed
- notion of alternate realities implies modes which record same gesture to both layers and then merge, manipulate, offset these. What ops?

** 24/1/2024

- list minormodes for basic set ups - in progress

- playback or overlay mix of tape/s at 2 different speeds (where we get these from?)

- detachment using newADC - we can unsync - shift play head to a new
  position instantly. delay rec for as long as we hold newADC or
  accelerate recording (speed again but not recorded)

how that last would work as it would leave blanks - or these are interpolated? -> *new major mode to try*

//
TO TEST: DONE	    // minormode speed as a pointer now

** 17/1/2024

Trial/decide on:
- Activate section: long freeze press (to test) - so we have 8 sections activated
- Geomantic code = mode select with newADC only in NADA: so we have 4 sections for that...
- Activated groups have R, and P. Do we have Mode on X or X is SEL, and where do we put modes?  mode is on X.

- +ORDERED: aisler /// moon figures for panel!TESTED+

** 16/1/2024 ++

- tested new speed arrays: logfast_stop and logspeed_stop which can now be added to the list of minormodes

- //decide on: modeXbutton[M] as mode or as extra action eg. SEL and then mode is on ADC

- notion of activation of a section (so next RMP is undertaken for those sections):
eg.
.press freeze and R,M,P (no freeze in that case): hold RMP->freeze->release - TRIAL: that seems to work in test code!
.press freeze for a longer time renders section active? // could be>>>???

- *is question of whether we activate section or not*

/////

NON:press newADC and R,M,P ->

DONE/18/1/TRIAL: ! press M/P/R ! new ADC goes up/down ! release button // enters that mode (and ADC is ignored) // we can't ignore as it just drops...

*either we activate a section (how to do multiple sections) and then press R,M,P for activated section... or we just have RMP for that section... which is more versatile*

is activation/local RMP across 4 or 8 sections - if we use ADC then is only 4!

** 13/1/2024 +notebook notes

- new top ADC as global control, added to by local values
- sync: sync speed as a minor mode? ie. all speeds add from top (what was [6] is now new ADC at top)
- divination

operations on list
operations on tapes - see latest notebook

eg. newADC runs through/scrolls through list of segments as index into tape

- NADA - micromodes sets use of touch/voltage (eg. add global from top, inversion, ghosts and mirrors) which stays through all...

BUT... *Q is that micromodes is global and major modes are local if they are determined by newADC*

solutions/questions:
- way of activating mode button locally? idea of active regions?

XXXthat modes are only selected by MODE button when that region is active (is being touched?)

- newADC for all modes/minor modes but then we lose newADC?
 or use mode X button as RESETT and as a new action (like REC, PLAY but could be SELECT/DIVINE)

Q of independent mode for each section? are modes global and where do we have them?

- that VIA needs to be more driven by impulses...

- *new major mode: we are always recording in NADA, and in REC we select what to add to the tape, and in PLAY we play these???*

// what is function of MODE button
// what is function on newADC

- we need major and minor modes to be selected, we need some kind of selection/divining mechanism
- major/minor should be local to voltage/or section (no to global modes)
- but would be nice to have extra mode (but how do we select to enter that)...
- changing major mode resets most things... minor modes not... so is it odd if only happens when we are active?

other possibles: simultaneous presses, gestures on newADC

- *touch based divination - what as simple mechanism can be (an unknown, non-causal mechanism for synchronicity)*

/ that there is a series of 4 anti-clockwise sections, make more of sections (that they can also mirror each, contribute to each other in the section)...

TODO:
- test major mode above: list of experimental modes
- trials for active section/voltage mode selects: IN PROGRESS
- TESTED/DONE:test new speed scheme // array

** 8/1/2024

- removed senseshift but still needed offset reductionDONE

TODO:

- HW tests:

- test voltages...

- FIXED with move of init code: +offset of 1.1V? on voltages (but not after programming???) offset is in DAC writing... (not in ADC)!+
+if we use DAC_OutputBuffer_Enable then we have 100mV offset... but we did not have this before...+

- noise seems ok on voltages...

- test VCAs (ADC is filled crescent)

no noise

- test new ADC:

all fine

toggles:

- none really working well, sticky and jittery. why? cold/dry weather but how to adjust... 

// we have 3.3M pulldown but what was it in the previous board? *4.7M - we just now replaced the one on MODE - changed on schematic*

and we extended delay and BRK -- but extending delay causes jump when we touch 

// 256 operates ok,,, but 300mV offset
// 24 gives 200mV
8 seems the limit but no toggle

*r71 is now 1K: changed on schematic* and we test removal of diode but we should leave it...

*now we have DELB as 42 and is fine... but still odd offset - negative at top and positive at bottom??? leave for now as is not terrible... and is worse with changes to GPIO*

// now in TEST_TOGGLES we have all of them in one so does not repeat delay

timer of toggle now:

- resett seems to work and we will only use short tap or reset...

- SW tests:

- mode 0 in 1123 not working now...??? as probably due to toggles!

- fix up test modes for next week: stm32f4xx_it_test.c

* recent notes

- *this is for NADA: new ADC as accelerating through modes (so is not ADC value=mode) as a *journey* // length of press and speed-> position
- DONE/TRAIL* - this is also a new model for speed - no press=no advance/hold voltage/record voltage
- we can also use this to mark sections - fwdwind and mark

** 21/12/2023

latest notebook notes:

PLAY
- one tap: loop selection. next tap /next tap: add now marked section to playlist // how do we make selection? 3 taps?

- eg. to cut up gestures we just keep what is there as long as we hold freeze or as long as new ADC is > level

is cut up into play list or as re-record to tape 1 or 2

- NO!playlist is single but has 2 strands? tape 1 or 2 - and indications to mix, add etc...

or we have 2 playlists or just one and all depends on current tape?

control gesture->>>[--------------] tape 1
                   [--------------] tape 2

parallel gestures which can repeat/mirror/combine/bump one to other. swop

parallel worlds/gestures - rise, dip, slope etc...

** 13/12/2023

more on gestures:

eg. to cut up a gesture we just keep what is there as long as we hold freeze/cut out the other // or as long as new ADC > x

in play list...??? but is more a question of tape and of re-recording

- is a single playlist or we have 2? single with 2 strands/refs to tape 1 or 2 and indications to merge/add etc???

** 11/12/2023 - *that VIA must be divinatory*

that divination is also a form of compression

from 4 cards each of 4 bits (total 16 bits, 2 bytes) to a future or a past...

that VIA/module offers possible algorithmic futures for the gestures // 2 layers, 2 futures

// how we understand and interpret a gesture?

as a set of values, individual values are meaningful, or as a relation between values over time - the last peak, rising, falling etc.

in dark interpreter they become values/codes within software but this approach is not working as ...

record and devise gesture maps / mapping journeys

** 10/12/2023

- how we can use new gesture from ADC pad as controlling option 
- to summarise what we are controlling -> - - *Play list and rec tape per layer*

so control is over the play list (single?)
modes describe interaction between layers eg. bounce etc...

*or we go full geomantic with new ADC gesture across all 4 parts in diamond shape*...

more notes/ again towards defining behaviours...

- *Play and list and rec tape per layer*

*rec:* - just adds and overlaps and is as a tape would be

*play list:* eg. [0-10][0-10][20-160]

how we manage this list in play mode... 

is it cumulative (add in and out to the list) but we need then 2 modes in play mode (and to toggle between and to toggle layer (or that is just in NADA)

2 play modes: select = play tape and select//add to list, play list only (what we toggle there - remove from list?)

//

headless
fingerless
handless

** 28/11/2023

- 2 layers // 2 code streams

- freeze in NADA freezes any mode change for that section - so modes
  can be per section (how could be also per current layer that we freeze on)

- freeze in NADA toggles layer??? how do we know which?

- NADA always records (to one or to both layers) and play sets START and END (do we have code for that): speedsamplestart
Q. of how we add to this in the case of an overlap - see above

- *long and short taps on freezer for different behaviours* [could also be on rec and play]

*that there can be the tape itself and a list of (playback) references
into that tape* // for example we can have list of repeated segments
or long looping part (how many times it loops) - how to implement
this, and also how on the record side...

record list, play list... how we handle these... and this is for each layer?

record list is additive

play list is determined by modes in play and touches...

** 27/11/2023

2 sides // 2 sides each of the 4 // hermaphrodite 2 layers

- major modes can differ across functions (rec, play etc)

*does it make sense if there are also different mode for each layer?*

demonic/good hermaphrodite...

- detach could be in minor modes...

- review and define from all notes... review minormodes

*we mention slowing a gesture - slow speed to other side... TODO* or we slow recording on one side?

// notebooks:

- layer operations:

1: [][][]
2: [    ]

whichever is longer// *we can reset length of one/both layer*, hold/slide/desync one layer...

define properties of layers: 

add/subtract/merge etc.

these are all modes which operate on same enlarging set of
gestures... [Q also if we can say remove last recorded bit - we just
need to record its start and end, but what if it is an overlap - makes it tricky? - still q of list of gestures]

one layer is a ghost and we can swap that designation...

ops: remove silence for voltages...???

*cycling through alternate ways of reading recorded gestures*

*algorithmic easter egg*

add or subtract gestures in play mode

detachment

*still todo modes above esp. - *still could do thing where we start to repeat say first section (or a define island) and overlay this on same tape!*


** 24/11/2023

- 2 layers //4 sides // each of 2 layers each

That VCA and voltage are not/should they be/ fixed to one side 

eg. they can reflect - so say we can add VCA and voltage and output on both // does that make sense...

swop them around... but they have quite different functions... so maybe doesn't make sense... 

** 22/11/2023

- if we sync counters across 2 layers then we have issue as one might go past end of other! // speedsampleL DEP!

** 21/11/2023

- struct for each layer DONE - what does it enable us to do, or what are issues/questions:

ending of each, sync of swopped playback as each speedplay has its own
counters (or these become one - for each layer: speedsampleL),
question of overlap for each layer, which layer on entry into play
etc, if layer is not there what we do in playback?, can have more
function pointers for different options also...

/////
- question still of list (as it should also indicate the layer) - we need list to be able to remove! *DISCARDED for NOW*

- 2 layers/tapes: speeds, slide across

*what cases we need to code for // eg.*

-record playback speed change on layer 1-> layer 2

but how do we get feedback for this...

*now in new file but not toggle// always NO USE OF TOGGLE:
toggle starts to record to layer2(overlay) speed changes from layer1 and we hear those changes (we are in 1). toggle stops and stays with 2... so no overlay recorded. local and global speeds*

- rec toggles 1 or 2 to record to (but no feedback so how we know which?)
- play toggles which one but one maybe blank?

twinned layer operations: swop, merge/add/subtract/mix, bounce to/record from one to other with speeds, slide across, different speeds

list ops: add (new rec), remove, swop, copy/double, collapse=join, chop?as in cut silence and render as new lists, hide/unhide, detach

-islands and notes above and below...

** 19/11/2023

questions/thoughts:

- do we extend overlay? was marked as TODO minormode option in [0]
- what minormodes we have so far? in [0]?

	//rec -nada
	
	//overlay
	overoverlay=((overminor>>1)&3); // 2 types of overlay
	overrec=((overminor>>3)&3); // type of recorded overlay 
	overspeedmod=((overminor>>5)&1);// 

	//play
	playoverlay=((playminor>>1)&3); // 4 types of overlay
	playspeed=((playminor>>3)&1); // 2 types speed 
	playfreeze=((playminor>>4)&1); // 2 types freeze
	playspeedmod=((playminor>>5)&2);  //

*which of these we retain?* run through them

- how play and rec can be generic? what are the exceptions so far?

- how we could record slowing down of a gesture - needs a place to record into (layer or new entry in list)?

- if we have list and add to it what happens if we run out of space - last entry stops... (is not like a tape loop)

typedef struct listy_ { 
  uint32_t start[120];  
  uint32_t gap[120];
  uint32_t length[120];
  float speed[120];
} hands;

static hands fingers[8];
static uint32_t howmanyfingers[8]={0,0,0,0, 0,0,0,0};

** 19/10/2023 notebook notes

- operations on a list of gestures
- that each mode entails a set of operations on that list
- how can we have successive changes in repeated segments

** 26/10/2023

*To start to define new direction based on latest notes*

notebook notes:

- Q of new speed rec, all is overlay, or *speed global as [6] voltage and local voltages*... no doublings 
- so we can maintain, modify or erase overlay as we progress
- and use overlay as speed or not...
- additive switch/swop across 2 tapes (2 tapes, 2 speeds - how?)
- algorithmic control as pulse in to freezers/toggles, minimode
- *translate modes we have into ongoing series of transformations*

- what we can do with a list of gestures, list of modes: earlier idea of push/pop/ *stack* button... 

earlier idea was: Notes: frozen levels are saved to a stack and can be popped off the stack, various over-rides...????

circular stack of gestures - how to add, remove and what happens when we run out of room??? 

** 25/10/2023 *KEY*

- trying to re-think towards more fluidity// notebook notes:

1. We could pull out REC and NADA as these have no modes (but in REC we have double and other rec options, also if we reset)

as in REC we have no feedback on what we do. so it must be simple... but how we could signify a RESET there in further modes, to start again and not to add to!?

First mode (after full RESETT) is just record, no speed, and is always reset REC in this mode - but then we can leave it...

Then we change after that...

Question of no double record, no speed rec? and top bits are always ghost/overlay with voltage 6 as speed (and seperate its playback speed)

*So modes overlay and change what we have already recorded gesturally - but how can we move back or forwards through modes?? or is just fwd*

And do we keep micromodes (yes)... but these do not include reset on REC...

3. top [6]voltage is always control - so no freeze on that. but is also output so we can use it for sync...

4. *Options for algorithmic control*

So we can use external voltage input via fingers to trigger freeze/toggles! Write this up in manual...

What does this enable - 

5. Global gestures - eg. as offsets from lowest VCA or voltage - have those as groups, or we slide sync across them all

6. List of gestures, actions on gestures to list? overlay, repeat, move in the list, detach, slide, attach

7. How we control - with local voltage, with [6] and freeze/toggle[6], with local toggles, with timings of presses, with gestures??? with modeswitch

8. Maybe 2 resets - one full to mode 0/basic REC, other just resets counters and sequence... we had idea below...

To consider new scheme... so more like an instrument


* manual

** manual/description

ERD/VIA is the Way, the new modular life, severing hands from knobs
and tinkering, and establishing a new local skin regime of signals and
gestures for dis-embodied prostheses. VIA is a new touch and
finger-based un-controller for ERD and all modules, allowing voltage
control to be freed from erudite wiggling, and surrendered to purely
cut and segmented gestures. Voltages are placed on the surface of both
skin and module to facilitate cross-skin-s/pore-modulation and feedback.

Four identical sections allow touch and gesture to govern a single VCA
and a control voltage (CV) independently. Input, output and control
voltages can also be mixed by skin and gesture. Gestural sections can
be recorded and played back, chopped and cut, frozen, altered, sped
up, slowed down, repeated, severed, overlaid, ghosted and finally
dis-embodied and de-organised, all under touch and skin-feedback
control. Signals can be routed on the skin to act globally and
independently. 

How it can be used as a live, gestural controller in its most simple configuration (mode 0)... further dislocations...

//

The geomantic figure Via, or “Way”. This figure has all elements
active, revealing its dynamic nature; its linear form resembles a
road, at the changes afoot due to time and circumstance. It takes and
transforms every other figure and force into its opposite. It is a
figure of complete change, upheaval, and reversal; it is good with bad
figures and bad with good figures, though it is considerably more
favorable in matters requiring total reassessment and journeys of any
kind. It often shows a solitary time and path, between homes, cities,
and worlds.

Via has connections with the waning Moon and the element of
Water. Agrippa assigns it to the astrological sign of Cancer, although
Gerard of Cremona assigns it to Leo. It is an even, mobile, and
liminal figure. 

*Its inverse and converse figure is Populus, the People, while its reverse figure is itself.*

//

fixed pattern, mobile pattern in geomancy/divination - rotation of one mandala against the other

2 kinds time
synchronicity

For manual: modes define operations on layers

one is always the ghost hand. a double of _____

switch ghost hands - 2nd layer

longer - what are the modes // how many modes?

basic operations - where we touch, what is vca, routing of signals,
freeze, micro/macro modes, rec/playback, lengths and timings!

instructions etc...

Image cards are cut out - disembodied hands, each of the 4 segments
cracked apart and somehow labelled... some uncut cards maybe to show
assembly/with text also on back for modes ... cut yourself out

Extended manual/Reader/reading list:

excerpts on geomancy
von franz
all chinese divination wheels, pipes and diagrams

** hardware

- +12v:75mA
- -12v:50mA
