#+OPTIONS: num:nil
#+OPTIONS: toc:nil

* notes 

    O
    |
(---+---)
    |
    0

sync and divination: 4 layers // binary figure

moon/crescents - new moon - half - full - half 

  M

R   P

MODE: X | ADC | FREEZE | NOTES
-------------------------------
N: 
R:
P:
R+P: 

////

*Basic mode to implement:* (each mode is defined by ADCs and freeze behaviour)

NADA: GEOMANTIC: ADC->mode // freeze as freeze (in other modes as fake swop? invert etc) - NONinvert is take value from top, but what is "fake swop"?
REC: ADC->overlay to other tape // freeze as swop main tape... // further REC adds sections to main tape...// what we hear is voltage+overlay
PLAY: ADC->speed // freeze is swop // do we add to list on swop/play-play? yes try that
REC+PLAY: ADC->speed/bounce/rec with overlay to other tape // freeze is swop // what does voltage do (overlay same tape minormodes here)

Q of global speed... *new top ADC is global control. also we have sync functions*

NADA = no tape

- ghost hands
- detached hand swop//cut off hand
- inversion - up is down // down is up

- ways of adding to play list, operations on play list (and how is it doubled or not?)
- operations on tape and across 2 tapes
- sync/detach etc...
- chop/silence/insert etc... or is that operation on play list

* speculative/divination ideas

The geomantic figure Via, or “Way”. This figure has all elements
active, revealing its dynamic nature; its linear form resembles a
road, at the changes afoot due to time and circumstance. It takes and
transforms every other figure and force into its opposite. It is a
figure of complete change, upheaval, and reversal; it is good with bad
figures and bad with good figures, though it is considerably more
favorable in matters requiring total reassessment and journeys of any
kind. It often shows a solitary time and path, between homes, cities,
and worlds.

- moons from the top

*how can VIA be informed by concepts of AION and CHRONOS - divisibility of time/no present and all present/all depth*

all present is NADA mode... endless presence

- divination methods, concepts of time: Franz(VF) and synchronicity-divination /Deleuze - aion and chronos
- how to implement scattering across space and time?

and from VF: 

So all these symbolic references to the meeting of those two worlds
seem to show that the world of time and the world of acausal
orderedness outside time, are two incompatible systems that cannot be
put together but are complementary. They are, that is, more than
complementary they are incompatible and we cannot imagine how they are
linked to each other, which is probably also the reason why we cannot
establish any law of synchronicity, for then the wheels would have to
be coordinated in a certain way.

The only place where the two systems link is at the hole in the centre, which means that they link in a nowhere, or in a hole.
This mysterious hole between the two worlds is in a one-sided way also represented in the Chinese incense clock.

* HW/timing

- HW Connectors upper and lower:
SL 2X40G SMD2,54
BL 2X50G7 2,54	

- divider: 470K // another value now we have 12V

- filter: 15K and 47nF = 220 Hz (did we decide against 50Hz filter?)

- software: main divider of 24: 21 seconds recording length

- Latest all working but make sure we fix to MMBT3906 in BOM/assembly!

* TODO:

UPDATE all notes for HW, speeds and basic mode, plan of action!

- DONEre-test all VCA, noise and voltages
- new finger tests - Kaffe: triggers, length of trigger, new voltage?

- DONEnew speed mode to test
- DONEcondense and print older/newer notes/here
- DONEdefine basic HW and timing, filters below

- DONEdefine minor modes 
////PLAN
- define and test basic mode: 20/2 
- 21/2+ and add/catalogue all modes - translate previous major modes into new scheme*
- full tests of basic first mode 21/2+

- test suggested new modes with/without minor modes
- wrap together

** minor modes in each state //these are not bits or bits as say options not binary

So minor modes define use of toggle, speed, newADC for major modes...

Nada: add global from top, invert voltage, ghosts and mirrors - but does these stick around? yes - as livevalue function now
Rec:
Play:
RP:

new: ghosts and mirrors for all:define these/how they operate

So each section can set a minormode which could also stick around - eg. NADA minors handle how we deal with voltages...

*** Speeds = P, RP

- sync speeds to top newADC or not
- 4 types speed: logspeed and logfast, + new logfast_stop and logspeed_stop

*** etc? 

- R,P,RP: to reset or not
- ALL@ sensitivity?
- RP: overlay: extend overlay past end of recording
- R,P,RP: detach/unsync (how that happens - as it needs to unsync to a time - so ie. re-sync to say Freeze) - options for what freeze toggle does in certain modes
// detach is not really minormode...
detach would be to stop/start/move play/rec head... with freeze/toggle or with newADC

see: strip for overlay options there - and how those change with 2 tapes?

also as minormodes modify the major mode so they depend on this!

*** types of overlay

	    if (overoverlay==0){ //usual - now swopped for >
	      if (real[daccount]>values[daccount]) values[daccount]=real[daccount]; // only if is more than
	    }
	    else if (overoverlay==1){ // mod
	      values[daccount]+=real[daccount];
	      if (values[daccount]>4095) values[daccount]=4095;
	    }
	    else if (overoverlay==2){
	      values[daccount]+=real[daccount];
	      values[daccount]=values[daccount]%4096;
	    }
	    else if (overoverlay==3){
	      subs=values[daccount]-real[daccount];
	      values[daccount]=abs(subs);
	    }


*** older and expanding

- what minormodes we have so far? in [0]?

	//Rec - 
	
	//R+P: overlay
	overoverlay=((overminor>>1)&3); // 4 types of overlay
	overrec=((overminor>>3)&3); // types of recorded overlay 
	+overspeedmod=((overminor>>5)&1);// as playspeedmod+
	+ now it would have speeds also as play: 2 types speed: logspeed and logfast  

	//Play
	playoverlay=((playminor>>1)&3); // 4 types of live overlay
	playspeed=((playminor>>3)&1); // 2 types speed: logspeed and logfast  
	+playfreeze=((playminor>>4)&1); // 2 types freeze+
	+playspeedmod=((playminor>>5)&2);  // 2 types:  add recorded speed to real, of if real> // but this was for recorded speed only+


** CATALOGUE suggested major modes to implement and test

- +Mode0:basic mode above+DONE - in testing
- *new major mode: we are always recording in NADA, and in REC we select what to add to the tape, and in PLAY we play these???*

most important is to have ability to rework what we just did live...
selection is key question

- use newADC as a kind of filter of the tape: doesn't let playback
  value through below newADC threshold (silence or stops tape/speed
  thresholding = could either be playback value as 0/threshold or
  freeze tape/speed)
- mode which removes silence...
- see 21/12/2023 below..
- port all previous mode ideas to new layer approach
- manipulations from notebook notes of layers and playlists
- properties of each position, layer and playlist and how these can be changed towards displacement and slippage eg. how we slip one tape across the other in RP mode
- like rehearsal anbd becomes active on press - hear what would happen if?
- writing over its own tape in specific areas - see islands - also overlay on itself and onto the other playback of itself
- ghosts and mirrors

** start to define new approach// see latest notebook and diary notes below // also for manual

States are: N, R, P, RP (enum)
Active position/voltage can change state and minor/major modes and undergo full and soft resets. Inactive position stays in its mode (eg. plays) until active/changes
There are two tapes (0 and 1) for each position 
There is a list of playbacks for each position which reference start and end on a tape, and which tape (0 or 1)
Rec just adds to end of tape/wrapping round until soft reset
Major modes are ported in and allow for recursive/fractal dismemberments and dislocations...
Pressing newADC in NADA zooms us into a new major mode (geomantic operation)

Major and minor modes as changed for all active layers with the MODE button.
Shortest press increments minor, longer is for major.

Long and very long presses on mode are for soft and hard resets, again only for active positions.

Hard resets everything: check what that is - all modes, all counters, all states. All are now active....

Soft reset: resets rec counter to 0, playlist. We have to return to NADA mode as we can't say play on 0...

Toggle for each position: short press = operation on position according to mode, longer press (1sec+) toggles position as active/inactive.

newADC: mode dependent, eg in nada: geomantic mode journey, in P, R, RP: overlays...

////older

Minor modes // and they stay// are changed in all state... so each state adds its own options...
//NON!
N: how we handle voltages: add global from top, invert voltage, ghosts and mirrors(?), sensitivity?
R: only reset R or not on entry into R + N options // or leave that reset... // for newADc also type of overlay
P, RP: 4 types of live overlay, speedsync, speedarrays
RP: 4 types of recorded overlay 

//older summary
- 2 tapes
- list of playbacks/gestures: list references layer (0 or 1): how do we manipulate list? 
- rec just adds to end of tape/wrapping round until full reset
- no recording of speed just of the effects of speed
- all minormodes: which ones stay across each state
- do we record newADC gestures?   
- activation/press per section of sections so maybe R,P, RP and M(mode sel) are not global!

** playing notes/ideas 22/2+

- hard to remember which is active or inactive ... would be nice to find a way to just be able to record one section on its own...

local recording??? without active/inactive... in loop/rec mode where always records...

- full reset should work regardless of active or not and resets to active...

- how to say keep an offset overlay... (would be like freeze but...)

- to be able to kill one section - erase/reset only one part (i guess through not de-activating all - shortcut to deactivate all?)

- minormodes seem to work - test again

* diary notes

** 22/2

- *Thinking about a more dislocated/shattered panel ???*

- DONEwe need to remove so many minormodes in R and RP as these are live so we don't have time to press
- Q of sync/reset of play/NOTrec counters:

TODO: option to sync/not sync play_cnt in P when we swop sidesDONE - TO TEST on lowest bit- tested but bit same length...

- *USAGE: tests by hand of minormodes*

eg in RP: - 1 bit recend // 0MAXREC, 1rec_end of opposing... // DONE:TODO: test live switching between these opts...

- Q of sensitivity - less sensitive - but then we don't hit top  - linear it is? *should speed be log or linear?

DONEadjust speeds so not so extreme*

- test next major mode - playback of playlist and how we add TESTING - seems fine so far

*Added new speedsample functions: still to finish and also to add play from playlist AND add to playlist*

- *catalogue all modes here - and notate/translate previous major modes into new scheme*

** 21/2

- test all options in first mode now: these hardcoded and then with presses

minormode options short press on mode...

// for manual to record all options now
N/V options: 3 bits // TESTED
- sensitivity
- overlay of sync to top voltage... invert voltage added // top syncs to lowest

P options: 5 bits // TESTED and fixed
- which speedarray: lowest 2 bits: {logfast, logspeed, logfast_stop, logspeed_stop}; 
- speedsync to top: next 1 bit (and top now syncs to bottom)
- types of live overlay: next 2 bits

R options: 2 bits // TESTED
- type of overlay of newADC onto other tape...

RP options: 3 bits //TESTED and with bugfixes // TODO: remove 5 bits play so becomes 3 bits DONE
- first 5 bits as Play above NON!
- 1 bit recend // 0MAXREC, 1rec_end of opposing... // *TODO: test live switching between these opts...*
- 2 bits overlay type

// note: in R and RP reclayers we added overend which is when we reach end, so rec_end is always held at max!

** 20/2

TODO:DONE

DONE - Define presses:

Major and minor modes as changed for all active layers with the MODE button. Shortest press increments minor, longer is for major.

Long and very long presses on mode are for soft and hard resets, again only for active positions.

Soft reset: resets rec counter to 0, playlist...

Timings: minor: <1, major: 1<4, soft reset: 4<6, hard reset: >6 approx checked

DONE:check again  with test_toggles in daccount>8*

Toggle for each position: short press = operation on position according to mode, longer press (1sec+) toggles position as active/inactive.

- All RP options to implement: REC_END option as 1 bit done

- Define/port major modes across...

TESTS
- DONEactive/inactive toggle:

// fixed toggle in play now (as would toggle on longer press too) - keep this for other toggles (in R and RP)...

- DONETEST/DONEimplement and test all presses lengths

- DONETEST recording over 21 seconds

DONEwhy pressing rec changes voltage - as we overlay newADC/// fixed in offsets

DONE- TEST playlist// test end of playlist so far...

///////
TEST base mode below: test all options once we have these implemented

TEST: test option to use rec_end of other tape, or MAX_REC as end in RP

// what were the overlay options:

- RP options*: overwrite/add playback/bounce onto tape x until we hit rec_end (of which tape) or we over_run till MAX_REC

- DONE: check overlay options below and refine:

1bit
overwrite at rec
overlay rec at rec

DONEand adding/overlay options= no overlay, peak >4095, onlyifmorethan, modulus

- how to implement test: playback ONLY of playlist // play and new add of playlist

** 16/2

TO TEST!//DONE:- to port latest playlist into 2024.c and trial there -> playing of playlist // recording of playlist

*idea of daemons and hands/VIA*

** 15/2/204

*Playlist:*
- Simple adding of plays in test2.c works but we haven't tried simultaneous playback/recursions
- settings and operations on the playlist... eg. where the playlist itself is looping/loop points in the list...
- start and stop of play/rec of playlist (means it just loops)
- when do we advance playcnt? when we hit length?

///

Properties of each layer/position and relation to others... relational interface

Properties of each layer/position:

2 tapes with play/rec counters and speeds
playlist

Relation to others:

4 groups each with newADC
top global voltage

** 14/2/2024

Playlist issues:

// to resolve start and end still - new counter

- we need to re=think playlist as is somehow recursive now... and doesn't work in test.c, nor in 2024.c ...

each play adds to the list, but when do we play that list and does playing the list add to the list...
and how do we start the list

also start and ends in each case

-when we enter play we need to record our start which is play_cnt, when we exit record play_cnt which is our end (except in case of loop or swop)
-when we loop what happens?
[-when we swop sides - each has its own play_cnt]

////

- +DONEremoved +1 from playlist inside - does that make sense ????+NON
- fix playlist addings and test in test.c

adding to playlist happens: when we hit end of one cycleDONE, when we leave play, when we swop layers...

///////////////

- option to reset play counter
- start is where we loop back to - always adds to play counter so is offset,,,
- somehow to genericise ops again so is easier to read and make options...

TESTING: test active/inactive, finish minor and major modes

+ plan scheme to finish

notes: 
-inverted voltage does make sense
-address what makes sense for VCA eg. additives to peak not so important as is more about open/close 
-newADC can be fine addition to voltages...

** 13/2/2024

*Basic mode we have:*
- test basic operations and options so far
- *DONETODO: add to playlist on playDONE, DONEadd RP options for end of overlay and overlay

adding to playlist happens: when we hit end of one cycle, when we leave play, when we swop layers...

- basic mode overlays to other layer // never changes own layer - could be live overlay own layer and playback overlay with opts to other...

** 12/2/2024

- hand comparator??? eg. compare against newADC
- DONEfirst mode - can add to playlist for later modes. *next mode just plays that, doesn't add*
// but if we enter second with no playlist then just play rec...

** 9-10/2/2024

- option to sync/not sync play_cnt and rec_cnt in P, RP when we swop sides*

// new panel and assembled PCB ordered 12/2/2024

moving all now as below but how to align panel...

//done as moons- Q of star voltages around!?

- *re. kaffe - why is freeze working better than mode toggle? - need to test kaffe again with slower toggle option every 8*

** 8/2/2024
DONE//
- +Thinking of redo pcb with outs at top/row, ins in row beneath at top+

other opts - enlarge base and move jacks closer and far as possible out...

base width: 100mm
height as: 109mm 

swop V and C jacks and move to extremes...

or... enlarge base, extremes and have 8 top row, 4 in square on edges and shift... 

offsets of jacks->panel 

panel jack is: x:145.45 y:70.45
pcb jack is:   x:145.5  y:64 

x same, y=+6.45 - but they are now inverted...

offset of main 40 pin connector:
panel: x102.0 y104.2

-24.1, -1.3

former PCB:x126.1 y105.5

new PCB: 134, 130.57

new panel pos should be-> 109.9, 129.97

also idea to have odd star voltages scattered around...

//////

NOTE: if in mode 1 option to keep same play point/overlay point for
both layers (also note REC_END will be the same so option to use
either doesn't make sense) ???? ???

** 7/2/2024

Kaffe: test.c

- voltage and newADCs - with differing sensitivity

main voltages: 3 or 4v sense0 // 6v sens1 // 
lower on crescents etc...
cables issue!

2v max newADC // 3v on sens1

- basic toggles of mode/toggle:

freeze fine...
modetoggle - sometimes... but not great....

- longer press on mode and on toggles...

longer press on mode fine
longer press on toggle fine

///

- first major mode can just be rec and playback if we don't want extra options
- test activation/de-activation of modes as way of detach/de-sync
- DONE: major/minor reset:  perhaps have now soft and hard resets - eg. soft resets rec and play tapes but doesn't change other mode stuff...*
- full test of first basic mode and all options

///

- RP options*: overwrite/add playback/bounce onto tape x until we hit rec_end (of which tape) or we over_run till MAX_REC

- check overlay options below and refine:

// overwrite it with playback+real
// add real only to recordings // add real+playback // types of add/overlay
// add playback+real at playback place???
// add real only at playback place

TODO: check these options eg writing at playback spot...*

also type of that overlap as we have for live

-loop/play till rec_end (only option we have) overlay=till own rec_end
(1), other rec_end(2) - if exists, extend until stops (3)
+ more options with other mode eg. marking points with toggle

-check we have rec_cnt in active layerYES - we write/extend other layer to check too

** 6/2/2024

First mode has no playlist - is really the most simple possible IMPLEMENT/test*

-In RP: types of recorded overlays, and length of overlay to fix*

from strip.c // recheck

// overwrite it with playback+real/overlay
// add real only to recordings // just >4095
// add playback+real at playback place???
// add real only at playback place // just >4095

- latest notebook notes for playlist:

problem with playlist is how we accommodate additions to rec... as we only add what we have from beginning in playlist...

options:
- new rec adds to playlist?
- we reboot playlist every time we have new rec

- playlist more as a journey -> R.P. so can be reset by R (or not, depends on mode)


/////

- test2.c in progress: walking through a playlist seems to work...

-> port into 2024.c DONE: to test - *we need to have playlist[0] established as reclength somewhere?*

how we deal with layer changes... should be easy...

port code... need to watch start and length

offset/start is issue or not in the test code?

DONE: BUT now we need to add in: add/rec to play list... eg. section x is added when it is played to the end or as we leave...

TESTED in test2.c adding as we go along but not sure how we deal with leaving... (as +1 is the next one in list)... watch we don't go over 118
last when we leave will be added next turn round...

** 5/4/2024

TODO: implement our basic first mode with all opts... and test all mode changes etc IN PROGRESS

= implement playlist in P, sketch out RP when we have that list: needs to be in speedsample... as can be overlaps...

maybe test first on lap///

// so playlist is: playlist which has start, length, layer, playfull which is number of elements and playcnt which is our counter into these

notebook notes:

- DONE: different modes for R,P,N, RP for each section and state [4] - check minors - yes these are the same: fingers[dacc].majormode[fingers[dacc].state]
- DONE: NADA basis - to test options there... also global sync is now to the final voltage at [6] TESTED

*double bounce - see diagram in notebook*

- simple operations across tapes and list which lead to recursive (writes over/to itself) or dislocated/dismembered results...
- for bounces key is speed and start/ends of bounce// also playlist
- did we write down slippage mode in R, maybe in RP where we slide across
- *for newADC in base mode above we need type of overlay in R!*
- what was self/island mode where we write to same tape in some part which repeats and how to adapt to 2 tapes // translate all prveioud major modes and new ideas here

** 4/4/2024

- added ACTIVE/toggle into latest code/to test there. Seems to work so far!

** 2/2/2024 

*note what we need to reset for new mode/mode change and for resett*

- TODO: pull out as much as possible from mode/switches// also use of function pointers for minormode options..
//
- DONE-all positions set as active at the start
- DONE-arrays for minor modes and states:       uint32_t minormode[4]; // N, R, P, RP // and use mask for each - say lowest x bits
- DONESENSESHIFT etc. is now no longer global so goes into STRUCT - but what is sensitivity for CTRL = 0,1,2,3 as these are VCA which don't have sensitivty
*so now sensitivity is for newADC and for Voltage -> manual*

** 1/2/2024

- embarked on new test code with all basics to test
- DONE - in test.c code: TODO: DONEimplement and test activation by way of extended TOGGLE/FREEZE - maybe a bit longer-adjusted to 300!
- port in basic rec/play/overlay from 1123 and test!
- lots to do/test eg. reset on entry into states
- where to put switch - inside functions

//

stm32f4xx_it_2024.c

new code base with:
- structure for each position/voltage inc. state of each (N, P, R, RP), all lists, and minor modes
- rework major and minors

- what is kept across states in minormodes? (eg, speedlog, type etc) - see below
- if we de-activate a position/voltage it stays in its mode. eg. R, P etc
- logic of minormodes as much as possible outside main switches/modes
- playlist: when do we play full list if P just adds to that list on each new entry
- does playlist reference layer?

** 31/1/2024

- +tested new moon panel fine...+
- how to code more clearly latest modes/layers and micromodes - structure?
- how much of micromodes stays across states - eg, speedlog across P and R+P is the same choice?

done but need to test//TODO: somehow we lost pointer/speedref code: TO TEST: DONE	    // minormode speed as a pointer now

** 25/1/2024

mode: R/P/RP?: (both layers play/record or swop layers): offsets/slide or detach:

- newADC offsets layer in time: offset as offset (newADC adds). offset as speed
- notion of alternate realities implies modes which record same gesture to both layers and then merge, manipulate, offset these. What ops?

** 24/1/2024

- list minormodes for basic set ups - in progress

- playback or overlay mix of tape/s at 2 different speeds (where we get these from?)

- detachment using newADC - we can unsync - shift play head to a new
  position instantly. delay rec for as long as we hold newADC or
  accelerate recording (speed again but not recorded)

how that last would work as it would leave blanks - or these are interpolated? -> *new major mode to try*

//
TO TEST: DONE	    // minormode speed as a pointer now

** 17/1/2024

Trial/decide on:
- Activate section: long freeze press (to test) - so we have 8 sections activated
- Geomantic code = mode select with newADC only in NADA: so we have 4 sections for that...
- Activated groups have R, and P. Do we have Mode on X or X is SEL, and where do we put modes?  mode is on X.

- +ORDERED: aisler /// moon figures for panel!TESTED+

** 16/1/2024 ++

- tested new speed arrays: logfast_stop and logspeed_stop which can now be added to the list of minormodes

- //decide on: modeXbutton[M] as mode or as extra action eg. SEL and then mode is on ADC

- notion of activation of a section (so next RMP is undertaken for those sections):
eg.
.press freeze and R,M,P (no freeze in that case): hold RMP->freeze->release - TRIAL: that seems to work in test code!
.press freeze for a longer time renders section active? // could be>>>???

- *is question of whether we activate section or not*

/////

NON:press newADC and R,M,P ->

DONE/18/1/TRIAL: ! press M/P/R ! new ADC goes up/down ! release button // enters that mode (and ADC is ignored) // we can't ignore as it just drops...

*either we activate a section (how to do multiple sections) and then press R,M,P for activated section... or we just have RMP for that section... which is more versatile*

is activation/local RMP across 4 or 8 sections - if we use ADC then is only 4!

** 13/1/2024 +notebook notes

- new top ADC as global control, added to by local values
- sync: sync speed as a minor mode? ie. all speeds add from top (what was [6] is now new ADC at top)
- divination

operations on list
operations on tapes - see latest notebook

eg. newADC runs through/scrolls through list of segments as index into tape

- NADA - micromodes sets use of touch/voltage (eg. add global from top, inversion, ghosts and mirrors) which stays through all...

BUT... *Q is that micromodes is global and major modes are local if they are determined by newADC*

solutions/questions:
- way of activating mode button locally? idea of active regions?

XXXthat modes are only selected by MODE button when that region is active (is being touched?)

- newADC for all modes/minor modes but then we lose newADC?
 or use mode X button as RESETT and as a new action (like REC, PLAY but could be SELECT/DIVINE)

Q of independent mode for each section? are modes global and where do we have them?

- that VIA needs to be more driven by impulses...

- *new major mode: we are always recording in NADA, and in REC we select what to add to the tape, and in PLAY we play these???*

// what is function of MODE button
// what is function on newADC

- we need major and minor modes to be selected, we need some kind of selection/divining mechanism
- major/minor should be local to voltage/or section (no to global modes)
- but would be nice to have extra mode (but how do we select to enter that)...
- changing major mode resets most things... minor modes not... so is it odd if only happens when we are active?

other possibles: simultaneous presses, gestures on newADC

- *touch based divination - what as simple mechanism can be (an unknown, non-causal mechanism for synchronicity)*

/ that there is a series of 4 anti-clockwise sections, make more of sections (that they can also mirror each, contribute to each other in the section)...

TODO:
- test major mode above: list of experimental modes
- trials for active section/voltage mode selects: IN PROGRESS
- TESTED/DONE:test new speed scheme // array

** 8/1/2024

- removed senseshift but still needed offset reductionDONE

TODO:

- HW tests:

- test voltages...

- FIXED with move of init code: +offset of 1.1V? on voltages (but not after programming???) offset is in DAC writing... (not in ADC)!+
+if we use DAC_OutputBuffer_Enable then we have 100mV offset... but we did not have this before...+

- noise seems ok on voltages...

- test VCAs (ADC is filled crescent)

no noise

- test new ADC:

all fine

toggles:

- none really working well, sticky and jittery. why? cold/dry weather but how to adjust... 

// we have 3.3M pulldown but what was it in the previous board? *4.7M - we just now replaced the one on MODE - changed on schematic*

and we extended delay and BRK -- but extending delay causes jump when we touch 

// 256 operates ok,,, but 300mV offset
// 24 gives 200mV
8 seems the limit but no toggle

*r71 is now 1K: changed on schematic* and we test removal of diode but we should leave it...

*now we have DELB as 42 and is fine... but still odd offset - negative at top and positive at bottom??? leave for now as is not terrible... and is worse with changes to GPIO*

// now in TEST_TOGGLES we have all of them in one so does not repeat delay

timer of toggle now:

- resett seems to work and we will only use short tap or reset...

- SW tests:

- mode 0 in 1123 not working now...??? as probably due to toggles!

- fix up test modes for next week: stm32f4xx_it_test.c

* recent notes

- *this is for NADA: new ADC as accelerating through modes (so is not ADC value=mode) as a *journey* // length of press and speed-> position
- DONE/TRAIL* - this is also a new model for speed - no press=no advance/hold voltage/record voltage
- we can also use this to mark sections - fwdwind and mark

** 21/12/2023

latest notebook notes:

PLAY
- one tap: loop selection. next tap /next tap: add now marked section to playlist // how do we make selection? 3 taps?

- eg. to cut up gestures we just keep what is there as long as we hold freeze or as long as new ADC is > level

is cut up into play list or as re-record to tape 1 or 2

- NO!playlist is single but has 2 strands? tape 1 or 2 - and indications to mix, add etc...

or we have 2 playlists or just one and all depends on current tape?

control gesture->>>[--------------] tape 1
                   [--------------] tape 2

parallel gestures which can repeat/mirror/combine/bump one to other. swop

parallel worlds/gestures - rise, dip, slope etc...

** 13/12/2023

more on gestures:

eg. to cut up a gesture we just keep what is there as long as we hold freeze/cut out the other // or as long as new ADC > x

in play list...??? but is more a question of tape and of re-recording

- is a single playlist or we have 2? single with 2 strands/refs to tape 1 or 2 and indications to merge/add etc???

** 11/12/2023 - *that VIA must be divinatory*

that divination is also a form of compression

from 4 cards each of 4 bits (total 16 bits, 2 bytes) to a future or a past...

that VIA/module offers possible algorithmic futures for the gestures // 2 layers, 2 futures

// how we understand and interpret a gesture?

as a set of values, individual values are meaningful, or as a relation between values over time - the last peak, rising, falling etc.

in dark interpreter they become values/codes within software but this approach is not working as ...

record and devise gesture maps / mapping journeys

** 10/12/2023

- how we can use new gesture from ADC pad as controlling option 
- to summarise what we are controlling -> - - *Play list and rec tape per layer*

so control is over the play list (single?)
modes describe interaction between layers eg. bounce etc...

*or we go full geomantic with new ADC gesture across all 4 parts in diamond shape*...

more notes/ again towards defining behaviours...

- *Play and list and rec tape per layer*

*rec:* - just adds and overlaps and is as a tape would be

*play list:* eg. [0-10][0-10][20-160]

how we manage this list in play mode... 

is it cumulative (add in and out to the list) but we need then 2 modes in play mode (and to toggle between and to toggle layer (or that is just in NADA)

2 play modes: select = play tape and select//add to list, play list only (what we toggle there - remove from list?)

//

headless
fingerless
handless

** 28/11/2023

- 2 layers // 2 code streams

- freeze in NADA freezes any mode change for that section - so modes
  can be per section (how could be also per current layer that we freeze on)

- freeze in NADA toggles layer??? how do we know which?

- NADA always records (to one or to both layers) and play sets START and END (do we have code for that): speedsamplestart
Q. of how we add to this in the case of an overlap - see above

- *long and short taps on freezer for different behaviours* [could also be on rec and play]

*that there can be the tape itself and a list of (playback) references
into that tape* // for example we can have list of repeated segments
or long looping part (how many times it loops) - how to implement
this, and also how on the record side...

record list, play list... how we handle these... and this is for each layer?

record list is additive

play list is determined by modes in play and touches...

** 27/11/2023

2 sides // 2 sides each of the 4 // hermaphrodite 2 layers

- major modes can differ across functions (rec, play etc)

*does it make sense if there are also different mode for each layer?*

demonic/good hermaphrodite...

- detach could be in minor modes...

- review and define from all notes... review minormodes

*we mention slowing a gesture - slow speed to other side... TODO* or we slow recording on one side?

// notebooks:

- layer operations:

1: [][][]
2: [    ]

whichever is longer// *we can reset length of one/both layer*, hold/slide/desync one layer...

define properties of layers: 

add/subtract/merge etc.

these are all modes which operate on same enlarging set of
gestures... [Q also if we can say remove last recorded bit - we just
need to record its start and end, but what if it is an overlap - makes it tricky? - still q of list of gestures]

one layer is a ghost and we can swap that designation...

ops: remove silence for voltages...???

*cycling through alternate ways of reading recorded gestures*

*algorithmic easter egg*

add or subtract gestures in play mode

detachment

*still todo modes above esp. - *still could do thing where we start to repeat say first section (or a define island) and overlay this on same tape!*


** 24/11/2023

- 2 layers //4 sides // each of 2 layers each

That VCA and voltage are not/should they be/ fixed to one side 

eg. they can reflect - so say we can add VCA and voltage and output on both // does that make sense...

swop them around... but they have quite different functions... so maybe doesn't make sense... 

** 22/11/2023

- if we sync counters across 2 layers then we have issue as one might go past end of other! // speedsampleL DEP!

** 21/11/2023

- struct for each layer DONE - what does it enable us to do, or what are issues/questions:

ending of each, sync of swopped playback as each speedplay has its own
counters (or these become one - for each layer: speedsampleL),
question of overlap for each layer, which layer on entry into play
etc, if layer is not there what we do in playback?, can have more
function pointers for different options also...

/////
- question still of list (as it should also indicate the layer) - we need list to be able to remove! *DISCARDED for NOW*

- 2 layers/tapes: speeds, slide across

*what cases we need to code for // eg.*

-record playback speed change on layer 1-> layer 2

but how do we get feedback for this...

*now in new file but not toggle// always NO USE OF TOGGLE:
toggle starts to record to layer2(overlay) speed changes from layer1 and we hear those changes (we are in 1). toggle stops and stays with 2... so no overlay recorded. local and global speeds*

- rec toggles 1 or 2 to record to (but no feedback so how we know which?)
- play toggles which one but one maybe blank?

twinned layer operations: swop, merge/add/subtract/mix, bounce to/record from one to other with speeds, slide across, different speeds

list ops: add (new rec), remove, swop, copy/double, collapse=join, chop?as in cut silence and render as new lists, hide/unhide, detach

-islands and notes above and below...

** 19/11/2023

questions/thoughts:

- do we extend overlay? was marked as TODO minormode option in [0]
- what minormodes we have so far? in [0]?

	//rec -nada
	
	//overlay
	overoverlay=((overminor>>1)&3); // 2 types of overlay
	overrec=((overminor>>3)&3); // type of recorded overlay 
	overspeedmod=((overminor>>5)&1);// 

	//play
	playoverlay=((playminor>>1)&3); // 4 types of overlay
	playspeed=((playminor>>3)&1); // 2 types speed 
	playfreeze=((playminor>>4)&1); // 2 types freeze
	playspeedmod=((playminor>>5)&2);  //

*which of these we retain?* run through them

- how play and rec can be generic? what are the exceptions so far?

- how we could record slowing down of a gesture - needs a place to record into (layer or new entry in list)?

- if we have list and add to it what happens if we run out of space - last entry stops... (is not like a tape loop)

typedef struct listy_ { 
  uint32_t start[120];  
  uint32_t gap[120];
  uint32_t length[120];
  float speed[120];
} hands;

static hands fingers[8];
static uint32_t howmanyfingers[8]={0,0,0,0, 0,0,0,0};

** 19/10/2023 notebook notes

- operations on a list of gestures
- that each mode entails a set of operations on that list
- how can we have successive changes in repeated segments

** 26/10/2023

*To start to define new direction based on latest notes*

notebook notes:

- Q of new speed rec, all is overlay, or *speed global as [6] voltage and local voltages*... no doublings 
- so we can maintain, modify or erase overlay as we progress
- and use overlay as speed or not...
- additive switch/swop across 2 tapes (2 tapes, 2 speeds - how?)
- algorithmic control as pulse in to freezers/toggles, minimode
- *translate modes we have into ongoing series of transformations*

- what we can do with a list of gestures, list of modes: earlier idea of push/pop/ *stack* button... 

earlier idea was: Notes: frozen levels are saved to a stack and can be popped off the stack, various over-rides...????

circular stack of gestures - how to add, remove and what happens when we run out of room??? 

** 25/10/2023 *KEY*

- trying to re-think towards more fluidity// notebook notes:

1. We could pull out REC and NADA as these have no modes (but in REC we have double and other rec options, also if we reset)

as in REC we have no feedback on what we do. so it must be simple... but how we could signify a RESET there in further modes, to start again and not to add to!?

First mode (after full RESETT) is just record, no speed, and is always reset REC in this mode - but then we can leave it...

Then we change after that...

Question of no double record, no speed rec? and top bits are always ghost/overlay with voltage 6 as speed (and seperate its playback speed)

*So modes overlay and change what we have already recorded gesturally - but how can we move back or forwards through modes?? or is just fwd*

And do we keep micromodes (yes)... but these do not include reset on REC...

3. top [6]voltage is always control - so no freeze on that. but is also output so we can use it for sync...

4. *Options for algorithmic control*

So we can use external voltage input via fingers to trigger freeze/toggles! Write this up in manual...

What does this enable - 

5. Global gestures - eg. as offsets from lowest VCA or voltage - have those as groups, or we slide sync across them all

6. List of gestures, actions on gestures to list? overlay, repeat, move in the list, detach, slide, attach

7. How we control - with local voltage, with [6] and freeze/toggle[6], with local toggles, with timings of presses, with gestures??? with modeswitch

8. Maybe 2 resets - one full to mode 0/basic REC, other just resets counters and sequence... we had idea below...

To consider new scheme... so more like an instrument


* manual

** manual/description

ERD/VIA is the Way, the new modular life, severing hands from knobs
and tinkering, and establishing a new local skin regime of signals and
gestures for dis-embodied prostheses. VIA is a new touch and
finger-based un-controller for ERD and all modules, allowing voltage
control to be freed from erudite wiggling, and surrendered to purely
cut and segmented gestures. Voltages are placed on the surface of both
skin and module to facilitate cross-skin-s/pore-modulation and feedback.

Four identical sections allow touch and gesture to govern a single VCA
and a control voltage (CV) independently. Input, output and control
voltages can also be mixed by skin and gesture. Gestural sections can
be recorded and played back, chopped and cut, frozen, altered, sped
up, slowed down, repeated, severed, overlaid, ghosted and finally
dis-embodied and de-organised, all under touch and skin-feedback
control. Signals can be routed on the skin to act globally and
independently. 

How it can be used as a live, gestural controller in its most simple configuration (mode 0)... further dislocations...

//

The geomantic figure Via, or “Way”. This figure has all elements
active, revealing its dynamic nature; its linear form resembles a
road, at the changes afoot due to time and circumstance. It takes and
transforms every other figure and force into its opposite. It is a
figure of complete change, upheaval, and reversal; it is good with bad
figures and bad with good figures, though it is considerably more
favorable in matters requiring total reassessment and journeys of any
kind. It often shows a solitary time and path, between homes, cities,
and worlds.

Via has connections with the waning Moon and the element of
Water. Agrippa assigns it to the astrological sign of Cancer, although
Gerard of Cremona assigns it to Leo. It is an even, mobile, and
liminal figure. 

*Its inverse and converse figure is Populus, the People, while its reverse figure is itself.*

//

fixed pattern, mobile pattern in geomancy/divination - rotation of one mandala against the other

2 kinds time
synchronicity

For manual: modes define operations on layers

one is always the ghost hand. a double of _____

switch ghost hands - 2nd layer

longer - what are the modes // how many modes?

basic operations - where we touch, what is vca, routing of signals,
freeze, micro/macro modes, rec/playback, lengths and timings!

instructions etc...

Image cards are cut out - disembodied hands, each of the 4 segments
cracked apart and somehow labelled... some uncut cards maybe to show
assembly/with text also on back for modes ... cut yourself out

Reader/reading list:

geomancy
von franz

** hardware

- +12v:75mA
- -12v:50mA
