#include "stdio.h"
#include <stdint.h>
#include "math.h"
#include "stdlib.h"
#include "time.h"

#define MAXVALUE 4095

///#include "resources.h"

const float logspeed[1024] = {1.000000f, 0.993247f, 0.986540f, 0.979878f, 0.973261f, 0.966689f, 0.960161f, 0.953678f, 0.947238f, 0.940841f, 0.934488f, 0.928178f, 0.921910f, 0.915685f, 0.909501f, 0.903360f, 0.897260f, 0.891201f, 0.885183f, 0.879205f, 0.873268f, 0.867371f, 0.861514f, 0.855696f, 0.849918f, 0.844179f, 0.838478f, 0.832816f, 0.827193f, 0.821607f, 0.816059f, 0.810548f, 0.805075f, 0.799638f, 0.794238f, 0.788875f, 0.783548f, 0.778257f, 0.773002f, 0.767782f, 0.762597f, 0.757448f, 0.752333f, 0.747252f, 0.742206f, 0.737195f, 0.732216f, 0.727272f, 0.722361f, 0.717483f, 0.712638f, 0.707826f, 0.703046f, 0.698299f, 0.693583f, 0.688900f, 0.684248f, 0.679627f, 0.675038f, 0.670479f, 0.665952f, 0.661455f, 0.656988f, 0.652552f, 0.648145f, 0.643768f, 0.639421f, 0.635103f, 0.630815f, 0.626555f, 0.622324f, 0.618122f, 0.613948f, 0.609802f, 0.605684f, 0.601594f, 0.597532f, 0.593497f, 0.589489f, 0.585508f, 0.581555f, 0.577627f, 0.573727f, 0.569853f, 0.566005f, 0.562183f, 0.558386f, 0.554616f, 0.550870f, 0.547151f, 0.543456f, 0.539786f, 0.536141f, 0.532521f, 0.528925f, 0.525353f, 0.521805f, 0.518282f, 0.514782f, 0.511306f, 0.507853f, 0.504424f, 0.501017f, 0.497634f, 0.494274f, 0.490936f, 0.487621f, 0.484328f, 0.481058f, 0.477809f, 0.474583f, 0.471378f, 0.468195f, 0.465033f, 0.461893f, 0.458774f, 0.455676f, 0.452599f, 0.449543f, 0.446507f, 0.443492f, 0.440497f, 0.437523f, 0.434568f, 0.431634f, 0.428719f, 0.425824f, 0.422948f, 0.420092f, 0.417255f, 0.414438f, 0.411639f, 0.408860f, 0.406099f, 0.403356f, 0.400633f, 0.397927f, 0.395240f, 0.392571f, 0.389920f, 0.387287f, 0.384672f, 0.382074f, 0.379494f, 0.376932f, 0.374386f, 0.371858f, 0.369347f, 0.366853f, 0.364376f, 0.361915f, 0.359471f, 0.357044f, 0.354633f, 0.352238f, 0.349860f, 0.347497f, 0.345151f, 0.342820f, 0.340505f, 0.338206f, 0.335922f, 0.333653f, 0.331400f, 0.329163f, 0.326940f, 0.324732f, 0.322539f, 0.320361f, 0.318198f, 0.316049f, 0.313915f, 0.311795f, 0.309690f, 0.307598f, 0.305521f, 0.303458f, 0.301409f, 0.299374f, 0.297352f, 0.295344f, 0.293350f, 0.291369f, 0.289401f, 0.287447f, 0.285506f, 0.283578f, 0.281663f, 0.279761f, 0.277872f, 0.275996f, 0.274132f, 0.272281f, 0.270442f, 0.268616f, 0.266802f, 0.265000f, 0.263211f, 0.261434f, 0.259668f, 0.257915f, 0.256173f, 0.254443f, 0.252725f, 0.251018f, 0.249323f, 0.247640f, 0.245967f, 0.244307f, 0.242657f, 0.241018f, 0.239391f, 0.237774f, 0.236169f, 0.234574f, 0.232990f, 0.231416f, 0.229854f, 0.228302f, 0.226760f, 0.225229f, 0.223708f, 0.222197f, 0.220697f, 0.219206f, 0.217726f, 0.216256f, 0.214796f, 0.213345f, 0.211904f, 0.210474f, 0.209052f, 0.207641f, 0.206238f, 0.204846f, 0.203462f, 0.202089f, 0.200724f, 0.199368f, 0.198022f, 0.196685f, 0.195357f, 0.194038f, 0.192727f, 0.191426f, 0.190133f, 0.188849f, 0.187574f, 0.186307f, 0.185049f, 0.183800f, 0.182559f, 0.181326f, 0.180101f, 0.178885f, 0.177677f, 0.176478f, 0.175286f, 0.174102f, 0.172926f, 0.171759f, 0.170599f, 0.169447f, 0.168303f, 0.167166f, 0.166037f, 0.164916f, 0.163803f, 0.162696f, 0.161598f, 0.160507f, 0.159423f, 0.158346f, 0.157277f, 0.156215f, 0.155160f, 0.154112f, 0.153072f, 0.152038f, 0.151011f, 0.149991f, 0.148979f, 0.147973f, 0.146973f, 0.145981f, 0.144995f, 0.144016f, 0.143044f, 0.142078f, 0.141118f, 0.140165f, 0.139219f, 0.138279f, 0.137345f, 0.136417f, 0.135496f, 0.134581f, 0.133672f, 0.132770f, 0.131873f, 0.130983f, 0.130098f, 0.129220f, 0.128347f, 0.127480f, 0.126620f, 0.125765f, 0.124915f, 0.124072f, 0.123234f, 0.122402f, 0.121575f, 0.120754f, 0.119939f, 0.119129f, 0.118325f, 0.117526f, 0.116732f, 0.115944f, 0.115161f, 0.114383f, 0.113611f, 0.112843f, 0.112081f, 0.111325f, 0.110573f, 0.109826f, 0.109085f, 0.108348f, 0.107616f, 0.106890f, 0.106168f, 0.105451f, 0.104739f, 0.104032f, 0.103329f, 0.102631f, 0.101938f, 0.101250f, 0.100566f, 0.099887f, 0.099213f, 0.098543f, 0.097877f, 0.097216f, 0.096560f, 0.095908f, 0.095260f, 0.094617f, 0.093978f, 0.093343f, 0.092713f, 0.092087f, 0.091465f, 0.090847f, 0.090234f, 0.089625f, 0.089019f, 0.088418f, 0.087821f, 0.087228f, 0.086639f, 0.086054f, 0.085473f, 0.084896f, 0.084323f, 0.083753f, 0.083188f, 0.082626f, 0.082068f, 0.081514f, 0.080963f, 0.080417f, 0.079874f, 0.079334f, 0.078798f, 0.078266f, 0.077738f, 0.077213f, 0.076691f, 0.076174f, 0.075659f, 0.075148f, 0.074641f, 0.074137f, 0.073636f, 0.073139f, 0.072645f, 0.072155f, 0.071667f, 0.071183f, 0.070703f, 0.070225f, 0.069751f, 0.069280f, 0.068812f, 0.068347f, 0.067886f, 0.067428f, 0.066972f, 0.066520f, 0.066071f, 0.065625f, 0.065181f, 0.064741f, 0.064304f, 0.063870f, 0.063439f, 0.063010f, 0.062585f, 0.062162f, 0.061742f, 0.061325f, 0.060911f, 0.060500f, 0.060091f, 0.059686f, 0.059283f, 0.058882f, 0.058485f, 0.058090f, 0.057698f, 0.057308f, 0.056921f, 0.056537f, 0.056155f, 0.055776f, 0.055399f, 0.055025f, 0.054653f, 0.054284f, 0.053918f, 0.053554f, 0.053192f, 0.052833f, 0.052476f, 0.052122f, 0.051770f, 0.051420f, 0.051073f, 0.050728f, 0.050385f, 0.050045f, 0.049707f, 0.049372f, 0.049038f, 0.048707f, 0.048378f, 0.048051f, 0.047727f, 0.047405f, 0.047085f, 0.046767f, 0.046451f, 0.046137f, 0.045826f, 0.045516f, 0.045209f, 0.044903f, 0.044600f, 0.044299f, 0.044000f, 0.043703f, 0.043408f, 0.043115f, 0.042823f, 0.042534f, 0.042247f, 0.041962f, 0.041678f, 0.041397f, 0.041117f, 0.040840f, 0.040564f, 0.040290f, 0.040018f, 0.039748f, 0.039479f, 0.039213f, 0.038948f, 0.038685f, 0.038424f, 0.038164f, 0.037907f, 0.037651f, 0.037396f, 0.037144f, 0.036893f, 0.036644f, 0.036396f, 0.036151f, 0.035907f, 0.035664f, 0.035423f, 0.035184f, 0.034946f, 0.034710f, 0.034476f, 0.034243f, 0.034012f, 0.033782f, 0.033554f, 0.033328f, 0.033103f, 0.032879f, 0.032657f, 0.032437f, 0.032217f, 0.032000f, 0.031784f, 0.031569f, 0.031356f, 0.031144f, 0.030934f, 0.030725f, 0.030518f, 0.030312f, 0.030107f, 0.029904f, 0.029702f, 0.029501f, 0.029302f, 0.029104f, 0.028907f, 0.028712f, 0.028518f, 0.028326f, 0.028135f, 0.027945f, 0.027756f, 0.027568f, 0.027382f, 0.027197f, 0.027014f, 0.026831f, 0.026650f, 0.026470f, 0.026291f, 0.026114f, 0.025937f, 0.025762f, 0.025588f, 0.025416f, 0.025244f, 0.025073f, 0.024904f, 0.024736f, 0.024569f, 0.024403f, 0.024238f, 0.024075f, 0.023912f, 0.023751f, 0.023590f, 0.023431f, 0.023273f, 0.023116f, 0.022959f, 0.022804f, 0.022650f, 0.022497f, 0.022346f, 0.022195f, 0.022045f, 0.021896f, 0.021748f, 0.021601f, 0.021455f, 0.021310f, 0.021167f, 0.021024f, 0.020882f, 0.020741f, 0.020601f, 0.020461f, 0.020323f, 0.020186f, 0.020050f, 0.019914f, 0.019780f, 0.019646f, 0.019514f, 0.019382f, 0.019251f, 0.019121f, 0.018992f, 0.018864f, 0.018736f, 0.018610f, 0.018484f, 0.018359f, 0.018235f, 0.018112f, 0.017990f, 0.017868f, 0.017748f, 0.017628f, 0.017509f, 0.017391f, 0.017273f, 0.017156f, 0.017041f, 0.016926f, 0.016811f, 0.016698f, 0.016585f, 0.016473f, 0.016362f, 0.016251f, 0.016142f, 0.016033f, 0.015924f, 0.015817f, 0.015710f, 0.015604f, 0.015498f, 0.015394f, 0.015290f, 0.015187f, 0.015084f, 0.014982f, 0.014881f, 0.014781f, 0.014681f, 0.014582f, 0.014483f, 0.014385f, 0.014288f, 0.014192f, 0.014096f, 0.014001f, 0.013906f, 0.013812f, 0.013719f, 0.013626f, 0.013534f, 0.013443f, 0.013352f, 0.013262f, 0.013172f, 0.013083f, 0.012995f, 0.012907f, 0.012820f, 0.012734f, 0.012648f, 0.012562f, 0.012477f, 0.012393f, 0.012309f, 0.012226f, 0.012144f, 0.012062f, 0.011980f, 0.011899f, 0.011819f, 0.011739f, 0.011660f, 0.011581f, 0.011503f, 0.011425f, 0.011348f, 0.011272f, 0.011195f, 0.011120f, 0.011045f, 0.010970f, 0.010896f, 0.010823f, 0.010749f, 0.010677f, 0.010605f, 0.010533f, 0.010462f, 0.010391f, 0.010321f, 0.010252f, 0.010182f, 0.010114f, 0.010045f, 0.009977f, 0.009910f, 0.009843f, 0.009777f, 0.009711f, 0.009645f, 0.009580f, 0.009515f, 0.009451f, 0.009387f, 0.009324f, 0.009261f, 0.009198f, 0.009136f, 0.009074f, 0.009013f, 0.008952f, 0.008892f, 0.008832f, 0.008772f, 0.008713f, 0.008654f, 0.008596f, 0.008538f, 0.008480f, 0.008423f, 0.008366f, 0.008309f, 0.008253f, 0.008198f, 0.008142f, 0.008087f, 0.008033f, 0.007978f, 0.007924f, 0.007871f, 0.007818f, 0.007765f, 0.007713f, 0.007660f, 0.007609f, 0.007557f, 0.007506f, 0.007456f, 0.007405f, 0.007355f, 0.007306f, 0.007256f, 0.007207f, 0.007159f, 0.007110f, 0.007062f, 0.007015f, 0.006967f, 0.006920f, 0.006873f, 0.006827f, 0.006781f, 0.006735f, 0.006690f, 0.006644f, 0.006600f, 0.006555f, 0.006511f, 0.006467f, 0.006423f, 0.006380f, 0.006337f, 0.006294f, 0.006251f, 0.006209f, 0.006167f, 0.006126f, 0.006084f, 0.006043f, 0.006002f, 0.005962f, 0.005922f, 0.005882f, 0.005842f, 0.005802f, 0.005763f, 0.005724f, 0.005686f, 0.005647f, 0.005609f, 0.005571f, 0.005534f, 0.005496f, 0.005459f, 0.005422f, 0.005386f, 0.005349f, 0.005313f, 0.005277f, 0.005242f, 0.005206f, 0.005171f, 0.005136f, 0.005102f, 0.005067f, 0.005033f, 0.004999f, 0.004965f, 0.004932f, 0.004898f, 0.004865f, 0.004832f, 0.004800f, 0.004767f, 0.004735f, 0.004703f, 0.004671f, 0.004640f, 0.004609f, 0.004577f, 0.004546f, 0.004516f, 0.004485f, 0.004455f, 0.004425f, 0.004395f, 0.004365f, 0.004336f, 0.004307f, 0.004278f, 0.004249f, 0.004220f, 0.004191f, 0.004163f, 0.004135f, 0.004107f, 0.004079f, 0.004052f, 0.004024f, 0.003997f, 0.003970f, 0.003943f, 0.003917f, 0.003890f, 0.003864f, 0.003838f, 0.003812f, 0.003786f, 0.003761f, 0.003735f, 0.003710f, 0.003685f, 0.003660f, 0.003636f, 0.003611f, 0.003587f, 0.003562f, 0.003538f, 0.003514f, 0.003491f, 0.003467f, 0.003444f, 0.003420f, 0.003397f, 0.003374f, 0.003352f, 0.003329f, 0.003307f, 0.003284f, 0.003262f, 0.003240f, 0.003218f, 0.003196f, 0.003175f, 0.003153f, 0.003132f, 0.003111f, 0.003090f, 0.003069f, 0.003048f, 0.003028f, 0.003007f, 0.002987f, 0.002967f, 0.002947f, 0.002927f, 0.002907f, 0.002887f, 0.002868f, 0.002849f, 0.002829f, 0.002810f, 0.002791f, 0.002772f, 0.002754f, 0.002735f, 0.002717f, 0.002698f, 0.002680f, 0.002662f, 0.002644f, 0.002626f, 0.002608f, 0.002591f, 0.002573f, 0.002556f, 0.002539f, 0.002522f, 0.002505f, 0.002488f, 0.002471f, 0.002454f, 0.002438f, 0.002421f, 0.002405f, 0.002389f, 0.002372f, 0.002356f, 0.002340f, 0.002325f, 0.002309f, 0.002293f, 0.002278f, 0.002262f, 0.002247f, 0.002232f, 0.002217f, 0.002202f, 0.002187f, 0.002172f, 0.002158f, 0.002143f, 0.002129f, 0.002114f, 0.002100f, 0.002086f, 0.002072f, 0.002058f, 0.002044f, 0.002030f, 0.002016f, 0.002003f, 0.001989f, 0.001976f, 0.001962f, 0.001949f, 0.001936f, 0.001923f, 0.001910f, 0.001897f, 0.001884f, 0.001872f, 0.001859f, 0.001846f, 0.001834f, 0.001821f, 0.001809f, 0.001797f, 0.001785f, 0.001773f, 0.001761f, 0.001749f, 0.001737f, 0.001725f, 0.001714f, 0.001702f, 0.001691f, 0.001679f, 0.001668f, 0.001657f, 0.001645f, 0.001634f, 0.001623f, 0.001612f, 0.001601f, 0.001591f, 0.001580f, 0.001569f, 0.001559f, 0.001548f, 0.001538f, 0.001527f, 0.001517f, 0.001507f, 0.001497f, 0.001486f, 0.001476f, 0.001466f, 0.001457f, 0.001447f, 0.001437f, 0.001427f, 0.001418f, 0.001408f, 0.001398f, 0.001389f, 0.001380f, 0.001370f, 0.001361f, 0.001352f, 0.001343f, 0.001334f, 0.001325f, 0.001316f, 0.001307f, 0.001298f, 0.001289f, 0.001281f, 0.001272f, 0.001263f, 0.001255f, 0.001246f, 0.001238f, 0.001230f, 0.001221f, 0.001213f, 0.001205f, 0.001197f, 0.001189f, 0.001181f, 0.001173f, 0.001165f, 0.001157f, 0.001149f, 0.001141f, 0.001134f, 0.001126f, 0.001118f, 0.001111f, 0.001103f, 0.001096f, 0.001088f, 0.001081f, 0.001074f, 0.001066f, 0.001059f, 0.001052f, 0.001045f, 0.001038f, 0.001031f, 0.001024f, 0.001017f, 0.001010f, 0.001003f, 0.000997f, 0.000990f, 0.000983f, 0.000977f};


//gcc test.c -otest -lm -std=gnu99 

// TODO:

//- in test2.c compare generic shiftings with coggs version (and also if we still need to do <<1 if routes to itself? yes we do) DONE
// they are both the same...

//- ghostSR in ghostSR in test2.c to trial//also various crossings of delayed ghosts with "real" SRs


//we need multiple ghosts for each possible shifter: eg. Gshift_rl, Gshift_rn, Gshift_rc (right ones for left, for n and for c)
// but these will all be arrays, why do we need pointers?

uint32_t shift_[4], Gshift_[4][4], GGshift_[4], cogg[4][4], route[4]; // gshift is 4 even though we don't use one
// GG is ghost in ghost

// and cycling/circling array of ghosts which can come back or go forwards/backwards - when these ghosts are copied over (on event)
// with 256 cycles/copies - or we can have variable length of this shifting array

uint32_t Gshift_rev[4][256], Gshift_revcnt[4]={0,0,0,0};
uint32_t default_route[4]={8,1,2,4}; // for 0,1,2,3 N,L,C,R - but routing is routing FROM!
//uint32_t default_route[4]={8,1,2,4}; // for 0,1,2,3 N,L,C,R - but routing is routing FROM!
uint32_t single_route[4]={1,2,4,8};
uint32_t sroute=0; // counter for single routes so we can share this

uint32_t neworder[4]={3,2,1,0};

uint32_t *speedroute[4][5]; // speed from our CV, CV as offset for DAC from (1,2,3,4) // just for speedCV modes - pointer to these

// can also be for any set of values - and we can include own length so +1
// always do DACs - but how these are handled according to length as we still want fixed number of bits

// and how would routing be for pulse modes: pulses, pulses from SR - but we can't use our own pulses
// we can't make this so generic as one set uses interrupts... also we can always reroute pulses with cables so...
// other options: DAC or CV as divider of pulses in these modes

/* each SR delivers DAC, how to do tables which don't allow for overlap of DACs eg.

1000
0100
0010
0001 

for each table - but what to do if one is chosen? route+1
*/

// for generic CLK puls routing
//LSRCLK-pulse9=PB12, RSRCLK-pulse10=PB13, CSRCLCK-pulse11=PB14
// 000,001,010,011,100,101,110,111

//GPIOC->BSRRH = (1<<15) ;  // clear bits            
//GPIOC->BSRRL = (1<<15) ;  // write bits            


static uint32_t clk_route[8]={0,
			      (1<<12),
			      (1<<13),
			      (1<<12) | (1<<13),
			      (1<<14),
			      (1<<12) | (1<<14),
			      (1<<14) | (1<<13),
			      (1<<12) | (1<<13) | (1<<14)
};

  
static uint32_t invmasky[32]={//0,0,0, // skip all zeroes or all ones ???

0b11111111111111111111111111111110,
0b11111111111111111111111111111100,
0b11111111111111111111111111111000,
0b11111111111111111111111111110000,
0b11111111111111111111111111100000,
0b11111111111111111111111111000000,
0b11111111111111111111111110000000,
0b11111111111111111111111100000000,
0b11111111111111111111111000000000,
0b11111111111111111111110000000000,
0b11111111111111111111100000000000,
0b11111111111111111111000000000000,
0b11111111111111111110000000000000,
0b11111111111111111100000000000000,
0b11111111111111111000000000000000,
0b11111111111111110000000000000000,
0b11111111111111100000000000000000,
0b11111111111111000000000000000000,
0b11111111111110000000000000000000,
0b11111111111100000000000000000000,
0b11111111111000000000000000000000,
0b11111111110000000000000000000000,
0b11111111100000000000000000000000,
0b11111111000000000000000000000000,
0b11111110000000000000000000000000,
0b11111100000000000000000000000000,
0b11111000000000000000000000000000,
0b11110000000000000000000000000000,
0b11100000000000000000000000000000,
0b11000000000000000000000000000000,
0b10000000000000000000000000000000,
0b00000000000000000000000000000000,			  
};

  
static uint32_t masky[32]={//0,0,0, // skip all zeroes or all ones ??? all 0
			   0b00000000000000000000000000000001,			  
			   0b00000000000000000000000000000011,			  
			   0b00000000000000000000000000000111,			  
			   0b00000000000000000000000000001111,			  
			   0b00000000000000000000000000011111,			  
			   0b00000000000000000000000000111111,			  
			   0b00000000000000000000000001111111,			  
			   0b00000000000000000000000011111111,			  
			   0b00000000000000000000000111111111,			  
			   0b00000000000000000000001111111111,			  
			   0b00000000000000000000011111111111,			  
			   0b00000000000000000000111111111111,			  
			   0b00000000000000000001111111111111,			  
			   0b00000000000000000011111111111111,			  
			   0b00000000000000000111111111111111,			  
			   0b00000000000000001111111111111111,			  
			   0b00000000000000011111111111111111,			  
			   0b00000000000000111111111111111111,			  
			   0b00000000000001111111111111111111,			  
			   0b00000000000011111111111111111111,			  
			   0b00000000000111111111111111111111,			  
			   0b00000000001111111111111111111111,			  
			   0b00000000011111111111111111111111,			  
			   0b00000000111111111111111111111111,			  
			   0b00000001111111111111111111111111,			  
			   0b00000011111111111111111111111111,			  
			   0b00000111111111111111111111111111,			  
			   0b00001111111111111111111111111111,			  
			   0b00011111111111111111111111111111,			  
			   0b00111111111111111111111111111111,			  
			   0b01111111111111111111111111111111,			   
			   0b11111111111111111111111111111111,
};


static uint8_t lfsr_taps[32][4] = {
        {0, 0, 0, 0},
        {0, 0, 0, 0},
        {0, 0, 0, 0},
        {3, 2, 0, 0},
        {4, 3, 2, 1},
        {5, 4, 2, 1},
        {6, 5, 4, 3},
        {7, 5, 4, 3},
        {8, 7, 5, 4},
        {9, 8, 6, 5},
        {10, 9, 8, 6},
        {11, 10, 7, 5},
        {12, 11, 9, 8},
        {13, 12, 10, 8},
        {14, 13, 12, 10},
        {15, 13, 12, 10},
        {16, 15, 14, 13},
        {17, 16, 15, 12},
        {18, 17, 16, 13},
        {19, 18, 15, 13},
        {20, 19, 18, 15},
        {21, 18, 17, 16},
        {22, 21, 19, 17},
        {23, 22, 20, 19},
        {24, 23, 22, 21},
        {25, 24, 23, 19},
        {26, 25, 24, 21},
        {27, 26, 23, 21},
        {28, 27, 26, 24},
        {29, 28, 25, 23},
        {30, 29, 28, 27},
        {31, 29, 25, 24},
  };

//static uint32_t rightshift[32]={0,0,0,0, 0,0,0,0, 0,0,0,0, // first 12 bits
//				1,2,3,4, 5,6,7,8, 9,10,11,12, 13,14,15,16, 17,18,19,20};

//static uint32_t leftshift[32]= {11,10,9, 8,7,6,5, 4,3,2,1,
//				0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0};

static uint8_t rightshift[32]={0,0,0,3, 0,0,0,0, 0,0,0,0, // first 12 bits
				1,2,3,4, 5,6,7,8, 9,10,11,12, 13,14,15,16, 17,18,19,20};

static uint8_t leftshift[32]= {11,11,11,11, 7,6,5,4, 3,2,1,0,
				0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0};


//static uint32_t countbts[4096]={0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 7, 8, 8, 9, 8, 9, 9, 10, 8, 9, 9, 10, 9, 10, 10, 11, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 7, 8, 8, 9, 8, 9, 9, 10, 8, 9, 9, 10, 9, 10, 10, 11, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 7, 8, 8, 9, 8, 9, 9, 10, 8, 9, 9, 10, 9, 10, 10, 11, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 7, 8, 8, 9, 8, 9, 9, 10, 8, 9, 9, 10, 9, 10, 10, 11, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 7, 8, 8, 9, 8, 9, 9, 10, 8, 9, 9, 10, 9, 10, 10, 11, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 7, 8, 8, 9, 8, 9, 9, 10, 8, 9, 9, 10, 9, 10, 10, 11, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 7, 8, 8, 9, 8, 9, 9, 10, 8, 9, 9, 10, 9, 10, 10, 11, 7, 8, 8, 9, 8, 9, 9, 10, 8, 9, 9, 10, 9, 10, 10, 11, 8, 9, 9, 10, 9, 10, 10, 11, 9, 10, 10, 11, 10, 11, 11, 12};

void print32bits(uint32_t bitz){
  int x,y;
  unsigned char bitt;
  uint32_t cc=0b10000000000000000000000000000000; 

  for (y=0;y<32;y++){
    if ((bitz&cc)!=0) bitt=1;
    else bitt=0;
    cc=cc>>1;
    printf("%d",bitt);
  }
printf("\n");
}

static inline int bits_(uint32_t reg, uint32_t length){ // function returns bottom length bits of SR reg
  uint32_t x=0;
  if (reg<4) x=shift_[reg]>>(31-length);
  return x;
}

// and another inline function which returns different kinds of DAC from
// a certain SR eg. standard DAC of x bits, equivalent dac of x bits,
// what about one bit dac (more involved as takes time but we should have
// a pointer to that value

float LPF_Beta = 0.02; // 0<ÃŸ<1

int adc_buffer[13];

// TODO: generic ADC functions for bit insertions into shift registers! - for single bits only we return bit which is to be used here

static inline int ADC_(uint32_t reg, uint32_t length, uint32_t type){ // here we use length as number of bits max is 12 bits
  static int n[4]={0,0,0,0};
  static int32_t integrator=0, oldValue=0;

  int k, bt;

  if (type==0){ // basic sequential length of bits cycling in
  if (length>11) length=11;
      if (n[reg]==length) {
	k=(adc_buffer[12])>>(11-length); //
      n[reg]=0;
    }
    bt = (k>>n[reg])&0x01;
    n[reg]++;    
  }
  else { // one bit audio input
    n[reg]++;
  if (n[reg]>50) {
    k=(adc_buffer[12]); // now 12 bits only // 16 bits to 12 bits - this is now our ADCin!
    n[reg]=0;
  }

  integrator+=k-oldValue;
   if(integrator>0)
  {
     oldValue=MAXVALUE;
     bt=1;
  }
   else
   {
      oldValue=0;
      bt=0;
   }

    // other options are: comparator, equivalent sets of x bits incoming (how to do this cleanly for x number of bits)

    }
    
    return bt;
}

static inline int DAC_(uint32_t reg, uint32_t length, uint32_t type){ // 3 types 0,1,2 - but we can also add more types for spacings with array of spacers (which we
                                                                      // did have somewhere
  uint32_t y,x=0;
  static float SmoothData[4]={0.0, 0.0, 0.0, 0.0};

  if (type==0){ // standard bit DAC for x bits
    if (reg<4 && length>3 && length<32) 
      x=((shift_[reg] & masky[length-3])>>(rightshift[length]))<<leftshift[length]; // we want 12 bits but is not really audible difference    
  }
  else if (type==1){
      // equivalent bit DAC for x bits - we need a table for this!
      // or more like set of tables for each bit
      // and we need divide highest but number - eg. for 8 bits we have max 8 (all 1s) - max 12 bits DAC is 4096 4096/8=512 4096/12=341
      // we can have another table for this - but just taking maybe max of 12 bits otherwise lookup is too long (max 12 bits=4096)
      if (reg<4){
	if (length>11) length=11;
	//	x=countbts[shift_[reg]&masky[length]]; // lower length bits only
	y=4096/(length+1);
	  x*=y;
      }
  }
  else { // one bit audio
    // top bit
    y=(shift_[reg]>>length)&1;
    if (y==1) x=4095;
    else x=0;
    SmoothData[reg] = SmoothData[reg] - (LPF_Beta * (SmoothData[reg] - x)); // how do we adjust beta for speed?
    x=(int)SmoothData[reg];
  }
  return x;
}

static inline uint32_t countbits(uint32_t i)
{
  //    return( countbts[i&0xFFFF] + countbts[i>>16] );
}


int main(void)   // try to re-learn pointer arrays
{
  uint32_t bitn, bitr, bitrr, tmp;
  uint32_t shift_registern=0xff; 
  uint32_t shift_registerl=0xff;
  uint32_t shift_registerr=0xff;
  uint32_t shift_registerc=0xff;
  uint32_t shift_registerR=0xff; 

  uint32_t counter[4];
  
  uint32_t speedn, speedl, speedr, speedc=0;
  uint32_t countern, counterl, counterr, counterc=0;
  uint32_t SRlengthn=31, SRlengthl=31, SRlengthr=31, SRlengthc=31, lengthbitn=15, Slengthbitl=15, lengthbitr=15, Slengthbitc=15;
  uint32_t coggn, coggl, coggr, coggc=0;

  uint32_t Gshift_registern=0xff; 
  uint32_t Gshift_registernn=0xff; // for routing we need 2x  - this is resolved in arrays of ghosts
  uint32_t Gshift_registerl=0xff;
  uint32_t Gshift_registerr=0xff;
  uint32_t Gshift_registerc=0xff; 

  //  uint32_t *speedroute[4][5]; // speed from our CV, CV as offset for DAC from (1,2,3,4) // just for speedCV modes - so could be pointer to these
  // but we can't add offset in pointers?
  speedroute[0][0]=&speedn; // eg CV speed.
  speedn=1;
  
  uint32_t b, g, x, y, clkr=0;
  shift_[0]=0b1111111011101011101010101110001;
  shift_[1]=0b0000000000000000000000000000000;
  shift_[2]=0b0000000000000000000000000000000;
  shift_[3]=0b0000000000000000000000000000000;
    
  //  shift_[1]=0b0110111011111011101110111110000;
  //  shift_[2]=0b0110111011111011101110111110010;
  //  shift_[3]=0b0110111011111011101110111110010;
  
  // seed rand
  srand (time(NULL));
  
  //say 0 is n, 1 is l, 2 is c, 3 is r
  // and same business for the lengths
  uint32_t SRlength[4]={31,17,6,5};
  //  print32bits(*shift_[0]);

  ////////////////////////////////////////////////////
  ////////////////////////////////////////////////////
  // trying to rewrite generic shifter for pointer arrays:
  // also counters can be arrays too...
  // whole of SR should be configurable as stream of bits so we can read a description from another SR
  // also mode and pulses can modify bits
  ////////////////////////////////////////////////////

  uint32_t c=0;
  
  for (y=0;y<256;y++){

  if (c>3) {
    c=0;
    //    printf("\n");
    // they run at different speeds though so we cant do this///
    // what can we do?
/*
    Gshift_[0][0]=shift_[0]; 
    Gshift_[0][1]=shift_[0]; 
    Gshift_[0][2]=shift_[0];
    Gshift_[0][3]=shift_[0]; // ghosts for l,c,r only but let's keep one spare

    Gshift_[1][0]=shift_[1]; 
    Gshift_[1][1]=shift_[1]; 
    Gshift_[1][2]=shift_[1];
    Gshift_[1][3]=shift_[1]; // ghosts for l,c,r only but let's keep one spare

    Gshift_[2][0]=shift_[2]; 
    Gshift_[2][1]=shift_[2]; 
    Gshift_[2][2]=shift_[2];
    Gshift_[2][3]=shift_[2]; // ghosts for l,c,r only but let's keep one spare

    Gshift_[3][0]=shift_[3]; 
    Gshift_[3][1]=shift_[3]; 
    Gshift_[3][2]=shift_[3];
    Gshift_[3][3]=shift_[3]; // ghosts for l,c,r only but let's keep one spare      
*/
  }
  //  b=neworder[c];
  b=c;
  // we want speed to be a route:
  //    countern++;
  //  if (countern>=speedn){ 
  //    countern=0;
  //  printf("spedrot: %d\n", *speedroute[b][0]); // this works
  counter[b]++;
  //  if (counter[b]>*speedroute[b][0]){ // speed from our CV, CV as offset for DAC from (1,2,3,4) // just for speedCV modes - 0 is route
  if (counter[b]>0){ // speed from our CV, CV as offset for DAC from (1,2,3,4) // just for speedCV modes - 0 is route
    // how to make speed offset generic pointer (not) except using if ?
    counter[b]=0;
  // trial routing table
  // 6/9/2021 - important thing is if we have routing table then what do we do if is
  //  zeroes for one route - we need always to preserve a default route

    route[b]=default_route[b]; // lowest 4 bits of routing NLCR 1000 so C would be 0010 = 2  - or we use binary weighted
    Gshift_[b][0]=shift_[b]; 
    Gshift_[b][1]=shift_[b]; 
    Gshift_[b][2]=shift_[b];
    Gshift_[b][3]=shift_[b]; // ghosts for l,c,r only but let's keep one spare
    
  
  //  g=2; // n=0,l=1,c=2,r=3 // so feedback here is from c 
    //  bitn = ((shift_[b] >> (lfsr_taps[SRlength[b]][0])) ^ (shift_[b] >> (lfsr_taps[SRlength[b]][1])) ^ (shift_[b] >> (lfsr_taps[SRlength[b]][2])) ^ (shift_[b] >> (lfsr_taps[SRlength[b]][3]))) & 1u; // 32 is 31, 29, 25, 24
  
  // copy now to ghost
  //we need multiple ghosts for each possible shifter: eg. Gshift_rl, Gshift_rn, Gshift_rc (right ones for left, for n and for c)

  // what would ghosts in ghost look like... only for itself
  // and again ghost shift can occur on pulses in so is delayed rev...
  // which is the only way it makes sense
  // events for copy in, for shift and/or for bit extraction
  // if event {
  //  GGshift_[b]=Gshift_[b][b];
  // if event {
  //  bitr= (GGshift_[b]>>SRlength[b]) & 0x01;
  //  GGshift_[b]=(GGshift_[b]<<1)+bitr;
  // } wrap
  
  // alternative for array of revenants:
  //uint32_t Gshift_rev[4][256], Gshift_revcnt[4]={0,0,0,0};
  // if event {
  //  Gshift_rev[b][Gshift_revcnt[b]]=Gshift_[b][b];
  // if event {
  //  bitr= (Gshift_rev[b][Gshift_revcnt[b]]>>SRlength[b]) & 0x01;
  //  Gshift_rev[b][Gshift_revcnt[b]]=(Gshift_rev[b][Gshift_revcnt[b]]<<1)+bitr;
  //  Gshift_revcnt[b]++; // events for increment
  //  if (Gshift_revcnt[b]>255) Gshift_revcnt[b]=0;
  // } wrap
    // need to catch it
  //  if (shift_[b]==0)     shift_[b]=0xff;
  // what else it needs to know - for each queued SR we need one cogg=0 for reset as we reset each on reading

  shift_[b]=shift_[b]<<1;
  
  // decoding routing table into bits - max of 4 bits...
  // own routing means we have the shifted out bit already
  // we could also lag the ghost so is like a delayed revenant
  // so example it only shifts itself if there is a pulse bit

  bitr=0;   // leave off for above ghost in ghostings where we have a bitr 
  tmp=route[b]; // route can also be another SR!
  // if route to ourself then is cycling bit but we still need to cycle <<1 above!
  for (x=0;x<4;x++){
    if (tmp&0x01){  
      bitrr = (Gshift_[x][b]>>SRlength[x]) & 0x01; // or other logical opp for multiple bits/accum
      // could even shift them in one after the other
      // ghosts can also have ghosts and LFSR within themselves
      Gshift_[x][b]=(Gshift_[x][b]<<1)+bitrr; // but this doesn't make sense as then later ones - TOFIX/FIXED
      bitr |= bitrr;
    }
    tmp=tmp>>1;
  }

  
  // check that if is only a routing to itself that we do have one default route bit
//    if (route[b]==(1<<b)) { // only itself - add in default route which is?
  //  x=default_route[b];
//    bitr |= (Gshift_[b][x]>>SRlength[x]) & 0x01; // or other logical opp for multiple bits/accum
//    Gshift_[b][x]=(Gshift_[b][x]<<1)+bitr;
//  } 
  
  shift_[b]+= bitr;// & bitr;// ^ (!(GPIOC->IDR & 0x0010)); // or goes to 1s, xor is risky, AND works... and clockbit PC4
    printf("%d: ",b);
    print32bits(shift_[b]);
  //  print32bits(Gshift_[0][0]);
  //  printf("\n");

  // generic output for fake CLKINS on: LSRCLK-pulse9=PB12, RSRCLK-pulse10=PB13, CSRCLCK-pulse11=PB14
  // just deal with CLKS - they are all on PB. we can route to all/any so 3 bits

  // if (bitr)     GPIOB->BSRRL = clk_route[clkr];
  //  else GPIOB->BSRRH = clk_route[clkr]; // clear

  //    GPIOB->BSRRL = (1)<<2 | (1<<3) | (1<<4) | (1<<10) | (1<<12)  | (1<<13)  | (1<<14) | (1<<15) ;  // write bits
  //  GPIOA->BSRRL = (1)<<11 | (1<<12);// | (1<<4) | (1<<10) | (1<<12)  | (1<<13)  | (1<<14) | (1<<15) ;  // write bits

  
  }
    c++;

  }

  ////////////////////////////////////////////////////
  // how can we compare routing with ghosts to routing with coggs at different speeds
  ////////////////////////////////////////////////////
  // basic coggs code;
  /*
  
  uint32_t laster=0;
  for (x=0;x<128000;x++){
  
    speedn=rand()%1280;
    speedr=rand()%1280;
    //  speedn=9;speedr=9;
    SRlengthn=(rand()%28)+3; SRlengthr=(rand()%28)+3;

    
    //  printf("coggs:  ");
    shift_registern=0xff; shift_registerr=0xff; countern=0; counterr=0; coggr=1;coggn=0; bitr=0; // now they are the same!
  for (y=0;y<10241;y++){
  
  countern++;
  if (countern>=speedn){ 
    countern=0;
    bitn = ((shift_registern >> (lfsr_taps[SRlengthn][0])) ^ (shift_registern >> (lfsr_taps[SRlengthn][1])) ^ (shift_registern >> (lfsr_taps[SRlengthn][2])) ^ (shift_registern >> (lfsr_taps[SRlengthn][3]))) & 1u; // 32 is 31, 29, 25, 24
    // need to catch it
    //    if (shift_registern==0)     shift_registern=0xff;
    
    shift_registern=shift_registern<<1; // we are shifting left << so bit 31 is out last one
    //    bitn |=bit;
    if (coggr==0)    shift_registern+= bitn | bitr;
    else shift_registern+= bitn | ((shift_registerr>>(SRlengthr-(coggr-1)))&0x01);
    coggr++;
    if (coggr>(SRlengthr+1)) coggr=1; // we always update the cogg which is feeding into this one
    coggn=0;
  }

    
  counterr++;
  if (counterr>=speedr){
    counterr=0;
  bitr = (shift_registerr>>SRlengthr) & 0x01; // bit which would be shifted out but we don't use it so far
  shift_registerr=(shift_registerr<<1)+bitr; // loop in this case
  coggr=0;
  }  
  } // 32 y
  //  print32bits(shift_registern);
  laster=shift_registern;
  
  //  printf("ghosts: ");

  shift_registern=0xff; shift_registerr=0xff; countern=0; counterr=0;
  Gshift_registerr=0xff;
  
  for (y=0;y<10241;y++){
      
  countern++;
  if (countern>=speedn){ 
    countern=0;
    bitn = ((shift_registern >> (lfsr_taps[SRlengthn][0])) ^ (shift_registern >> (lfsr_taps[SRlengthn][1])) ^ (shift_registern >> (lfsr_taps[SRlengthn][2])) ^ (shift_registern >> (lfsr_taps[SRlengthn][3]))) & 1u; // 32 is 31, 29, 25, 24
    // need to catch it
    //    if (shift_registern==0)     shift_registern=0xff;
    // copy now to ghost
    Gshift_registern=shift_registern; // this could also be ORed or other logic operation with former ghost!
    shift_registern=shift_registern<<1; // we are shifting left << so bit 31 is out last one
    
    bitr=(Gshift_registerr>>SRlengthr) & 0x01; 
    Gshift_registerr=(Gshift_registerr<<1)+bitr; 

    shift_registern+= bitn | bitr;// & bitr;// ^ (!(GPIOC->IDR & 0x0010)); // or goes to 1s, xor is risky, AND works... and clockbit PC4
  }

  counterr++;
  if (counterr>=speedr){
    counterr=0;
  bitr = (shift_registerr>>SRlengthr) & 0x01; // bit which would be shifted out but we don't use it so far
  Gshift_registerr=shift_registerr; // this could also be ORed or other logic operation with former ghost!
  //  bitr = (shift_registerr>>SRlengthr) & 0x01; // bit which would be shifted out but we don't use it so far
  shift_registerr=(shift_registerr<<1)+bitr; // loop in this case  
  }
  
  
  } // 32 ghosts

  //      print32bits(shift_registern);
  //      printf("n: %d r: %d\n", speedn, speedr);
      if (shift_registern!=laster) printf("xxxxxxxxxxxxxxxxxx n: %d r: %d\n", speedn, speedr);
  }
  */
  // XOR;
  //  int testy=1^0^0;
  //  printf("TEST: %d\n", testy);
  
    //////////////////////////////////
    
  // test small SR and changes in length
  /*  SRlengthl=31;
    for (y=0;y<100000;y++){
      //      SRlengthl-=2;
            SRlengthl=((rand()%31)+1);
      //      SRlengthl=((rand()%14)*2)+2; // even
      //      SRlengthl=((rand()%15)*2)+1; // odd
      //      printf("%d\n", SRlengthl);
      //      if (SRlengthl==1) SRlengthl=31;
  for (x=0;x<32;x++){
    bitn=(shift_registerl>>SRlengthl) & 0x01; // try overlap with/without this shift
    if ((rand()%1024)==0) bitn^=1; // flips
    shift_registerl=(shift_registerl<<1)+bitn;
  }
    }
    print32bits(shift_registerl);
  */

  //    x=countbits(shift_[reg]&masky[length]); // lower length bits only
  //    y=divy[length]; // added table for this 7/10 - updated for 32 bits
  //    x*=y;
  //    break;


uint16_t divy[32]={4095, 2047, 1365, 1023, 819, 682, 585, 511, 455, 409, 372, 341, 315, 292, 273, 255, 240, 227, 215, 204, 195, 186, 178, 170, 163, 157, 151, 146, 141, 136, 132, 127}; // should this be more weighted...

  
  uint32_t countt, fff;

  countt=countbits(0xffffffff & masky[31]);
  fff=divy[31];
  countt*=fff;
  //  printf("count: %d \n", countt);
  
  //testing masks and overlaps - working
    /*
      uint32_t tmpp, tmp, sl=4;

  print32bits(shift_registerl);
  print32bits(Gshift_registern);

  shift_registerl=(shift_registerl<<1);
    // overlap bottom x bits of l with top x bits of Gn
  tmpp=shift_registerl&masky[sl]; // this is just lower bits
  //  print32bits(tmpp);
  shift_registerl&=invmasky[sl]; // clear lower - masks don't match but we did one shift - see if it makes sense? - try in test2.c
  //  print32bits(shift_registerl);
  tmp=Gshift_registern>>(32-sl); // top x bits
  //  print32bits(tmp);
  tmpp^=tmp;
  shift_registerl+=tmpp;
  
  print32bits(shift_registerl);
    */

  static uint32_t ADCshift_[4]={0xffff,0xffff,0xffff,0xffff};


  
  uint32_t toggle=1, bt, btt, regg=1;

  for (x=0;x<102400;x++){

      bt = ((ADCshift_[regg] >> (lfsr_taps[SRlength[regg]][0])) ^ (ADCshift_[regg] >> (lfsr_taps[SRlength[regg]][1])) ^ (ADCshift_[regg] >> (lfsr_taps[SRlength[regg]][2])) ^ (ADCshift_[regg] >> (lfsr_taps[SRlength[regg]][3]))) & 1u;
    ADCshift_[regg]=(ADCshift_[regg]<<1)+bt;

    printf("%d",bt);
  }


  /*
  for (x=0;x<102400;x++){
    SRlength[regg]=(rand()%27)+4;
    if ((rand()%2)==1) toggle^=1;
    if (toggle){
    bt = ((ADCshift_[regg] >> (lfsr_taps[SRlength[regg]][0])) ^ (ADCshift_[regg] >> (lfsr_taps[SRlength[regg]][1])) ^ (ADCshift_[regg] >> (lfsr_taps[SRlength[regg]][2])) ^ (ADCshift_[regg] >> (lfsr_taps[SRlength[regg]][3]))) & 1u;
    ADCshift_[regg]=(ADCshift_[regg]<<1)+bt;
    }
    else {
    bt = ((ADCshift_[regg] >> (lfsr_taps[SRlength[regg]][0])) ^ (ADCshift_[regg] >> (lfsr_taps[SRlength[regg]][1])) ^ (ADCshift_[regg] >> (lfsr_taps[SRlength[regg]][2])) ^ (ADCshift_[regg] >> (lfsr_taps[SRlength[regg]][3]))) & 1u;
    ADCshift_[regg]=(ADCshift_[regg]>>1)+(bt<<31);
    }
    if (ADCshift_[regg]==0) ADCshift_[regg]=0xff;
    printf("%d",bt);
  }
  */
  /*
 uint32_t length=3;
 //    bt=4095;
  //    bt=0b111111111111;
  btt=0b11111111111100000000000000000000;
  //  printf("xxxx %u %u\n",bt, btt);

  bt=0b1111;
  x=((bt & masky[length])>>(rightshift[length])<<leftshift[length]);
  x=1<<7;
  //  printf("xxxxxxxxx %d\n",x);
  bt=0;
  uint32_t xx;
  for (x=0;x<120;x++){
    if (rand()%4) bt^=1;
  ADCshift_[0]=(ADCshift_[0]<<1)+(bt&1);
  SRlength[2]=4;
  if ((x%5)==0){
  xx=(((ADCshift_[0] & masky[SRlength[2]])<<leftshift[SRlength[2]])&4095);//>>(rightshift[length]))<<leftshift[length];
    printf("%d\n",xx);//(bt*4095);
  }
  }*/

  for (x=0;x<31;x++){
  
  uint32_t k=pow(2,x);
    printf("%d\n",k);
  }


enum which {N,L,C,R};

typedef struct heavens_ { // fill out with trigger, routes, types, bits and other attributes,,,
  uint8_t which;
  uint8_t mode;
  uint8_t trigger;  
  uint8_t adcmode;
  uint8_t dacmode;
  uint8_t routein;
  uint8_t length;
  uint32_t Gshift_[4];
  uint32_t shift_;
  //  uint32_t(*dofunc)(void);
  uint32_t (*dofunc[64])(void); // or each has its own modes???
} heavens;

heavens gate[4];

 gate[L].which=L;
   
 // printf("%d \n", gate[R].which);

 // test timings;;;

  static uint32_t lastdac[4]={0,0,0,0}, dac[4]={0,0,0,0}, val;
  float alpha;
  static float time_now[4]={0.0f};
  long last_time[4];
  static long int_time[4]={0};
  int w=0;
  float speedf_[4]={0.0};

  speedf_[0]=logspeed[32];
  
  for (x=0;x<128;x++){
 
 
  if (time_now[w]>32768){
      int_time[w]=0; 
      time_now[w]-=32768.0f;
    }

  // fixed interpol
  //    alpha = time_now[w] - (float)int_time[w];
    //    dac[w] = ((float)delay_buffer[w][DELAY_SIZE-5] * alpha) + ((float)delay_buffer[w][DELAY_SIZE-6] * (1.0f - alpha)); // interpol but is just last and before last
  //   if (dac[w]>4095) dac[w]=4095;
  //    else if (dac[w]<0) dac[w]=0;
      dac[w]=lastdac[w];
      printf("%d\n",dac[w]);
      
  time_now[w] += speedf_[w];
  last_time[w] = int_time[w];
  int_time[w] = time_now[w];

  while (last_time[w]<int_time[w])      {
    val++;
    lastdac[w]=val;
    last_time[w] += 1;
  } // lasttime
  }
  printf("%d\n",1<<11);
  
}
