/*

<--------------+-------^-------+-------<
               |       |       |       |
               |       |       |       |
               +-------+       +-------+

0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  0  0  1  1  1  1  1  1  1  1  1  1  1  1  1  1  
0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  0  0  1  1  1  1  1  1  1  1  1  1  1  1  1  
0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  0  0  1  1  1  1  1  1  1  1  1  1  1  1  
0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  0  0  1  1  1  1  1  1  1  1  1  1  1  
0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  0  0  1  1  0  0  0  0  0  0  0  0  0  0  
0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  0  0  1  1  0  0  0  0  0  0  0  0  0  
1  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  0  0  1  0  0  1  1  1  1  0  1  1  
1  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  0  0  1  0  0  1  1  1  1  0  1  
0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  0  1  1  1  1  0  0  1  0  1  
0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  0  1  1  1  1  0  0  1  0  
0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  0  1  1  1  1  0  0  1  
0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  0  1  1  1  1  0  0  
0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  0  1  1  1  1  0  
0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  0  1  1  1  1  
0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  0  1  1  1  
0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1  1  1  1  0  0  0  0  1  1  1  1  1  1  1  0  0  
1  0  0  0  0  0  0  0  1  0  0  0  0  0  0  0  0  0  0  0  1  1  1  0  0  1  1  1  1  0  1  0  
1  0  0  0  0  0  0  0  1  0  1  1  1  1  1  1  1  1  1  1  1  0  0  0  1  1  0  0  0  0  1  0  
1  0  0  0  0  0  0  0  1  0  1  0  0  0  0  0  0  0  0  0  0  0  1  1  1  0  0  1  1  1  1  0  
1  0  0  0  0  0  0  0  0  1  0  1  0  0  0  0  0  0  0  0  0  0  0  1  1  1  0  0  1  1  1  1  

*at the moment we don't deal with fake CLKouts...*

  */ 

#include "stm32f4xx.h"
#include "stm32f4xx_dac.h"
#include "stm32f4xx_gpio.h"
#include "stm32f4xx_adc.h"
#include "stm32f4xx_dma.h"
#include "stm32f4xx_rcc.h"
#include "stm32f4xx_spi.h"
#include "stm32f4xx_exti.h"
#include "stm32f4xx_tim.h"
#include "misc.h"
#include "adc.h"
/////////////////////

uint32_t testmodes[4]={9,9,9,9}; // TEST

/* list modes here for easy access:

// - maybe to line up LFSR modes etc so they follow each other in a block

//0: all pass through only

//1: cycle round only XORbits - basic 0 DAC out

//2: cycle and pass only XORcycleXOR-bits - basic 0 DAC out
////
//3: N: passon/XOR-LFSR LR: passonORbits C: XOR-DACequiv  // note that for LR with no bits in these are all the same

//4: N: passon/XOR-ADC1bit LR: passonANDbits C:XOR-DAC1bit

//5: N: passon/XOR-ADCxbit LR: passonLEAKbits C: XOR-DACspacers

//// maybe remove 678! and add new ADC/DAC options instead

678: N:cycle/pass/XOR-ADCoptions LR: cycleandpasXOR-LOGOPbits C: as N/DACoptions //NOTE: these ones are quite destructive of ADC ins/orDAC?
6 LFSR
7 ADC1
8 ADCxbits

//////9- test code with other ADC and DAC options
//rung - cycle XOR with pass//=mode2

10 - model for probability modes?

/////
TODO: prob modes below as/and basic INT modes

- probability modes for (DAC, DAC+CV comp to SR,countedclk), prob of bit in/inverted bit in,
  XOR bit in from->[routed//cycled//ADCorLFSR//pulseifwehave], prob of
  bitin OR loopback, prob of bitin or inverted loopback, prob of
  cycle, new bit from bits/from route -> how many? make this clearer:

SR is customSR or RSR(routed SR)

1. if SR<CV  // int mode
2.if SR<DAC  // cv/int mode
3.if SR<DAC+CV // int mode
4.if sr<CLKCNT // cv mode
XX
1. invert cycling bit or not, pulsbit is ORed in (TM)
2. invert routedin bit or not, pulsbit is ORed in (TM)
3. mix of this?

3. new input (from pulsbit) or cycling bit (wiard and EN)
4. new input (from route) or cycling bit
5. new input (from ADC) or cycling bit
6. new input (from LFSR) or cycling bit

7-10 above with inverted cycling bit

so is quite a few modes for all options
///
- other modes/to fill in:

- Rungler:

Original: SR bit out XOR with OSC1 out (OSC1 speed/freq) is determined by SR (itself)

translated: cycling bit XOR with other SR out bit which is clocked by
SR/or DACspeed from itself (bit clock options are set BY SR itself) 

or:

cycling bit XOR with DACout from own/other SR vs. comparator=CV/DAC/DAC+CV/CLKCNT

///

- leaky logic, memory logic to play with 

- Beckett/gray code.

Gray code: where each line differs in only one bit
Beckett/gray: as gray code but bit first in first out (history of bits also for leaky???)

bit position x which has not changed... FIFO ... we have list of transitions (which bit flips) for n=5 etc.

- modes from original it.c ported to generic form

- use of clkins for LR to select options in CVmode as in AC

- AC modes, segmodes, ...

*/

/////////////////////

#define PULSEOUT {				  \
  tmp=(w<<1);					  \
  if (bitn) *pulsoutLO[tmp]=pulsouts[tmp];	  \
  else *pulsoutHI[tmp]=pulsouts[tmp];		  \
  lengthbit=(SRlength[w]>>1);			      \
  new_stat=(shift_[w] & (1<<lengthbit))>>lengthbit;   \
  if (prev_stat[w]==0 && new_stat==1) flipd[w]^=1;    \
  prev_stat[w]=new_stat;			      \
  tmp++;					      \
  if (flipd[w]) *pulsoutLO[tmp]=pulsouts[tmp];	      \
  else *pulsoutHI[tmp]=pulsouts[tmp];		      \
}


extern __IO uint16_t adc_buffer[12];
float LPF_Beta = 0.4; // 0<ÃŸ<1
uint32_t lookupadc[4]={0,3,9,6}; // CVs for speed
uint32_t dacroute[4]={2,3,2,1}; // DAC routing for probability modes etc...

#define FULL 0b11111111111111111111111111111111 //32 bits full
#define FROZENSPEED 1024 // 
#define MAXVALUE 4095
#define SMOOTHINGS 512 // we can hold 65536 of our 16 bit ADC values...speed
uint32_t cc=0, totc=0, smoothc[SMOOTHINGS];
uint32_t ll=0, totl=0, smoothl[SMOOTHINGS];
uint32_t rr=0, totr=0, smoothr[SMOOTHINGS];
uint32_t nn=0, totn=0, smoothn[SMOOTHINGS];

uint16_t mode[4]={0,0,0,0};
uint8_t clkr=7;
uint16_t lastmodec, lastmoden, lastmodel, lastmoder;
uint16_t lastlastmodec, lastlastmoden, lastlastmodel, lastlastmoder;
//uint16_t whichDAC=2;

volatile uint32_t intflag[4]={0,0,0,0}; // interrupt flag...
volatile uint32_t param[4]={0,0,0,0}; // interrupt flag...
uint32_t SRlength[4]={31,31,31,31};

// for generic CLK fake puls routing
//LSRCLK-pulse9=PB12, RSRCLK-pulse10=PB13, CSRCLCK-pulse11=PB14
// 000,001,010,011,100,101,110,111
static uint32_t clk_route[8]={0,
			      (1<<12),
			      (1<<13),
			      (1<<12) | (1<<13),
			      (1<<14),
			      (1<<12) | (1<<14),
			      (1<<14) | (1<<13),
			      (1<<12) | (1<<13) | (1<<14)
};

static uint32_t LFSR_[4]={0xf0fff,0xf0ff,0xff00f,0xff};
static uint32_t shift_[4]={0xffff,0xffff,0xffff,0xffff};
static uint32_t ADCshift_[4]={0xffff,0xffff,0xffff,0xffff};
static uint32_t ADCGshift_[4]={0xffff,0xffff,0xffff,0xffff};
static uint32_t Gshift_[4][4]={
 {0xff,0xff,0xff,0xff},
  {0xff,0xff,0xff,0xff},
  {0xff,0xff,0xff,0xff},
  {0xff,0xff,0xff,0xff}
};

static uint32_t GGshift_[4], cogg[4][4]; // gshift is 4 even though we don't use one
// GG is ghost in ghost

// and cycling/circling array of ghosts which can come back or go forwards/backwards - when these ghosts are copied over (on event)
// with 256 cycles/copies - or we can have variable length of this shifting array

uint32_t Gshift_rev[4][256], Gshift_revcnt[4]={0,0,0,0};

// simple modes: speedfrom, speedfrom_, inputbit, adctype, dactype, doit and route (some of these are fixed)
// route to itself, route from others
// TODO: basic structures, experiment with route bits from SRs, ghosts in ghosts and add in more esoteric modes
// small tweaks, changes for more diverse modes

// set of modes of how we interpret modes!!!
// 64 modes
//         32/16/8/4/2/1
//          1  1 1 1 1 1 - 6 bits

// 20.9.2021: route is 4 bits - 0->15 try quick mode->route


// so for simple pass through by speed would be: speedfrom=0/inputbit=2/adctype=0/route=last one as bit/
uint32_t speedfrom[4]={0,0,0,0}; //0 is CV, 1 is interrupt, 2 is DACspeedfrom_ + CV
uint32_t speedfrom_[4]={0,0,0,0}; // who we get dac offset from?
uint32_t inputbit[4]={0,2,2,2}; //0-LFSR,1-ADC,2-none
uint32_t LFSR[4]={0,1,2,3}; // which SR take the LFSR bits from! default is from itself -
uint32_t adctype[4]={0,0,0,0}; // 0-basic, 1-one bit
uint32_t dactype[4]={0,0,0,0}; // 0-basic, 1-equiv bits, 2-one bit
uint32_t doit[4]={1,0,0,0}; // covers what we do with cycling bit - 0 nada, 1=invert if srdacvalue[x]<param// param is 12 bits - can be other options
uint32_t whichdoit[4]={8,8,8,8}; // dac from???

uint32_t route[4]={8,1,2,1}; // route[4]={1,9,9,9}; NLCR=1248 0->15 binary routing table
uint32_t defroute[4]={3,0,1,0}; // 0,1,2,3 NLCR - not binary code but just one!
uint32_t defroutee[4]={3,0,1,1}; // 0,1,2,3 NLCR - in this one 3 routes from 1 too
uint32_t dacfrom[4]={0,0,0,0};

uint32_t ourroute[4]={0,0,0,0};


volatile uint32_t prev_stat[4]={0,0,0,0};
volatile uint32_t speed[4]={0,0,0,0};
volatile uint32_t dac[4]={0,0,0,0};
volatile uint32_t adc_[4]={0,0,0,0};
uint32_t counter_[4]={0,0,0,0};

// what are pulse ins?
// only for left and right! PC7 is RSR, PC8 is LSR
// generic table and all on GPIOC
static uint32_t pulsins[4]={0,1<<8,0,1<<7}; //N,L,C,R

// what are pulse outs?
// L1-PB2, L2-PC15, R1-PB3, R2-PA11, C1-PB4, C2-PA12
static uint32_t pulsouts[8]={0, 0, 1<<2,1<<15, 1<<4,1<<12, 1<<3,1<<11};

volatile uint16_t *pulsoutHI[8]={&(GPIOB->BSRRL), &(GPIOB->BSRRL), &(GPIOB->BSRRL), &(GPIOC->BSRRL), &(GPIOB->BSRRL), &(GPIOA->BSRRL), &(GPIOB->BSRRL), &(GPIOA->BSRRL) };
//                                  0              0              PB2            PC15           PB4            PA12           PB3            PA11 
volatile uint16_t *pulsoutLO[8]={&(GPIOB->BSRRH), &(GPIOB->BSRRH), &(GPIOB->BSRRH), &(GPIOC->BSRRH), &(GPIOB->BSRRH), &(GPIOA->BSRRH), &(GPIOB->BSRRH), &(GPIOA->BSRRH) }; // both are 16 bit registers

static uint8_t lookuplenall[32]={3, 3, 3, 3, 4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};

static uint8_t bitsz[256]={0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8}; // this is for 8 bits

static uint8_t rightshift[32]={0,0,0,0, 0,0,0,0, 0,0,0,0, // first 12 bits
				1,2,3,4, 5,6,7,8, 9,10,11,12, 13,14,15,16, 17,18,19,20};

static uint8_t leftshift[32]= {11,10,9, 8,7,6,5, 4,3,2,1,
				0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0};

// fixed masks 31/8/2021

static uint32_t invmasky[32]={//0,0,0, // skip all zeroes or all ones ??? skip all ones

  //0b11111111111111111111111111111111,
0b11111111111111111111111111111110,
0b11111111111111111111111111111100,
0b11111111111111111111111111111000,
0b11111111111111111111111111110000,
0b11111111111111111111111111100000,
0b11111111111111111111111111000000,
0b11111111111111111111111110000000,
0b11111111111111111111111100000000,
0b11111111111111111111111000000000,
0b11111111111111111111110000000000,
0b11111111111111111111100000000000,
0b11111111111111111111000000000000,
0b11111111111111111110000000000000,
0b11111111111111111100000000000000,
0b11111111111111111000000000000000,
0b11111111111111110000000000000000,
0b11111111111111100000000000000000,
0b11111111111111000000000000000000,
0b11111111111110000000000000000000,
0b11111111111100000000000000000000,
0b11111111111000000000000000000000,
0b11111111110000000000000000000000,
0b11111111100000000000000000000000,
0b11111111000000000000000000000000,
0b11111110000000000000000000000000,
0b11111100000000000000000000000000,
0b11111000000000000000000000000000,
0b11110000000000000000000000000000,
0b11100000000000000000000000000000,
0b11000000000000000000000000000000,
0b10000000000000000000000000000000,
0b00000000000000000000000000000000
};

  
static uint32_t masky[32]={//0,0,0, // skip all zeroes or all ones ??? all 0
			   0b00000000000000000000000000000001,			  
			   0b00000000000000000000000000000011,			  
			   0b00000000000000000000000000000111,			  
			   0b00000000000000000000000000001111,			  
			   0b00000000000000000000000000011111,			  
			   0b00000000000000000000000000111111,			  
			   0b00000000000000000000000001111111,			  
			   0b00000000000000000000000011111111,			  
			   0b00000000000000000000000111111111,			  
			   0b00000000000000000000001111111111,			  
			   0b00000000000000000000011111111111,			  
			   0b00000000000000000000111111111111,			  
			   0b00000000000000000001111111111111,			  
			   0b00000000000000000011111111111111,			  
			   0b00000000000000000111111111111111,			  
			   0b00000000000000001111111111111111,			  
			   0b00000000000000011111111111111111,			  
			   0b00000000000000111111111111111111,			  
			   0b00000000000001111111111111111111,			  
			   0b00000000000011111111111111111111,			  
			   0b00000000000111111111111111111111,			  
			   0b00000000001111111111111111111111,			  
			   0b00000000011111111111111111111111,			  
			   0b00000000111111111111111111111111,			  
			   0b00000001111111111111111111111111,			  
			   0b00000011111111111111111111111111,			  
			   0b00000111111111111111111111111111,			  
			   0b00001111111111111111111111111111,			  
			   0b00011111111111111111111111111111,			  
			   0b00111111111111111111111111111111,			  
			   0b01111111111111111111111111111111,			   
			   0b11111111111111111111111111111111,
};

static uint32_t othermasky[32]={  // skip all zeroes or all ones ???
  //  0b00000000000000000000000000000000,
  0b10000000000000000000000000000000,
  0b11000000000000000000000000000000,
  0b11100000000000000000000000000000,
  0b11110000000000000000000000000000,
  0b11111000000000000000000000000000,
  0b11111100000000000000000000000000,
  0b11111110000000000000000000000000,
  0b11111111000000000000000000000000,
  0b11111111100000000000000000000000,
  0b11111111110000000000000000000000,
  0b11111111111000000000000000000000,
  0b11111111111100000000000000000000,
  0b11111111111110000000000000000000,
  0b11111111111111000000000000000000,
  0b11111111111111100000000000000000,
  0b11111111111111110000000000000000,
  0b11111111111111111000000000000000,
  0b11111111111111111100000000000000,
  0b11111111111111111110000000000000,
  0b11111111111111111111000000000000,
  0b11111111111111111111100000000000,
  0b11111111111111111111110000000000,
  0b11111111111111111111111000000000,
  0b11111111111111111111111100000000,
  0b11111111111111111111111110000000,
  0b11111111111111111111111111000000,
  0b11111111111111111111111111100000,
  0b11111111111111111111111111110000,
  0b11111111111111111111111111111000,
  0b11111111111111111111111111111100,  
  0b11111111111111111111111111111110,
  0b11111111111111111111111111111111,
};


// TODO: test much greater range of slow speeds - and stop indicator/value at end -> first establish basic speed for all modes and then
// we can do this...

static uint16_t logger[1024]={1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39, 40, 40, 40, 40, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 47, 47, 47, 48, 48, 48, 49, 49, 49, 50, 50, 50, 51, 51, 51, 52, 52, 53, 53, 53, 54, 54, 54, 55, 55, 55, 56, 56, 57, 57, 57, 58, 58, 59, 59, 59, 60, 60, 61, 61, 61, 62, 62, 63, 63, 64, 64, 64, 65, 65, 66, 66, 67, 67, 68, 68, 69, 69, 69, 70, 70, 71, 71, 72, 72, 73, 73, 74, 74, 75, 75, 76, 76, 77, 78, 78, 79, 79, 80, 80, 81, 81, 82, 82, 83, 84, 84, 85, 85, 86, 86, 87, 88, 88, 89, 89, 90, 91, 91, 92, 93, 93, 94, 94, 95, 96, 96, 97, 98, 98, 99, 100, 100, 101, 102, 102, 103, 104, 105, 105, 106, 107, 107, 108, 109, 110, 110, 111, 112, 113, 113, 114, 115, 116, 117, 117, 118, 119, 120, 121, 121, 122, 123, 124, 125, 126, 127, 127, 128, 129, 130, 131, 132, 133, 134, 135, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 161, 162, 163, 164, 165, 166, 167, 168, 170, 171, 172, 173, 174, 175, 177, 178, 179, 180, 181, 183, 184, 185, 186, 188, 189, 190, 192, 193, 194, 196, 197, 198, 200, 201, 202, 204, 205, 206, 208, 209, 211, 212, 214, 215, 216, 218, 219, 221, 222, 224, 225, 227, 229, 230, 232, 233, 235, 236, 238, 240, 241, 243, 245, 246, 248, 250, 251, 253, 255, 257, 258, 260, 262, 264, 265, 267, 269, 271, 273, 275, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 317, 319, 321, 323, 325, 328, 330, 332, 334, 337, 339, 341, 343, 346, 348, 351, 353, 355, 358, 360, 363, 365, 368, 370, 373, 375, 378, 380, 383, 385, 388, 391, 393, 396, 399, 401, 404, 407, 410, 413, 415, 418, 421, 424, 427, 430, 433, 436, 439, 441, 444, 448, 451, 454, 457, 460, 463, 466, 469, 472, 476, 479, 482, 485, 489, 492, 495, 499, 502, 506, 509, 513, 516, 520, 523, 527, 530, 534, 537, 541, 545, 549, 552, 556, 560, 564, 567, 571, 575, 579, 583, 587, 591, 595, 599, 603, 607, 611, 616, 620, 624, 628, 632, 637, 641, 645, 650, 654, 659, 663, 668, 672, 677, 681, 686, 691, 695, 700, 705, 710, 715, 719, 724, 729, 734, 739, 744, 749, 754, 760, 765, 770, 775, 780, 786, 791, 796, 802, 807, 813, 818, 824, 830, 835, 841, 847, 852, 858, 864, 870, 876, 882, 888, 894, 900, 906, 912, 918, 925, 931, 937, 944, 950, 956, 963, 969, 976, 983, 989, 996, 1003, 1010, 1017, 1024}; //

// array for taps
// eg. 32-bit Galois LFSR with taps at 32, 30, 26, 25. Sequence length is 4294967295. 0 is a lock-up state.  -- minus one here - 31, 29, 25, 24
// bith= ((shift_registerh >> 31) ^ (shift_registerh >> 29) ^ (shift_registerh >> 25) ^ (shift_registerh >> 24)) & 1u; // 32 is 31, 29, 25, 24
// from: http://courses.cse.tamu.edu/walker/csce680/lfsr_table.pdf
// and reworked for length in test.c -> not so if we revert to basic code...
// note that we can have 2 mirrored with [n, A, B, C] -> [n, n-C, n-B, n-A] - maybe for LF to hF!

static uint8_t lfsr_taps[32][4] = {
        {0, 0, 0, 0},
        {0, 0, 0, 0},
        {0, 0, 0, 0},
        {3, 2, 0, 0},
        {4, 3, 2, 1},
        {5, 4, 2, 1},
        {6, 5, 4, 3},
        {7, 5, 4, 3},
        {8, 7, 5, 4},
        {9, 8, 6, 5},
        {10, 9, 8, 6},
        {11, 10, 7, 5},
        {12, 11, 9, 8},
        {13, 12, 10, 8},
        {14, 13, 12, 10},
        {15, 13, 12, 10},
        {16, 15, 14, 13},
        {17, 16, 15, 12},
        {18, 17, 16, 13},
        {19, 18, 15, 13},
        {20, 19, 18, 15},
        {21, 18, 17, 16},
        {22, 21, 19, 17},
        {23, 22, 20, 19},
        {24, 23, 22, 21},
        {25, 24, 23, 19},
        {26, 25, 24, 21},
        {27, 26, 23, 21},
        {28, 27, 26, 24},
        {29, 28, 25, 23},
        {30, 29, 28, 27},
        {31, 29, 25, 24},
  };

static uint8_t ghost_tapsL[32][4] = { // left hand path
        {0, 0, 0, 0},
        {0, 0, 0, 0},
        {0, 0, 0, 0},
        {3, 2, 0, 0},
        {4, 3, 2, 1},
        {5, 4, 2, 1},
        {6, 5, 4, 3},
        {7, 5, 4, 3},
        {8, 7, 5, 4},
        {9, 8, 6, 5},
        {10, 9, 8, 6},
        {11, 10, 7, 5},
        {12, 11, 9, 8},
        {13, 12, 10, 8},
        {14, 13, 12, 10},
        {15, 13, 12, 10},
        {16, 15, 14, 13},
        {17, 16, 15, 12},
        {18, 17, 16, 13},
        {19, 18, 15, 13},
        {20, 19, 18, 15},
        {21, 18, 17, 16},
        {22, 21, 19, 17},
        {23, 22, 20, 19},
        {24, 23, 22, 21},
        {25, 24, 23, 19},
        {26, 25, 24, 21},
        {27, 26, 23, 21},
        {28, 27, 26, 24},
        {29, 28, 25, 23},
        {30, 29, 28, 27},
        {31, 29, 25, 24},
  };


static uint8_t lfsr_taps_mirrored[32][4] = {
        {0, 0, 0, 0},
        {0, 0, 0, 0},
        {0, 1, 1, 1},
        {3, 2, 2, 0},
        {4, 2, 1, 0},
        {5, 3, 2, 0},
        {6, 2, 1, 0},
        {7, 3, 2, 1},
        {8, 3, 2, 0},
        {9, 3, 2, 0},
        {10, 3, 1, 0},
        {11, 5, 3, 0},
        {12, 3, 2, 0},
        {13, 4, 2, 0},
        {14, 3, 1, 0},
        {15, 4, 2, 1},
        {16, 2, 1, 0},
        {17, 4, 1, 0},
        {18, 4, 1, 0},
        {19, 5, 3, 0},
        {20, 4, 1, 0},
        {21, 4, 3, 2},
        {22, 4, 2, 0},
        {23, 3, 2, 0},
        {24, 2, 1, 0},
        {25, 5, 1, 0},
        {26, 4, 1, 0},
        {27, 5, 3, 0},
        {28, 3, 1, 0},
        {29, 5, 3, 0},
        {30, 2, 1, 0},
        {31, 6, 5, 1},
	 };

static uint8_t ghost_tapsR[32][4] = { // right hands path
        {0, 0, 0, 0},
        {0, 0, 0, 0},
        {0, 1, 1, 1},
        {3, 2, 2, 0},
        {4, 2, 1, 0},
        {5, 3, 2, 0},
        {6, 2, 1, 0},
        {7, 3, 2, 1},
        {8, 3, 2, 0},
        {9, 3, 2, 0},
        {10, 3, 1, 0},
        {11, 5, 3, 0},
        {12, 3, 2, 0},
        {13, 4, 2, 0},
        {14, 3, 1, 0},
        {15, 4, 2, 1},
        {16, 2, 1, 0},
        {17, 4, 1, 0},
        {18, 4, 1, 0},
        {19, 5, 3, 0},
        {20, 4, 1, 0},
        {21, 4, 3, 2},
        {22, 4, 2, 0},
        {23, 3, 2, 0},
        {24, 2, 1, 0},
        {25, 5, 1, 0},
        {26, 4, 1, 0},
        {27, 5, 3, 0},
        {28, 3, 1, 0},
        {29, 5, 3, 0},
        {30, 2, 1, 0},
        {31, 6, 5, 1},
	 };

static uint8_t countbts[4096]={0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 7, 8, 8, 9, 8, 9, 9, 10, 8, 9, 9, 10, 9, 10, 10, 11, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 7, 8, 8, 9, 8, 9, 9, 10, 8, 9, 9, 10, 9, 10, 10, 11, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 7, 8, 8, 9, 8, 9, 9, 10, 8, 9, 9, 10, 9, 10, 10, 11, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 7, 8, 8, 9, 8, 9, 9, 10, 8, 9, 9, 10, 9, 10, 10, 11, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 7, 8, 8, 9, 8, 9, 9, 10, 8, 9, 9, 10, 9, 10, 10, 11, 5, 6, 6, 7, 6, 7, 7, 8, 6, 7, 7, 8, 7, 8, 8, 9, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 7, 8, 8, 9, 8, 9, 9, 10, 8, 9, 9, 10, 9, 10, 10, 11, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 9, 8, 9, 9, 10, 7, 8, 8, 9, 8, 9, 9, 10, 8, 9, 9, 10, 9, 10, 10, 11, 7, 8, 8, 9, 8, 9, 9, 10, 8, 9, 9, 10, 9, 10, 10, 11, 8, 9, 9, 10, 9, 10, 10, 11, 9, 10, 10, 11, 10, 11, 11, 12};

uint16_t divy[12]={1364, 1364, 1364, 1023, 818, 681, 584, 511, 454, 408, 371, 340};

uint8_t logtable[4]={0,0,0,0};

// w/here was/is array of spacers for DAC code
static uint32_t shifty_spacers[8]={1,2,3,4,5,6,7,8};

// fix this array as seems off...//FIXED 5/10 using code in test.c based on gaps
static uint32_t pos[32][8]={ // for DAC PWM out wider spacings
{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},
{0,1,1,1,1,1,1,1},
{0,1,2,2,2,2,2,2},
{0,1,1,2,2,3,3,3},
{0,1,2,3,3,4,4,4},
{0,1,2,3,3,4,4,4},
{0,1,2,3,3,4,4,4},
{0,1,2,3,4,5,5,5},
{0,1,2,3,4,5,6,6},
{0,1,2,3,4,5,6,7},
{0,1,3,4,5,6,7,8},
{0,1,3,5,6,7,8,9},
{0,1,3,5,6,8,9,10},
{0,1,3,5,6,8,10,11},
{0,1,3,6,7,9,11,12},
{0,1,3,6,7,9,12,13},
{0,2,4,7,8,10,13,14},
{0,2,4,7,8,10,13,15},
{0,2,4,7,9,11,14,16},
{0,2,5,8,10,12,15,17},
{0,2,5,8,10,13,16,18},
{0,3,6,9,11,14,17,19},
{0,3,6,9,12,15,18,20},
{0,3,6,9,12,15,18,21},
{0,4,7,10,13,16,19,22}
};

 uint32_t spac[32]={0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7};

 uint32_t spacc[32][3]={
{0, 0, 0 },
{0, 0, 0 },
{0, 0, 0 },
{0, 0, 0 },
{1, 2, 3 },
{1, 2, 3 },
{1, 2, 3 },
{1, 2, 3 },
{2, 4, 6 },
{2, 4, 6 },
{2, 4, 6 },
{2, 4, 6 },
{3, 6, 9 },
{3, 6, 9 },
{3, 6, 9 },
{3, 6, 9 },
{4, 8, 12 },
{4, 8, 12 },
{4, 8, 12 },
{4, 8, 12 },
{5, 10, 15 },
{5, 10, 15 },
{5, 10, 15 },
{5, 10, 15 },
{6, 12, 18 },
{6, 12, 18 },
{6, 12, 18 },
{6, 12, 18 },
{7, 14, 21 },
{7, 14, 21 },
{7, 14, 21 },
{7, 14, 21 }
  };


uint32_t spacmask[32]={
0b11111111111111111111111111111011,
0b11111111111111111111111111111011,
0b11111111111111111111111111111011,
0b11111111111111111111111111111011,
0b11111111111111111111111111110000,
0b11111111111111111111111111110000,
0b11111111111111111111111111110000,
0b11111111111111111111111111110000,
0b11111111111111111111111110101010,
0b11111111111111111111111110101010,
0b11111111111111111111111110101010,
0b11111111111111111111111110101010,
0b11111111111111111111110110110110,
0b11111111111111111111110110110110,
0b11111111111111111111110110110110,
0b11111111111111111111110110110110,
0b11111111111111111110111011101110,
0b11111111111111111110111011101110,
0b11111111111111111110111011101110,
0b11111111111111111110111011101110,
0b11111111111111110111101111011110,
0b11111111111111110111101111011110,
0b11111111111111110111101111011110,
0b11111111111111110111101111011110,
0b11111111111110111110111110111110,
0b11111111111110111110111110111110,
0b11111111111110111110111110111110,
0b11111111111110111110111110111110,
0b11111111110111111011111101111110,
0b11111111110111111011111101111110,
0b11111111110111111011111101111110,
0b11111111110111111011111101111110
};

uint32_t lastspac[32][4]={
{0, 1, 2, 3 },
{0, 1, 2, 3 },
{0, 1, 2, 3 },
{0, 1, 2, 3 },
{0, 1, 2, 3 },
{0, 1, 2, 3 },
{0, 1, 2, 3 },
{0, 1, 2, 3 },
{1, 3, 5, 7 },
{1, 3, 5, 7 },
{1, 3, 5, 7 },
{1, 3, 5, 7 },
{2, 5, 8, 11 },
{2, 5, 8, 11 },
{2, 5, 8, 11 },
{2, 5, 8, 11 },
{3, 7, 11, 15 },
{3, 7, 11, 15 },
{3, 7, 11, 15 },
{3, 7, 11, 15 },
{4, 9, 14, 19 },
{4, 9, 14, 19 },
{4, 9, 14, 19 },
{4, 9, 14, 19 },
{5, 11, 17, 23 },
{5, 11, 17, 23 },
{5, 11, 17, 23 },
{5, 11, 17, 23 },
{6, 13, 20, 27 },
{6, 13, 20, 27 },
{6, 13, 20, 27 },
{6, 13, 20, 27 }
};

uint32_t lastspacbac[32][4]={
{0, 0, 0, 0 },
{0, 0, 0, 0 },
{0, 0, 0, 0 },
{0, 0, 0, 0 },
{0, 0, 0, 0 },
{0, 0, 0, 0 },
{0, 0, 0, 0 },
{0, 0, 0, 0 },
{1, 2, 2, 4 },
{1, 2, 2, 4 },
{1, 2, 2, 4 },
{1, 2, 2, 4 },

{2, 4, 6, 8 },
{2, 4, 6, 8 },
{2, 4, 6, 8 },
{2, 4, 6, 8 },

{3, 6, 8, 12 },
{3, 6, 8, 12 },
{3, 6, 8, 12 },
{3, 6, 8, 12 },

{4, 8, 12, 16 },
{4, 8, 12, 16 },
{4, 8, 12, 16 },
{4, 8, 12, 16 },

{5, 10, 15, 20 },
{5, 10, 15, 20 },
{5, 10, 15, 20 },
{5, 10, 15, 20 },

{6, 12, 18, 24 },
{6, 12, 18, 24 },
{6, 12, 18, 24 },
{6, 12, 18, 24 }

};




uint32_t others[4][3]={ // for triadx style - all but itself
{1,2,3},
{0,2,3},
{0,1,3},
{0,1,2}
};


// TODO:split/spaced bits in

// 0: xbits in, 1: 1bit 2: LFSR 3: equivalent bits 4: oscillator/clock 5: DACfrom_reg 6:param_from_reg 7:param as comparator for a single bit
// 8: seperate LFSR running here with length/length
// use otherpar as strobe/latch...

static inline int ADC_(uint32_t reg, uint32_t length, uint32_t type, uint32_t otherpar){ // here we use length as number of bits max is 12 bits
  static uint32_t n[4]={0,0,0,0},nn[4]={0,0,0,0}; // counters
  static int32_t integrator=0, oldValue=0;
  static uint32_t k, lastbt=0; // 21/9 - we didn't have k for one bits as static - FIXED/TEST!
  static uint8_t toggle=0;
  uint32_t bt=0;

  switch(type){
  case 0: // basic sequential length of upto 12 bits cycling in
  if (length>11) length=11;
      if (n[reg]>length) {
	k=(adc_buffer[12])>>(11-length); //
      n[reg]=0;
    }
    bt = (k>>n[reg])&0x01;
    n[reg]++;    
    break;

  case 1: // one bit audio input
    n[reg]++;
  if (n[reg]>50) {
    k=(adc_buffer[12]); // now 12 bits only // 16 bits to 12 bits - this is now our ADCin!
    n[reg]=0;
  }

  integrator+=k-oldValue;
   if(integrator>0)
  {
     oldValue=MAXVALUE;
     bt=1;
  }
   else
   {
      oldValue=0;
      bt=0;
   }   
   break;
  case 2: // LFSR
     // if we never change that default we can replace LFSR[reg] with reg!
    bt = ((shift_[LFSR[reg]] >> (lfsr_taps[SRlength[LFSR[reg]]][0])) ^ (shift_[LFSR[reg]] >> (lfsr_taps[SRlength[LFSR[reg]]][1])) ^ (shift_[LFSR[reg]] >> (lfsr_taps[SRlength[LFSR[reg]]][2])) ^ (shift_[LFSR[reg]] >> (lfsr_taps[SRlength[LFSR[reg]]][3]))) & 1u;
    break;
  case 3: // equivalent bits: TO TEST
       // lengths upto 11=12 - we need tables for divisions/shifts 
  if (length>11) length=11;

  if (n[reg]>length) {
    k=(adc_buffer[12]); //
    k=k/divy[length];
    n[reg]=0;
  }
  if (k!=0) {
    bt=1;
    k--;
  }
  else bt=0;
  n[reg]++;    
  break;
  case 4:// // 1 bit oscillator - train of length 1 bits followed by y 0 bits // here we need 2 params... we use otherpar
     if (n[reg]>length) { // 0s
       bt=0;
       if (nn[reg]>otherpar) {
	 n[reg]=0;
       }
       nn[reg]++;
     }
     else {
       bt=1;
       n[reg]++;
       nn[reg]=0;
     }         
     break;    
  case 5: // dac[otherpar] seq input we use otherpar
  if (length>11) length=11;
      if (n[reg]>length) {
	k=(dac[otherpar])>>(11-length); 
      n[reg]=0;
    }
    bt = (k>>n[reg])&0x01;
    n[reg]++;    
    break;
  case 6: //param[reg] seq input
  if (length>11) length=11;
      if (n[reg]>length) {
	k=(param[reg])>>(11-length); 
      n[reg]=0;
    }
    bt = (k>>n[reg])&0x01;
    n[reg]++;    
    break;

  case 7:// run LFSR-ADCshift and output a bit - again if we don't use redirection of LFSR[reg] then ...
    bt = ((ADCshift_[LFSR[reg]] >> (lfsr_taps[SRlength[LFSR[reg]]][0])) ^ (ADCshift_[LFSR[reg]] >> (lfsr_taps[SRlength[LFSR[reg]]][1])) ^ (ADCshift_[LFSR[reg]] >> (lfsr_taps[SRlength[LFSR[reg]]][2])) ^ (ADCshift_[LFSR[reg]] >> (lfsr_taps[SRlength[LFSR[reg]]][3]))) & 1u;
    ADCshift_[LFSR[reg]]=(ADCshift_[LFSR[reg]]<<1)+bt;
    break;
    
  case 8: 
    // we accumulate bits onto a ghosted register TO TEST
    // strobe places these onto the shift register in one chunk?
    // so we don't use returned bt
      if (length>11) length=11;
      if (n[reg]>length) {
	k=(adc_buffer[12])>>(11-length); //
      n[reg]=0;
    }
    bt = (k>>n[reg])&0x01;
    n[reg]++;    
    // then bt goes into newghostSR
    ADCGshift_[reg]=(ADCGshift_[reg]<<1)+bt;

    if (otherpar) { // strobe
      shift_[reg]&=invmasky[length]; // clear length bits
      shift_[reg]+=(ADCGshift_[reg]&masky[length]);
    }
    break;

  case 9: // basic sequential length of bits cycling in but zeroed by param which is trigger
  if (length>11) length=11;
      if (n[reg]>length) {
	k=(adc_buffer[12])>>(11-length); //
      n[reg]=0;
    }
      if (otherpar) bt=0;
      else bt = (k>>n[reg])&0x01;
    n[reg]++;    
    break;
    
    // dac for one bit input
  case 10: // one bit audio input
    n[reg]++;
  if (n[reg]>50) {
    k=dac[otherpar];
    n[reg]=0;
  }

  integrator+=k-oldValue;
   if(integrator>0)
  {
     oldValue=MAXVALUE;
     bt=1;
  }
   else
   {
      oldValue=0;
      bt=0;
   }   
   break;

  case 11:  // special case for spaced bit entry depending on length
    shift_[reg]&=spacmask[length]; //cleared
    k=(adc_buffer[12])>>8; // we want 4 bits
    shift_[reg]+=(k&1)+((k&2)<<spacc[length][0])+((k&4)<<spacc[length][1])+((k&8)<<spacc[length][2]);
    // 4 bits goes in
    // no bt return
    bt=0;
    break;   

    // strobe // latch modes - strobe becomes toggle
  case 12:     // 1-we keep on cycling ADC bits but only enter new bit on strobe - or vice versa
    if (otherpar) toggle^=1;

    if (length>11) length=11;
      if (n[reg]>length) {
	k=(adc_buffer[12])>>(11-length); //
      n[reg]=0;
    }
      if (toggle) {// strobe
      bt = (k>>n[reg])&0x01;
      lastbt=bt;
      }
      else bt=lastbt;
    n[reg]++;    
    break;
    
  case 13:     // 2-we only cycle ADC on strobe/toggle  - or vice versa
    if (otherpar) toggle^=1;
    if (length>11) length=11;

  if (n[reg]>length) {
	k=(adc_buffer[12])>>(11-length); //
      n[reg]=0;
    }
      bt = (k>>n[reg])&0x01;

      if (toggle) {// strobe
    n[reg]++;    
      }
    break;


  case 14: // STROBE: 3-one bit entry
    if (otherpar) toggle^=1;
    n[reg]++;
  if (n[reg]>50) {
    k=(adc_buffer[12]); // now 12 bits only // 16 bits to 12 bits - this is now our ADCin!
    n[reg]=0;
  }

  integrator+=k-oldValue;
   if(integrator>0)
  {
     oldValue=MAXVALUE;
     bt=1;
  }
   else
   {
      oldValue=0;
      bt=0;
   }   

      if (toggle) {// strobe
	lastbt=bt;
      }
      else bt=lastbt;
   break;

     case 15:// STROBE: run LFSR-ADCshift and output a bit - again if we don't use redirection of LFSR[reg] then ..
       if (otherpar) toggle^=1;
    bt = ((ADCshift_[LFSR[reg]] >> (lfsr_taps[SRlength[LFSR[reg]]][0])) ^ (ADCshift_[LFSR[reg]] >> (lfsr_taps[SRlength[LFSR[reg]]][1])) ^ (ADCshift_[LFSR[reg]] >> (lfsr_taps[SRlength[LFSR[reg]]][2])) ^ (ADCshift_[LFSR[reg]] >> (lfsr_taps[SRlength[LFSR[reg]]][3]))) & 1u;
    ADCshift_[LFSR[reg]]=(ADCshift_[LFSR[reg]]<<1)+bt;
      if (toggle) {// strobe
	lastbt=bt;
      }
      else bt=lastbt;    
    break;

  case 16: // STROBE for other LFSR too
     // if we never change that default we can replace LFSR[reg] with reg!
    if (otherpar) toggle^=1;
    bt = ((shift_[LFSR[reg]] >> (lfsr_taps[SRlength[LFSR[reg]]][0])) ^ (shift_[LFSR[reg]] >> (lfsr_taps[SRlength[LFSR[reg]]][1])) ^ (shift_[LFSR[reg]] >> (lfsr_taps[SRlength[LFSR[reg]]][2])) ^ (shift_[LFSR[reg]] >> (lfsr_taps[SRlength[LFSR[reg]]][3]))) & 1u;
      if (toggle) {// strobe
	lastbt=bt;
      }
      else bt=lastbt;    
    break;
       
    // INT MODES ONLY
  case 21: // INT // CV as comparator - for INT modes ONLY which don't use CV!
     bt=0;
     if (adc_buffer[12]>adc_buffer[lookupadc[reg]]) bt=1;
     break;
  case 22: // INT  //param[reg] as comparator
     bt=0;
     if ((adc_buffer[12]>>2)>param[reg]) bt=1;
     break;

     

  } // switch
     
  return bt;
}


static inline uint16_t leaks(uint16_t x, uint16_t y, uint16_t prob, uint16_t who){ // try lazy, stickyt, leaky, decaying logic here... // who is new 20/9 for which SR we take logic from...
  static uint16_t timer=0;
  uint16_t z;
  // p as probability or time
  // keep track of how many times this is called (for each register/bit position) and flipit

  // or we can track bits recording their position for a certain lifespan
  // one bit per SR is tracked and lost... so would be leakNSR for example for that bit
  
  // but that is too deterministic... but if we share timers or if timer is across different speeds
  //  prob=1;
  // leaky XOR to test
  if (prob>31) prob=31;
  
  if (x^y==0) return 0;
  //  shift_registerR=(shift_registerR<<1)+z; // we are shifting left << so bit 31 is out last one
  if ((shift_[who]&masky[prob])==0) return 1;
  //  else if (rand()%prob==0) return 1;
  return 0;
  
  /*  timer++;
  if (timer>p){
    timer=0;
    d^=1;
    }*/
}


//bitr=logop(bitr,bitrr,logopp[w]); // or other op TODO
// logop: 0-XOR, 1-OR, 2-&, 3leaks
static inline uint16_t logop(uint32_t bita, uint32_t bitaa, uint32_t type){ //TODO: xor, or, and, leaky, others?
  // 0 is XOR< 1 is OR etc
  if (type==0)  return (bita ^ bitaa);
  else if (type==1) return (bita | bitaa);
  else if (type==2) return (bita & bitaa);
  else if (type==3) return (leaks(bita, bitaa,8,3)); // leaks using RSR as random // where we get 8 from...
  return bita ^ bitaa; // default
}

// 0: xbit DAC, 1: equiv DAC, 2: 1bit 3: spacers 4: strobed xbit DAC UNTESTED 5: 4 bits spaced dac/no equv 6: 
// TODO: what we add to this: shifty_spacers, sequential x bit DAC, sequential equiv DAC, seq spaced DAC
// also we can have one bit data with selection of params for BETA!
static inline uint32_t DAC_(uint32_t reg, uint32_t length, uint32_t type, uint32_t param){ //
  // DAC is 12 bits
  uint32_t y,x=0;
  static float SmoothData[4]={0.0, 0.0, 0.0, 0.0};
  static uint32_t lastout=0;
  static uint8_t toggle=0;
  
  switch(type){
  case 0:// standard bit DAC for x bits
    //    if (reg<4 && length>3 && length<32) 
      x=((shift_[reg] & masky[length-3])>>(rightshift[length-3]))<<leftshift[length-3]; // we want 12 bits but is not really audible difference    
      break;
  case 1:
      // equivalent bit DAC for x bits - we need a table for this!
      // or more like set of tables for each bit
      // and we need divide highest but number - eg. for 8 bits we have max 8 (all 1s) - max 12 bits DAC is 4096 4096/8=512 4096/12=341
      // we can have another table for this - but just taking maybe max of 12 bits otherwise lookup is too long (max 12 bits=4096)
    //      if (reg<4){
    //    length=8;
	if (length>11) length=11;
	x=countbts[shift_[reg]&masky[length]]; // lower length bits only
	y=divy[length]; // added table for this 7/10
	  x*=y;
	  //      }
	  break;
  case 2: // one bit audio
    // top bit
    y=(shift_[reg]>>length)&1;
    if (y==1) x=4095;
    else x=0;
    SmoothData[reg] = SmoothData[reg] - (LPF_Beta * (SmoothData[reg] - x)); // how do we adjust beta for speed?
    x=(int)SmoothData[reg];
    break;
  case 3: //spacers - how did we do this?
    x = (shift_[reg]&0xFF)<<4; // just the lower 8 bits - no spacings
    if (length>7){ // real length >8
      x = ((shift_[reg] & 0x01) + ((shift_[reg]>>pos[length][1])&0x02) + ((shift_[reg]>>pos[length][2])&0x04) + ((shift_[reg]>>pos[length][3])&0x08) + ((shift_[reg]>>pos[length][4])&0x10) + ((shift_[reg]>>pos[length][5])&0x20) + ((shift_[reg]>>pos[length][6])&0x40) + ((shift_[reg]>>pos[length][7])&0x80))<<4;
      //       {0, 0, 1, 3, 6, 10, 15, 21} // for 32 bits = length=31 - check sense of this
    }
    break;
  case 4: // only output standard DAC on param->strobe/clock! so just maintain lastout
    if (param) {
      x=((shift_[reg] & masky[length-3])>>(rightshift[length-3]))<<leftshift[length-3]; // we want 12 bits but is not really audible difference
      lastout=x;
    }
    else x=lastout;
    break;
    /*  case 5: // hold last DAC on strobe/clk is inverse of 5
    if (param) {
      x=lastout;
    }
    else {
      x=((shift_[reg] & masky[length-3])>>(rightshift[length-3]))<<leftshift[length-3]; // we want 12 bits but is not really audible difference
      lastout=x;
    }      
    break;*/    
  case 6: // toggle to hold/release DAC
    if (param) toggle^=1;
    if (toggle) {
      x=lastout;
    }
    else {
      x=((shift_[reg] & masky[length-3])>>(rightshift[length-3]))<<leftshift[length-3]; // we want 12 bits but is not really audible difference
      lastout=x;
    }      
    break;
    // but we need to space these back TEST AGAIN
  case 7: // 4 spaced bits out! equiv bits or not - in this case not
    x= ( ( (shift_[reg]& (1<<lastspac[length][0]))>>lastspacbac[length][0]) + ((shift_[reg]& (1<<lastspac[length][1]))>>lastspacbac[length][1]) + ((shift_[reg]& (1<<lastspac[length][2]))>>lastspacbac[length][2]) + ((shift_[reg]& (1<<lastspac[length][3]))>>lastspacbac[length][3]) )<<8; // 4 bits to 12 bits
    break;

  case 8: // 4 spaced bits out! equiv bits
    x= ( ((shift_[reg]& (1<<lastspac[length][0]))>>lastspacbac[length][0]) + ((shift_[reg]& (1<<lastspac[length][1]))>>lastspacbac[length][1]) + ((shift_[reg]& (1<<lastspac[length][2]))>>lastspacbac[length][2]) + ((shift_[reg]& (1<<lastspac[length][3]))>>lastspacbac[length][3]) ); 
    x=countbts[x]*1023;
    break;
  } // switch


  return x;
}



///////////////////////////////////////////////////////////////////////// 

#define delay()						 do {	\
    register unsigned int ix;					\
    for (ix = 0; ix < 1000; ++ix)				\
      __asm__ __volatile__ ("nop\n\t":::"memory");		\
  } while (0)

#define delayy()						 do {	\
    register unsigned int ix;					\
    for (ix = 0; ix < 10000000; ++ix)				\
      __asm__ __volatile__ ("nop\n\t":::"memory");		\
  } while (0)

void NMI_Handler(void)
{
}

void HardFault_Handler(void)
{
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
  {
  }
}

void MemManage_Handler(void)
{
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
  {
  }
}

void BusFault_Handler(void)
{
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {
  }
}

void UsageFault_Handler(void)
{
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
  {
  }
}

void SVC_Handler(void)
{
}

void DebugMon_Handler(void)
{
}

void PendSV_Handler(void)
{
}

// - different ways of counting pulseins (eg. reset generic counter on pulsein) or count gap between pulses = number of pulses in time x

void EXTI4_IRQHandler(void){ // working NSR 
  uint32_t tmp, tmpp;
if (EXTI_GetITStatus(EXTI_Line4) != RESET) {
  intflag[0]=1; //NSR
  //  counter_[0]++; // overflow at 32 bits
  // time from last interrupt
  param[0]=counter_[0];
  counter_[0]=0;
  EXTI_ClearITPendingBit(EXTI_Line4);
 }
 }

void EXTI9_5_IRQHandler(void){ // PC5 RSR works and PB6 LSR share same line but both work out
  uint32_t tmp, tmpp;
  uint16_t j, bit, xx, x;
  uint32_t lengthbitl=15, new_statl, new_statr,new_statc, lengthbitc=15, lengthbitr=15; // for 2nd bit on lsr, rsr and csr
  
  // added PB7 now for CSRCLKIN CSR which moved from PC3!!!
  // CSR: PC3->now PB7, NSR: PC4, RSR: PC5, LSR: PB6
  
  
  if (EXTI_GetITStatus(EXTI_Line5) != RESET) { //RSR  
    intflag[3]=1; //RSR
    //    counter_[3]++; // overflow at 32 bits
    param[3]=counter_[3];
      counter_[3]=0;
    EXTI_ClearITPendingBit(EXTI_Line5);
 }

  if (EXTI_GetITStatus(EXTI_Line6) != RESET) { //LSR
    intflag[1]=1; //LSR
    //  counter_[1]++; // overflow at 32 bits
    param[1]=counter_[1];
    counter_[1]=0;
    EXTI_ClearITPendingBit(EXTI_Line6);
 } 

  if (EXTI_GetITStatus(EXTI_Line7) != RESET) {// CSR
    intflag[2]=1; //CSR
    //    counter_[2]++; // overflow at 32 bits
    param[2]=counter_[2];
    counter_[2]=0;
    EXTI_ClearITPendingBit(EXTI_Line7);
 } 
}

void TIM4_IRQHandler(void) 
// HERE we do speed and modes ALL TODO AS ARRAYS

{
  uint32_t temp;
  volatile static uint16_t tmp;

  TIM_ClearITPendingBit(TIM4, TIM_IT_Update); 

  /*  
      tmp^=1;
      if (tmp) GPIOB->BSRRH = (1)<<4;  // clear bits PB2
      else   GPIOB->BSRRL=(1)<<4; //  write bits   
  */

  // map ADCs:

    // 0: nspd, 1: nlen, 2: nmode
    // 3: lspd, 4: llen, 5: lmode
    // 6: rspd, 7: rlen, 8: rmode // adc6 fixed hw
    // 9: cspd, 10: clen, 11: cmode

  // modes are NOT inverted!
  
  //moden
  temp=(adc_buffer[2]+lastlastmoden+lastmoden)/3; 
  lastlastmoden=lastmoden;
  lastmoden=temp;
  mode[0]=(temp>>6); // 64 modes = 6 bits  

  // modec
  temp=(adc_buffer[11]+lastlastmodec+lastmodec)/3; 
  lastlastmodec=lastmodec;
  lastmodec=temp;
  mode[2]=(temp>>6); // 64 modes = 6 bits  

  // model
  temp=(adc_buffer[5]+lastlastmodel+lastmodel)/3; 
  lastlastmodel=lastmodel;
  lastmodel=temp;
  mode[1]=(temp>>6); // 64 modes = 6 bits  

  // moder
  temp=(adc_buffer[8]+lastlastmoder+lastmoder)/3; 
  lastlastmoder=lastmoder;
  lastmoder=temp;
  mode[3]=(temp>>6); // 64 modes = 6 bits  
  
  // speedn
  totn=totn-smoothn[nn];
  smoothn[nn]=adc_buffer[0];
  totn+=smoothn[nn];
  nn++;
  if (nn>=SMOOTHINGS) nn=0;
  temp=totn/SMOOTHINGS;  
  speed[0]=logger[temp>>2];

  // speedl
  totl=totl-smoothl[ll];
  smoothl[ll]=adc_buffer[3];
  totl+=smoothl[ll];
  ll++;
  if (ll>=SMOOTHINGS) ll=0;
  temp=totl/SMOOTHINGS;  
  speed[1]=logger[temp>>2];

  // speedr
  totr=totr-smoothr[rr];
  smoothr[rr]=adc_buffer[6];
  totr+=smoothr[rr];
  rr++;
  if (rr>=SMOOTHINGS) rr=0;
  temp=totr/SMOOTHINGS;  
  speed[3]=logger[temp>>2];

    // speedc
  totc=totc-smoothc[cc];
  smoothc[cc]=adc_buffer[9];
  totc+=smoothc[cc];
  cc++;
  if (cc>=SMOOTHINGS) cc=0;
  temp=totc/SMOOTHINGS;  
  speed[2]=logger[temp>>2];
  
  // lens from 4 to 32

  temp=31-(adc_buffer[1]>>7); // 12 bits to 5 bits 
  SRlength[0]=lookuplenall[temp];

  temp=31-(adc_buffer[4]>>7); // 12 bits to 5 bits 
  SRlength[1]=lookuplenall[temp];

  temp=31-(adc_buffer[7]>>7); // 12 bits to 5 bits 
  SRlength[3]=lookuplenall[temp];

  temp=31-(adc_buffer[10]>>7); // 12 bits to 5 bits 
  SRlength[2]=lookuplenall[temp];

}

void TIM2_IRQHandler(void) // running with period=1024, prescale=32 at 2KHz - how fast can we run this?
// period 32, prescaler 8 = toggle of 104 KHz
// 4 and 4 we go up to 800 KHz
{
  uint32_t lengthbit=15, new_stat;
  uint32_t x, y, q, start=0;
  uint32_t bitn, bitnn, bitnnn, bitnnnn, bitrr, tmp, tmpp, xx;
  uint8_t trigger[4]={0,0,0,0};
  static uint32_t flipd[4]={0,0,0,0}, flipper=1, w=0, count=0;
  static uint32_t counter[4]={0,0,0,0};
  static uint32_t train[4]={0,0,0,0};
  int32_t tmpt;
  
  TIM_ClearITPendingBit(TIM2, TIM_IT_Update); // needed

  ////////////////////////////////////////////////////
  // taking off from GENERIC SR but we need differences
  // //so also that each mode then has a code for: speedfrom/inputbit/adctype/route/ - later add in DAC etc.
  // so for simple pass through by speed would be: speedfrom=0/inputbit=2/adctype=0/route=last one as bit/
  ////////////////////////////////////////////////////

  // crash detect ++ 32/64 in main.c is 14KHz
  /*       flipper^=1;
     if (flipper) GPIOB->BSRRH = (1)<<4;  // clear bits PB2
     else   GPIOB->BSRRL=(1)<<4; //  write bits   
  */

    /* // we don't deal with CLKs now!  
    //TODO: ghostSRs for normed clks (with speed of these from what, from RDAC?)
  if (w==2 && counter[2]>speed[w] && speedfrom[2]==1){ // 2 is Cspeed - but we have a problem when Cspeed is from an interrupt as this is never generated...FIXED HERE
      counter[2]=0;
      flipper^=1;
      if (flipper) GPIOB->BSRRH = clk_route[clkr];  // clear bits of fake_one - clkr is 7 so all of them
      // or we can set L and R from an independent SR with only CSR as clocked from here
      else   GPIOB->BSRRL=clk_route[clkr]; //  write bits       
    }
  */

  // for the time between counts
  counter_[0]++;  counter_[1]++;  counter_[2]++;  counter_[3]++;

  
  w++;
  if (w>3) w=0;

  // process INT?
  if (intflag[w]) {
    trigger[w]=1;
    intflag[w]=0;
  }
  else  trigger[w]=0;

  // genericLFSR
  tmp= ((LFSR_[w] >> 31) ^ (LFSR_[w] >> 29) ^ (LFSR_[w] >> 25) ^ (LFSR_[w] >> 24)) & 1u; // 32 is 31, 29, 25, 24
  LFSR_[w] = (LFSR_[w]<<1) + tmp;
  
  counter[w]++;

  mode[w]=testmodes[w];
  switch(mode[w]){ // start with simple routes and ADC/DAC options
    // but how do we work this - cases for w, or ifs or more generic?

    ///////////////////////////////////////////////////////////////////////// 
  case 0: // Just passes on/CSR is basic DAC 0 - well they all are which makes question of modes?
    // TEST mode: start with basic pass through and basic routing - first try pass along as generic structure (no input, fixed routings, DAC out (8 bit)
    // speed is from cv only - we don't use CLKIN
    // case 0 can go to zero if NSR SR zeroes out
    
    if (counter[w]>speed[w]){
    dactype[2]=0; // basic DAC out, others are fixed as basic

    counter[w]=0; 
    Gshift_[w][0]=shift_[w]; 
    Gshift_[w][1]=shift_[w]; 
    Gshift_[w][2]=shift_[w];
    Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;
  
    //3-what is routing for incoming SR bits, cycling bit
    // we have default route here
    bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01; 
    Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
    //    bitn=bitn^bitrr; // just XOR now for this mode

    //4-what is incoming pulsin bit if any? - incoming pulse will always be XORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn^=xx;
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); // TODO - add in DACtype.. basic DAC-0

    //7-pulses out if any
    PULSEOUT;
    }// counterw
  break; 

  ///////////////////////////////////////////////////////////////////////// 
  case 1: // cycle round only
  if (counter[w]>speed[w]){
    dactype[2]=0; // basic DAC out, others are fixed as basic
    counter[w]=0; 

      Gshift_[w][0]=shift_[w]; 
      Gshift_[w][1]=shift_[w]; 
      Gshift_[w][2]=shift_[w];
      Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;
  
    //3-what is routing for incoming SR bits, cycling bit
    // we have default route here
    //    bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01; 
    //    Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
    //    bitn=bitn^bitrr; // just XOR now for this mode
    bitn=(shift_[w]>>SRlength[w])& 0x01; //cycling bit
    
    //4-what is incoming pulsin bit if any? - incoming pulse will always be ORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn^=xx;
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); // TODO - add in DACtype.. basic DAC-0

    //7-pulses out if any
    PULSEOUT;
  }// counterw
  break; 

  case 2: // cycle and pass only
  if (counter[w]>speed[w]){
    dactype[2]=0; // basic DAC out, others are fixed as basic
    counter[w]=0; 

      Gshift_[w][0]=shift_[w]; 
      Gshift_[w][1]=shift_[w]; 
      Gshift_[w][2]=shift_[w];
      Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;
  
    //3-what is routing for incoming SR bits, cycling bit
    // we have default route here
    bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01; 
    Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
    bitn^=(shift_[w]>>SRlength[w])& 0x01; //cycling bit XOR in     
    //    bitn=bitn^bitrr; // just XOR now for this mode

    //4-what is incoming pulsin bit if any? - incoming pulse will always be ORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn^=xx;
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); // TODO - add in DACtype.. basic DAC-0

    //7-pulses out if any
    PULSEOUT;
  }// counterw
  break;

  case 3: 
    // N: ADC/IN, route from/bits in/logic - pass on/XOR - LFSR 
    // L: route from/bits in/logic - pass on/OR
    // C: DAC/OUT, route from/bits in/logic - pass on/XOR - DACequiv
    // R: route from/bits in/logic  - pass on/OR
    
  if (counter[w]>speed[w]){
    counter[w]=0; 
    // here we can set options
    dactype[2]=1; // equiv DAC out, others are fixed as basic
    //    logtable[4]={0,1,0,1}; we set L and R to 1 which is OR
    logtable[0]=0; logtable[1]=1; logtable[2]=0; logtable[3]=1;
    
    Gshift_[w][0]=shift_[w]; 
    Gshift_[w][1]=shift_[w]; 
    Gshift_[w][2]=shift_[w];
    Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;
  
    //3-what is routing for incoming SR bits, cycling bit
    // we have default route here
    // BUT for LFSR in we have another route
    if (w==0){
      bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01;  
      Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      bitn^=ADC_(w,SRlength[w],2,0); // XOR with LFSR
    }
    else
      {
    bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01; 
    Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      }

    //4-what is incoming pulsin bit if any? - incoming pulse will always be ORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn=logop(bitn,xx,logtable[w]); // just for bits in
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); 

    //7-pulses out if any
    PULSEOUT;
  }// counterw
  break; 

  case 4: // 
    // N: ADC/IN, route from/bits in/logic - pass on/XOR - ADC1bit 
    // L: route from/bits in/logic - pass on/AND
    // C: DAC/OUT, route from/bits in/logic - pass on/XOR - DAC1bit
    // R: route from/bits in/logic  - pass on/AND
    
  if (counter[w]>speed[w]){
    counter[w]=0; 
    // here we can set options
    dactype[2]=2; // 1 bit DAC out
    //    logtable[4]={0,1,0,1}; we set L and R to 1 which is OR
    logtable[0]=0; logtable[1]=2; logtable[2]=0; logtable[3]=2;
    
    Gshift_[w][0]=shift_[w]; 
    Gshift_[w][1]=shift_[w]; 
    Gshift_[w][2]=shift_[w];
    Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;
  
    //3-what is routing for incoming SR bits, cycling bit
    // we have default route here
    // BUT for LFSR in we have another route
    if (w==0){
      bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01;  
      Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      bitn^=ADC_(w,SRlength[w],1,0); // XOR with 1 bit audio
    }
    else
      {
    bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01; 
    Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      }

    //4-what is incoming pulsin bit if any? - incoming pulse will always be ORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn=logop(bitn,xx,logtable[w]); // just for bits in
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); 

    //7-pulses out if any
    // L, C and R have 2 clocks out, N has none    
    tmp=(w<<1);
    if (bitn) *pulsoutLO[tmp]=pulsouts[tmp]; // N is just B with always zero
    else *pulsoutHI[tmp]=pulsouts[tmp];

    // follow AC scheme but we do maybe do a divide down of another bit-sofar is same! - make GENERIC    
    lengthbit=(SRlength[w]>>1); // /2
    new_stat=(shift_[w] & (1<<lengthbit))>>lengthbit; // so that is not just a simple divide down

    if (prev_stat[w]==0 && new_stat==1) flipd[w]^=1;
    prev_stat[w]=new_stat;	
    tmp++;
    if (flipd[w]) *pulsoutLO[tmp]=pulsouts[tmp];
    else *pulsoutHI[tmp]=pulsouts[tmp];        
  }// counterw
  break; 

    case 5: // 
    // N: ADC/IN, route from/bits in/logic - pass on/XOR - ADCxbit 
    // L: route from/bits in/logic - pass on/OR
    // C: DAC/OUT, route from/bits in/logic - pass on/XOR - DACspacers
    // R: route from/bits in/logic  - pass on/OR
    
  if (counter[w]>speed[w]){
    counter[w]=0; 
    // here we can set options
    dactype[2]=3; // spacerbit DAC out
    //    logtable[4]={0,1,0,1}; we set L and R to 1 which is OR
    logtable[0]=0; logtable[1]=3; logtable[2]=0; logtable[3]=3; // leaks
    
    Gshift_[w][0]=shift_[w]; 
    Gshift_[w][1]=shift_[w]; 
    Gshift_[w][2]=shift_[w];
    Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;
  
    //3-what is routing for incoming SR bits, cycling bit
    // we have default route here
    // BUT for LFSR in we have another route
    if (w==0){
      bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01;  
      Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      bitn^=ADC_(w,SRlength[w],1,0); // XOR with 1 bit audio
    }
    else
      {
    bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01; 
    Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      }

    //4-what is incoming pulsin bit if any? - incoming pulse will always be ORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn=logop(bitn,xx,logtable[w]); // just for bits in
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); 

    //7-pulses out if any
PULSEOUT;  }// counterw
  break; 

  case 6: // 

    // N: ADC/IN, route from/bits in/logic - cycleXORpass on/XOR - LFSR 
    // L: route from/bits in/logic - cycle/pass on/OR
    // C: DAC/OUT, route from/bits in/logic - cycle/pass on/XOR - DACequiv
    // R: route from/bits in/logic  - cycle/pass on/OR
    
  if (counter[w]>speed[w]){
    counter[w]=0; 
    // here we can set options
    dactype[2]=1; // equiv DAC out, others are fixed as basic
    // logop: 0-XOR, 1-OR, 2-&, 3leaks
    logtable[0]=0; logtable[1]=1; logtable[2]=0; logtable[3]=1;
    
    Gshift_[w][0]=shift_[w]; 
    Gshift_[w][1]=shift_[w]; 
    Gshift_[w][2]=shift_[w];
    Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;
  
    //3-what is routing for incoming SR bits, cycling bit
    // we have default route here
    // BUT for LFSR in we have another route
    if (w==0){
      bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01;  
      Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      bitn^=ADC_(w,SRlength[w],2,0); // XOR with LFSR
      bitn^=(shift_[w]>>SRlength[w])& 0x01; //cycling bit XOR in     
    }
    else
      {
    bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01; 
    Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
    bitn^=(shift_[w]>>SRlength[w])& 0x01; //cycling bit XOR in - could be logop but...
      }

    //4-what is incoming pulsin bit if any? - incoming pulse will always be ORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn=logop(bitn,xx,logtable[w]); // just for bits in
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); 

    //7-pulses out if any
PULSEOUT;  }// counterw
  break; 

  case 7: // 
    // N: ADC/IN, route from/bits in/logic - cyclepass on/XOR - ADC1bit 
    // L: route from/bits in/logic - cyclepass on/AND
    // C: DAC/OUT, route from/bits in/logic - cyclepass on/XOR - DAC1bit
    // R: route from/bits in/logic  - cyclepass on/AND
    
  if (counter[w]>speed[w]){
    counter[w]=0; 
    // here we can set options
    dactype[2]=2; // 1 bit DAC out
    //    logtable[4]={0,1,0,1}; we set L and R to 1 which is OR
    logtable[0]=0; logtable[1]=2; logtable[2]=0; logtable[3]=2;
    
    Gshift_[w][0]=shift_[w]; 
    Gshift_[w][1]=shift_[w]; 
    Gshift_[w][2]=shift_[w];
    Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;
  
    //3-what is routing for incoming SR bits, cycling bit
    // we have default route here
    // BUT for LFSR in we have another route
    if (w==0){
      bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01;  
      Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      bitn^=ADC_(w,SRlength[w],1,0); // XOR with 1 bit audio
      bitn^=(shift_[w]>>SRlength[w])& 0x01; //cycling bit XOR in     
    }
    else
      {
    bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01; 
    Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;
    bitn^=(shift_[w]>>SRlength[w])& 0x01; //cycling bit XOR in     
      }

    //4-what is incoming pulsin bit if any? - incoming pulse will always be ORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn=logop(bitn,xx,logtable[w]); // just for bits in
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); 

    //7-pulses out if any
PULSEOUT;  }// counterw
  break; 

    case 8: // 
    // N: ADC/IN, route from/bits in/logic - cyclepass on/XOR - ADCxbit 
    // L: route from/bits in/logic - cyclepass on/OR
    // C: DAC/OUT, route from/bits in/logic - cyclepass on/XOR - DACspacers
    // R: route from/bits in/logic  - cyclepass on/OR
    
  if (counter[w]>speed[w]){
    counter[w]=0; 
    // here we can set options
    dactype[2]=3; // spacerbit DAC out
    //    logtable[4]={0,1,0,1}; we set L and R to 1 which is OR
    logtable[0]=0; logtable[1]=3; logtable[2]=0; logtable[3]=3; // leaks
    
    Gshift_[w][0]=shift_[w]; 
    Gshift_[w][1]=shift_[w]; 
    Gshift_[w][2]=shift_[w];
    Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;
  
    //3-what is routing for incoming SR bits, cycling bit
    // we have default route here
    // BUT for LFSR in we have another route
    if (w==0){
      bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01;  
      Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      bitn^=ADC_(w,SRlength[w],1,0); // XOR with 1 bit audio
      bitn^=(shift_[w]>>SRlength[w])& 0x01; //cycling bit XOR in     
    }
    else
      {
    bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01; 
    Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;
    bitn^=(shift_[w]>>SRlength[w])& 0x01; //cycling bit XOR in     
      }

    //4-what is incoming pulsin bit if any? - incoming pulse will always be ORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn=logop(bitn,xx,logtable[w]); // just for bits in
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); 

    //7-pulses out if any
PULSEOUT;  }// counterw
  break; 
  
  case 9: // just for trials with other ADC/DAC options... 
    // N: ADC/IN, route from/bits in/logic - pass on/XOR - experiment with ADCs
    // L: route from/bits in/logic - pass on/OR
    // C: DAC/OUT, route from/bits in/logic - pass on/XOR - DACequiv
    // R: route from/bits in/logic  - pass on/OR

  if (counter[w]>speed[w]){
    counter[w]=0; 
    // here we can set options
    dactype[2]=7; 
    //    logtable[4]={0,1,0,1}; we set L and R to 1 which is OR - just for bits in
    logtable[0]=0; logtable[1]=0; logtable[2]=0; logtable[3]=0;
    
    Gshift_[w][0]=shift_[w]; 
    Gshift_[w][1]=shift_[w]; 
    Gshift_[w][2]=shift_[w];
    Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;
  
    //3-what is routing for incoming SR bits, cycling bit
    // we have default route here
    // BUT for LFSR in we have another route
    if (w==0){// w below can be zeroed...
      bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01;
      //      bitn=0;
      Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      //      bitn^=ADC_(w,SRlength[w],3,0); // XOR with: EQUIV BITS-TESTED!
      //      tmp=SRlength[w]>>1;
      //      bitn^=ADC_(0,SRlength[w],6,0); // param[0]
      //      bitn^=ADC_(0,SRlength[w],7,0); // comparator with param[0]
      //      bitn^=ADC_(0,SRlength[w],8,0);
      //      bitn^=ADC_(w,param[0],4,param[0]>>4);
      //      bitn^=ADC_(0,SRlength[w],10,trigger[0]); // strobe ADC in
      //      bitn^=ADC_(0,SRlength[w],12,3); // one bit DAC in //param is reg to get DAC from
      // int ADC_(uint32_t reg, uint32_t length, uint32_t type, uint32_t otherpar){ // here we use length as number of bits max is 12 bits
      // new adc strobe modes: 12,13,14,15,16
      bitn^=ADC_(0,SRlength[w],0,trigger[0]); // spaced bits in - 11 does not return bits though
    }
    else
      {
    bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01; 
    Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      }

    //4-what is incoming pulsin bit if any? - incoming pulse will always be ORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn=logop(bitn,xx,logtable[w]); // just for bits in
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],trigger[w]); // question is then if we want to use param other than trigger?

    //7-pulses out if any
    PULSEOUT;  }// counterw
  break; 

  /////////////////////////////////////////////////////////////////////
  
  case 10: // probability modes to explore here:
    //    1. if SR<CV  // int mode --- SR is customSR or RSR(routed SR)
    //    1. invert cycling bit or not, pulsbit is ORed in (TM)

    if (trigger[w]==1){ // we don't use intflag!
      dactype[2]=0; // basic DAC out

      Gshift_[w][0]=shift_[w]; 
      Gshift_[w][1]=shift_[w]; 
      Gshift_[w][2]=shift_[w];
      Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
      //2.5-shifting of which bits <<
      shift_[w]=shift_[w]<<1;
      bitn=(shift_[w]>>SRlength[w])& 0x01; //cycling bit
      if (pulsins[w]!=0) xx=!(GPIOC->IDR & pulsins[w]); 
      
      if ((LFSR_[w] & 4095 )<adc_buffer[lookupadc[w]]) { // 12 bits - which way round is this?
	// invert cycling bit only, no entry in, 
	bitn=bitn^1;
      }
      bitn|=xx;
      shift_[w]+=bitn;

    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); // TODO - add in DACtype.. basic DAC-0

    //7-pulses out if any
PULSEOUT;
    }
    break; 

  case 11: // probability modes to explore here:
    //    1. if SR<CV  // int mode --- SR is customSR or RSR(routed SR)
    //    1. invert routed-in-bit or not, pulsbit is ORed in (TM)

    if (trigger[w]==1){ // we don't use intflag!
      dactype[2]=0; // basic DAC out

      Gshift_[w][0]=shift_[w]; 
      Gshift_[w][1]=shift_[w]; 
      Gshift_[w][2]=shift_[w];
      Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
      //2.5-shifting of which bits <<
      shift_[w]=shift_[w]<<1;
      
      bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01; 
      Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      
      if (pulsins[w]!=0) xx=!(GPIOC->IDR & pulsins[w]); 
      
      if ((LFSR_[w] & 4095 )<adc_buffer[lookupadc[w]]) { // 12 bits - which way round is this?
	// invert cycling bit only, no entry in, 
	bitn=bitn^1;
      }
      bitn|=xx;
      shift_[w]+=bitn;

    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); // TODO - add in DACtype.. basic DAC-0

    //7-pulses out if any
PULSEOUT;
    }
    break; 

  case 12: // probability modes to explore here:
    //    1. if SR<CV  // int mode --- SR is customSR or RSR(routed SR)
    //    1. invert cycle+routed-in-bit or not, pulsbit is ORed in (TM)

    if (trigger[w]==1){ // we don't use intflag!
      dactype[2]=0; // basic DAC out

      Gshift_[w][0]=shift_[w]; 
      Gshift_[w][1]=shift_[w]; 
      Gshift_[w][2]=shift_[w];
      Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
      //2.5-shifting of which bits <<
      shift_[w]=shift_[w]<<1;
      
      bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01; 
      Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      bitn^=(shift_[w]>>SRlength[w])& 0x01; //cycling bit XOR in     
      
      if (pulsins[w]!=0) xx=!(GPIOC->IDR & pulsins[w]); 
      
      if ((LFSR_[w] & 4095 )<adc_buffer[lookupadc[w]]) { // 12 bits - which way round is this?
	// invert cycling bit only, no entry in, 
	bitn=bitn^1;
      }
      bitn|=xx;
      shift_[w]+=bitn;

    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); // TODO - add in DACtype.. basic DAC-0

    //7-pulses out if any
PULSEOUT;
    }
    break; 

  case 13: // probability modes to explore here:
    //    1. if SR<CV  // int mode --- SR is customSR or RSR(routed SR)
    //3. new input (from pulsbit) or cycling bit (wiard and EN)  - if we don't have pulsebit then route
    
    if (trigger[w]==1){ // we don't use intflag!
      dactype[2]=0; // basic DAC out

      Gshift_[w][0]=shift_[w]; 
      Gshift_[w][1]=shift_[w]; 
      Gshift_[w][2]=shift_[w];
      Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
      //2.5-shifting of which bits <<
      shift_[w]=shift_[w]<<1;
            
      
      if ((LFSR_[w] & 4095 )<adc_buffer[lookupadc[w]]) { // 12 bits - which way round is this?
      bitn=(shift_[w]>>SRlength[w])& 0x01; //cycling bit XOR in     
      }
      else
	{
	  if (pulsins[w]!=0) bitn=!(GPIOC->IDR & pulsins[w]); 
	  else { // if we don't use pulseins
	    bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01;  
	    Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
	  }	  	  
	}      
      shift_[w]+=bitn;

    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); // TODO - add in DACtype.. basic DAC-0

    //7-pulses out if any
PULSEOUT;
    }
    break; 

  case 14: // probability modes to explore here:
    //    1. if SR<CV  // int mode --- SR is customSR or RSR(routed SR)
    //4. new input (from route) or cycling bit - and OR in pulsebit if...    
    if (trigger[w]==1){ // we don't use intflag!
      dactype[2]=0; // basic DAC out

      Gshift_[w][0]=shift_[w]; 
      Gshift_[w][1]=shift_[w]; 
      Gshift_[w][2]=shift_[w];
      Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
      //2.5-shifting of which bits <<
      shift_[w]=shift_[w]<<1;
            
      
      if ((LFSR_[w] & 4095 )<adc_buffer[lookupadc[w]]) { // 12 bits - which way round is this?
      bitn=(shift_[w]>>SRlength[w])& 0x01; //cycling bit XOR in     
      }
      else{
	bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01;  
	Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
	}
    if (pulsins[w]!=0) xx=!(GPIOC->IDR & pulsins[w]); 

      shift_[w]+=bitn|xx;

    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); // TODO - add in DACtype.. basic DAC-0

    //7-pulses out if any
PULSEOUT;
    }
    break; 

  case 15: // probability modes to explore here:
    //    1. if SR<CV  // int mode --- SR is customSR or RSR(routed SR)
    //4. new input (from route/ADC) or cycling bit - and OR in pulsebit if...
    /// or in case of w==0 NSR we have ADC/LFSR in depending on type - but THIS is not extra to mode 14 as it will simply repeat those except for NSR
    // but now we change thi so is inverted routing bit
    if (trigger[w]==1){ // we don't use intflag!
      dactype[2]=0; // basic DAC out

      Gshift_[w][0]=shift_[w]; 
      Gshift_[w][1]=shift_[w]; 
      Gshift_[w][2]=shift_[w];
      Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
      //2.5-shifting of which bits <<
      shift_[w]=shift_[w]<<1;
            
      
      if ((LFSR_[w] & 4095 )<adc_buffer[lookupadc[w]]) { // 12 bits - which way round is this?
      bitn=(shift_[w]>>SRlength[w])& 0x01; //cycling bit XOR in     
      }
      else{
	if (w==0){
	  bitn=ADC_(w,SRlength[w],0,0); // 0 is bits in, 2 is LFSR
	}
	else
	  {
	bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01;  
	Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;
	bitn^=1;
	  }
	}
    if (pulsins[w]!=0) xx=!(GPIOC->IDR & pulsins[w]); 

      shift_[w]+=bitn|xx;

    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); // TODO - add in DACtype.. basic DAC-0

    //7-pulses out if any
PULSEOUT;
    }
    break; 

  case 16: // probability modes to explore here:
    //1. if SR<CV  // int mode --- SR is customSR or RSR(routed SR)
    //6. new input (from ADCtypeX) or route in     
    // how these match/repeat above when we don't have ADC ??? - maybe do inverted route bit in for others // with cycling bit
    
    if (trigger[w]==1){ // we don't use intflag!
      dactype[2]=0; // basic DAC out

      Gshift_[w][0]=shift_[w]; 
      Gshift_[w][1]=shift_[w]; 
      Gshift_[w][2]=shift_[w];
      Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
      //2.5-shifting of which bits <<
      shift_[w]=shift_[w]<<1;
            
      
      if ((LFSR_[w] & 4095 )<adc_buffer[lookupadc[w]]) { // 12 bits - which way round is this?
	bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01;  
	Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;
      }
      else{
	if (w==0){
	  bitn=ADC_(w,SRlength[w],0,0); // 0 is bits in, 2 is LFSR
	}
	else
	  {
	    bitn=(!(shift_[w]>>SRlength[w])) & 0x01; //
 	  }
	}
    if (pulsins[w]!=0) xx=!(GPIOC->IDR & pulsins[w]); 

      shift_[w]+=bitn|xx;

    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); // TODO - add in DACtype.. basic DAC-0

    //7-pulses out if any
PULSEOUT;
    }
    break; 

    //3. if SR<DAC+CV // int mode from 10-16 repeat with sr<adc+dac[2]
    
  case 17: // probability modes to explore here:
    //    1. if SR<CV  // int mode --- SR is customSR or RSR(routed SR)
    //    1. invert cycling bit or not, pulsbit is ORed in (TM)

    if (trigger[w]==1){ // we don't use intflag!
      dactype[2]=0; // basic DAC out

      Gshift_[w][0]=shift_[w]; 
      Gshift_[w][1]=shift_[w]; 
      Gshift_[w][2]=shift_[w];
      Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
      //2.5-shifting of which bits <<
      shift_[w]=shift_[w]<<1;
      bitn=(shift_[w]>>SRlength[w])& 0x01; //cycling bit
      if (pulsins[w]!=0) xx=!(GPIOC->IDR & pulsins[w]); 
      //      tmpt=((dacr>>2)-(1024-speedc)); // dacr is 12 bits, speedc is 10 bits
      tmpt=dac[dacroute[w]]-(4095-adc_buffer[lookupadc[w]]);
      if (tmpt<0) tmpt=0; // or just add them      
      if ((LFSR_[w] & 4095 )<tmpt) { // 12 bits - which way round is this? - we fix now on dac[2]
	// invert cycling bit only, no entry in, 
	bitn=bitn^1;
      }
      bitn|=xx;
      shift_[w]+=bitn;

    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); // TODO - add in DACtype.. basic DAC-0

    //7-pulses out if any
PULSEOUT;
    }
    break; 

    // FILL in adc+dac modes TODO::::
    
  case 18:
    //    LFSR<DAC
    // first for CV modes and prob - copy of 17 which is copy of 10
    //    1. if SR<CV  // int mode --- SR is customSR or RSR(routed SR)
    //    1. invert cycling bit or not, pulsbit is ORed in (TM)

  if (counter[w]>speed[w]){
    counter[w]=0; 

    dactype[2]=0; // basic DAC out

      Gshift_[w][0]=shift_[w]; 
      Gshift_[w][1]=shift_[w]; 
      Gshift_[w][2]=shift_[w];
      Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
      //2.5-shifting of which bits <<
      shift_[w]=shift_[w]<<1;
      bitn=(shift_[w]>>SRlength[w])& 0x01; //cycling bit
      if (pulsins[w]!=0) xx=!(GPIOC->IDR & pulsins[w]); 
      if ((LFSR_[w] & 4095 )<dac[dacroute[w]]) { // 12 bits - which way round is this? - we fix now on dac[2]
	// invert cycling bit only, no entry in, 
	bitn=bitn^1;
      }
      bitn|=xx;
      shift_[w]+=bitn;

    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); // TODO - add in DACtype.. basic DAC-0

    //7-pulses out if any
PULSEOUT;
    }
    break; 

    // fill in 10-17
    
  case 19:
    // first for CV modes and prob - copy of 17 which is copy of 10
    //    1. if SR<CV  // int mode --- SR is customSR or RSR(routed SR)
    //    1. invert cycling bit or not, pulsbit is ORed in (TM)

  if (counter[w]>speed[w]){
    counter[w]=0; 

    dactype[2]=0; // basic DAC out

      Gshift_[w][0]=shift_[w]; 
      Gshift_[w][1]=shift_[w]; 
      Gshift_[w][2]=shift_[w];
      Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
      //2.5-shifting of which bits <<
      shift_[w]=shift_[w]<<1;
      bitn=(shift_[w]>>SRlength[w])& 0x01; //cycling bit
      if (pulsins[w]!=0) xx=!(GPIOC->IDR & pulsins[w]); 
      if ((LFSR_[w] & 4095 )<param[w]) { // 12 bits - which way round is this? - we fix now on dac[2]
	// invert cycling bit only, no entry in, 
	bitn=bitn^1;
      }
      bitn|=xx;
      shift_[w]+=bitn;

    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); // TODO - add in DACtype.. basic DAC-0

    //7-pulses out if any
PULSEOUT;
    }
    break; 
    
    // fill in 10-17

  case 20: //as case 3 but for INT modes and with test ADC 11 mode in! CV as comparator
    // N: ADC/IN, route from/bits in/logic - pass on/XOR - LFSR 
    // L: route from/bits in/logic - pass on/OR
    // C: DAC/OUT, route from/bits in/logic - pass on/XOR - DACequiv
    // R: route from/bits in/logic  - pass on/OR

    
    //  if (counter[w]>speed[w]){
    //    counter[w]=0; 
    // here we can set options
    if (trigger[w]==1){ // we don't use intflag!
	  
    dactype[2]=0; // equiv DAC out, others are fixed as basic
    //    logtable[4]={0,1,0,1}; we set L and R to 1 which is OR
    logtable[0]=0; logtable[1]=1; logtable[2]=0; logtable[3]=1;
    
    Gshift_[w][0]=shift_[w]; 
    Gshift_[w][1]=shift_[w]; 
    Gshift_[w][2]=shift_[w];
    Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;
  
    //3-what is routing for incoming SR bits, cycling bit
    // we have default route here
    // BUT for LFSR in we have another route
    if (w==0){
      bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01;  
      Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      bitn^=ADC_(w,SRlength[w],11,0); // XOR with LFSR
    }
    else
      {
    bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01; 
    Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      }

    //4-what is incoming pulsin bit if any? - incoming pulse will always be ORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn=logop(bitn,xx,logtable[w]); // just for bits in
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); 

    //7-pulses out if any
PULSEOUT;  }// counterw
  break; 

  case 21: // triadex inspired mode where we XOR in bits from the other SRs
    // but which bits and do we use static SR or shift ghostSRs round...
    // try ghosted SRs...
    if (counter[w]>speed[w]){
    dactype[2]=0; // basic DAC out, others are fixed as basic

    counter[w]=0; 
    Gshift_[w][0]=shift_[w]; 
    Gshift_[w][1]=shift_[w]; 
    Gshift_[w][2]=shift_[w];
    Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;
  
    //3-what is routing for incoming SR bits, cycling bit
    // we have default route here
    bitn = (Gshift_[others[w][0]][w]>>SRlength[others[w][0]]) & 0x01; 
    Gshift_[others[w][0]][w]=(Gshift_[others[w][0]][w]<<1)+bitn;

    bitnn = (Gshift_[others[w][1]][w]>>SRlength[others[w][1]]) & 0x01; 
    Gshift_[others[w][1]][w]=(Gshift_[others[w][1]][w]<<1)+bitnn;

    bitnnn = (Gshift_[others[w][2]][w]>>SRlength[others[w][2]]) & 0x01; 
    Gshift_[others[w][2]][w]=(Gshift_[others[w][2]][w]<<1)+bitnnn;

    bitn^=((shift_[w]>>SRlength[w])& 0x01)^bitnn^bitnnn; 

    //4-what is incoming pulsin bit if any? - incoming pulse will always be XORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn^=xx;
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); // TODO - add in DACtype.. basic DAC-0

    //7-pulses out if any
PULSEOUT;  }// counterw
  break; 

  case 22: // triadex inspired mode where we XOR in bits from the other SRs
    // but which bits and do we use static SR or shift ghostSRs round...
    // this one with static SR!
    if (counter[w]>speed[w]){
    dactype[2]=0; // basic DAC out, others are fixed as basic

    counter[w]=0; 
    Gshift_[w][0]=shift_[w]; 
    Gshift_[w][1]=shift_[w]; 
    Gshift_[w][2]=shift_[w];
    Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;
  
    bitn = (shift_[others[w][0]]>>SRlength[others[w][0]]) & 0x01; 
    bitnn = (shift_[others[w][1]]>>SRlength[others[w][1]]) & 0x01; 
    bitnnn = (shift_[others[w][2]]>>SRlength[others[w][2]]) & 0x01; 

    bitn^=((shift_[w]>>SRlength[w])& 0x01)^bitnn^bitnnn; 

    //4-what is incoming pulsin bit if any? - incoming pulse will always be XORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn^=xx;
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); // TODO - add in DACtype.. basic DAC-0

    //7-pulses out if any
PULSEOUT;  }// counterw
  break; 

  case 23: // pass on but trigger bumps on default route
    // can also be multiple routes in/change to binary routing table
    
    if (counter[w]>speed[w]){
    dactype[2]=0; // basic DAC out, others are fixed as basic

    if (trigger[w]){
      ourroute[w]++;
      if (ourroute[w]>3) ourroute[w]=0;
    }
    
    counter[w]=0; 
    Gshift_[w][0]=shift_[w]; 
    Gshift_[w][1]=shift_[w]; 
    Gshift_[w][2]=shift_[w];
    Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;
  
    //3-what is routing for incoming SR bits, cycling bit
    bitn = (Gshift_[ourroute[w]][w]>>SRlength[ourroute[w]]) & 0x01; 
    Gshift_[ourroute[w]][w]=(Gshift_[ourroute[w]][w]<<1)+bitn;  
    //    bitn=bitn^bitrr; // just XOR now for this mode

    //4-what is incoming pulsin bit if any? - incoming pulse will always be XORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn^=xx;
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); // TODO - add in DACtype.. basic DAC-0

    //7-pulses out if any
PULSEOUT;  }// counterw
  break; 

  case 24: // can also be multiple routes in/change to binary routing table
    // first implementation of multiple routing table
        if (counter[w]>speed[w]){
    dactype[2]=0; // basic DAC out, others are fixed as basic

    if (trigger[w]){ // bump up binary routing table which is route[]
      route[w]++;
      if (route[w]>15) route[w]=0; // 15 is all routes, 8,4,2,1
    }
    
    counter[w]=0; 
    Gshift_[w][0]=shift_[w]; 
    Gshift_[w][1]=shift_[w]; 
    Gshift_[w][2]=shift_[w];
    Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;

    // work with the binary routing table
    bitn=0;
    tmp=route[w]; // route can also be another SR!
    // if route to ourself then is cycling bit but we still need to cycle <<1 above!
    for (x=0;x<4;x++){ //unroll?
      if (tmp&0x01){  
	bitrr = (Gshift_[x][w]>>SRlength[x]) & 0x01; // or other logical opp for multiple bits/accum
	Gshift_[x][w]=(Gshift_[x][w]<<1)+bitrr;  // we had x and w wrong way round - x is ghost SR number, w is our own copy for this SR
	bitn^=bitrr;//logop(bitn,bitrr,logopp[w]); // but what if we want different logical opps for each?
    }
    tmp=tmp>>1;
    }
    
    //4-what is incoming pulsin bit if any? - incoming pulse will always be XORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn^=xx;
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); // TODO - add in DACtype.. basic DAC-0

    //7-pulses out if any
PULSEOUT;  }// counterw
  break; 

  case 25: // can also be multiple routes in/change to binary routing table
    // implementation of multiple routing table
    // this is an INT mode with CV as the routing table
    // table is 4 bits but we can have DAC selection on extra 2 bits for all SRs
    // how this works with ADC in or we don't route that one - default route in...
    // and use bits to select types there... TRY THIS

    if (trigger[w]==1){ // we don't use intflag!

      tmpp=adc_buffer[lookupadc[w]]>>6; // this can also be RSR DAC! 12 bits down to 6 bits
      
      //      dactype[2]=(tmpp>>10)&3; // upper 2 bits but we do this below

      Gshift_[w][0]=shift_[w]; 
      Gshift_[w][1]=shift_[w]; 
      Gshift_[w][2]=shift_[w];
      Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;

    // work with the binary routing table - but 0 is a route from nowhere...
    bitn=0;
    tmp=tmpp&15; // bottom 4 bits 
    for (x=0;x<4;x++){ //unroll?
      if (tmp&0x01){  
	bitrr = (Gshift_[x][w]>>SRlength[x]) & 0x01; // or other logical opp for multiple bits/accum
	Gshift_[x][w]=(Gshift_[x][w]<<1)+bitrr;  // we had x and w wrong way round - x is ghost SR number, w is our own copy for this SR
	bitn^=bitrr;//logop(bitn,bitrr,logopp[w]); // but what if we want different logical opps for each?
    }
    tmp=tmp>>1;
    }

    //4-what is incoming pulsin bit if any? - incoming pulse will always be XORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn^=xx;
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], (tmpp>>4)&3,0); // all DACTypes changed here - top bits

    //7-pulses out if any
PULSEOUT;  }// counterw
  break; 

  case 26: // multiple routes in/change to binary routing table
    // implementation of multiple routing table - CV mode with dacrouted dac as source for table...

    if (counter[w]>speed[w]){
      //      tmpp=adc_buffer[lookupadc[w]]>>6; // this can also be RSR DAC! 12 bits down to 6 bits
      tmpp=dac[dacroute[w]]>>6;
      //      dactype[2]=(tmpp>>10)&3; // upper 2 bits but we do this below

      Gshift_[w][0]=shift_[w]; 
      Gshift_[w][1]=shift_[w]; 
      Gshift_[w][2]=shift_[w];
      Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;

    // work with the binary routing table - but 0 is a route from nowhere...
    bitn=0;
    tmp=tmpp&15; // bottom 4 bits 
    for (x=0;x<4;x++){ //unroll?
      if (tmp&0x01){  
	bitrr = (Gshift_[x][w]>>SRlength[x]) & 0x01; // or other logical opp for multiple bits/accum
	Gshift_[x][w]=(Gshift_[x][w]<<1)+bitrr;  // we had x and w wrong way round - x is ghost SR number, w is our own copy for this SR
	bitn^=bitrr;//logop(bitn,bitrr,logopp[w]); // but what if we want different logical opps for each?
    }
    tmp=tmp>>1;
    }
    
    //4-what is incoming pulsin bit if any? - incoming pulse will always be XORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn^=xx;
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], (tmpp>>4)&3,0); // all DACTypes changed here - two bits

    //7-pulses out if any
    PULSEOUT;
    }// counterw
  break; 

  case 27:     // w==0 4 bit adc entry on adc_ mode 13
    // we need to cycle in at spac points from routed one...
    
    if (counter[w]>speed[w]){
    dactype[2]=6; // others are fixed as basic - but should be 4 bits spaced dac out = 5/6 6 for equiv bits

    counter[w]=0; 
    Gshift_[w][0]=shift_[w]; 
    Gshift_[w][1]=shift_[w]; 
    Gshift_[w][2]=shift_[w];
    Gshift_[w][3]=shift_[w]; 
      
    shift_[w]=shift_[w]<<1;

    if (w==0){ // do our adc 4 bits in mode 13
      ADC_(0,SRlength[0],13,0); // pulls in bits 
    }
    else
      { // we need to extract the advanced bits from the last one
	// shift_registerl += (((shift_registern&(1<<7))>>7) + ((shift_registern&(1<<15))>>7) + ((shift_registern&(1<<23))>>7) + ((shift_registern&(1<<31))>>7));
	shift_[w]&=spacmask[SRlength[w]]; //cleared
	
	if (SRlength[defroute[w]]>=SRlength[w]){ // need to >> 
	  //	  tmp=(SRlength[defroute[w]]>>2)-(SRlength[w]>>2); // /4
	  shift_[w]+=(((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][0])) >>(lastspac[SRlength[defroute[w]]][0]))+ \
		      ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][1]))          >> ((lastspac[SRlength[defroute[w]]][1]) - spacc[SRlength[w]][0]))  + \
		      ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][2]))         >>((lastspac[SRlength[defroute[w]]][2]) - spacc[SRlength[w]][1]))  + \
		      ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][3]))         >>((lastspac[SRlength[defroute[w]]][3]) - spacc[SRlength[w]][2]))); 
	  }
	  else // shift up <<
	    {
	      shift_[w]+=(((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][0]))>>(lastspac[SRlength[defroute[w]]][0])) + \
			  ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][1]))<< ((spacc[SRlength[w]][0]) - lastspac[SRlength[defroute[w]]][1]))  + \
			   ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][2]))<< ((spacc[SRlength[w]][1]) - lastspac[SRlength[defroute[w]]][2]))  + \
			  ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][3]))<< ((spacc[SRlength[w]][2]) - lastspac[SRlength[defroute[w]]][3])));
	    }

	if (pulsins[w]!=0){
	  xx=!(GPIOC->IDR & pulsins[w]); 
	  shift_[w]^=xx;
	}
    
      }
    bitn=shift_[w]&1;
    
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); 
    PULSEOUT;
    }
  break; 

  case 28:     // w==0 4 bit adc entry on adc_ mode 13 - pass on 4 bits - this one with feedback into ADC/NSR 0
    
    if (counter[w]>speed[w]){
    dactype[2]=6; // others are fixed as basic - but should be 4 bits spaced dac out = 5/6 6 for equiv bits

    counter[w]=0; 
    Gshift_[w][0]=shift_[w]; 
    Gshift_[w][1]=shift_[w]; 
    Gshift_[w][2]=shift_[w];
    Gshift_[w][3]=shift_[w]; 
      
    shift_[w]=shift_[w]<<1;

    if (w==0){ // do our adc 4 bits in mode 13
      ADC_(0,SRlength[0],13,0); // pulls in bits 
      // we want to xor bits back in;;
	if (SRlength[defroute[w]]>=SRlength[w]){ // need to >> 
	  //	  tmp=(SRlength[defroute[w]]>>2)-(SRlength[w]>>2); // /4
	  shift_[w]^=(((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][0])) >>(lastspac[SRlength[defroute[w]]][0]))+ \
		      ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][1]))          >> ((lastspac[SRlength[defroute[w]]][1]) - spacc[SRlength[w]][0]))  + \
		      ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][2]))         >>((lastspac[SRlength[defroute[w]]][2]) - spacc[SRlength[w]][1]))  + \
		      ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][3]))         >>((lastspac[SRlength[defroute[w]]][3]) - spacc[SRlength[w]][2]))); 
	  }
	  else // shift up <<
	    {
	      shift_[w]^=(((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][0]))>>(lastspac[SRlength[defroute[w]]][0])) + \
			  ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][1]))<< ((spacc[SRlength[w]][0]) - lastspac[SRlength[defroute[w]]][1]))  + \
			   ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][2]))<< ((spacc[SRlength[w]][1]) - lastspac[SRlength[defroute[w]]][2]))  + \
			  ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][3]))<< ((spacc[SRlength[w]][2]) - lastspac[SRlength[defroute[w]]][3])));
	    }

    }
    else
      { // we need to extract the advanced bits from the last one
	// shift_registerl += (((shift_registern&(1<<7))>>7) + ((shift_registern&(1<<15))>>7) + ((shift_registern&(1<<23))>>7) + ((shift_registern&(1<<31))>>7));
	shift_[w]&=spacmask[SRlength[w]]; //cleared
	
	if (SRlength[defroute[w]]>=SRlength[w]){ // need to >> 
	  //	  tmp=(SRlength[defroute[w]]>>2)-(SRlength[w]>>2); // /4
	  shift_[w]+=(((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][0])) >>(lastspac[SRlength[defroute[w]]][0]))+ \
		      ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][1]))          >> ((lastspac[SRlength[defroute[w]]][1]) - spacc[SRlength[w]][0]))  + \
		      ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][2]))         >>((lastspac[SRlength[defroute[w]]][2]) - spacc[SRlength[w]][1]))  + \
		      ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][3]))         >>((lastspac[SRlength[defroute[w]]][3]) - spacc[SRlength[w]][2]))); 
	  }
	  else // shift up <<
	    {
	      shift_[w]+=(((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][0]))>>(lastspac[SRlength[defroute[w]]][0])) + \
			  ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][1]))<< ((spacc[SRlength[w]][0]) - lastspac[SRlength[defroute[w]]][1]))  + \
			   ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][2]))<< ((spacc[SRlength[w]][1]) - lastspac[SRlength[defroute[w]]][2]))  + \
			  ((shift_[defroute[w]]&(1<<lastspac[SRlength[defroute[w]]][3]))<< ((spacc[SRlength[w]][2]) - lastspac[SRlength[defroute[w]]][3])));
	    }

	if (pulsins[w]!=0){
	  xx=!(GPIOC->IDR & pulsins[w]); 
	  shift_[w]^=xx;
	}	
    }
    bitn=shift_[0]&1;
    
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); 
    PULSEOUT;

    }
  break; 
  

  // INT MODES!
  
  
  
       
    /// extra experimental cases // tested
  /////////////////////////////////////////////////////////////////////////
  case 104:  // let's try INT driven one for pulse train mode
  // INT triggers train of CV pulses at speed DAC - and can also be vice versa
    // INT can also start new train or let old one carry on (now it starts new train...)
    if (trigger[w]==1){ 
      train[w]=1; // we can use train as counter      
    }
    if (train[w]!=0 && train[w]<(speed[w]+1)){ // number of pulses
      // do train so first we need speed counter
      if (counter[w]>dac[dacroute[w]]){ // or another dac
	train[w]++;
	// from DACR now but can be dacfrom!
	counter[w]=0;
	// now we can do any kind of SR, but guess makes sense for NSR to be LFSR or so???
	// so we borrow some from mode 3
	dactype[2]=0; // basic DAC out
	//    logtable[4]={0,1,0,1}; we set L and R to 1 which is OR
	//    logtable[0]=0; logtable[1]=1; logtable[2]=0; logtable[3]=1;
    
    Gshift_[w][0]=shift_[w]; 
    Gshift_[w][1]=shift_[w]; 
    Gshift_[w][2]=shift_[w];
    Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;
  
    //3-what is routing for incoming SR bits, cycling bit
    // we have default route here
    // BUT for LFSR in we have another route
    if (w==0){
      bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01;  
      Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      bitn^=ADC_(w,SRlength[w],2,0); // XOR with LFSR
    }
    else
      {
    bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01; 
    Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      }

    //4-what is incoming pulsin bit if any? - incoming pulse will always be ORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn=bitn^xx;
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); 

    //7-pulses out if any
    PULSEOUT;    
      }
    }
    else train[w]=0; // train ran out
    
    break;
    ///////////
  case 105:// this is the vice versa of the above
    // let's try INT driven one for pulse train mode
  // INT triggers train of CV pulses at speed DAC - and can also be vice versa
    // INT can also start new train or let old one carry on (now it starts new train...)
    if (trigger[w]==1){ 
      train[w]=1; // we can use train as counter      
    }
    if (train[w]!=0 && train[w]<dac[3]){ // number of pulses
      // do train so first we need speed counter
      if (counter[w]>speed[w]){ // or another dac
	train[w]++;
	// from DACR now but can be dacfrom!
	counter[w]=0;
	// now we can do any kind of SR, but guess makes sense for NSR to be LFSR or so???
	// so we borrow some from mode 3
	dactype[2]=0; // basic DAC out
	//    logtable[4]={0,1,0,1}; we set L and R to 1 which is OR
	//    logtable[0]=0; logtable[1]=1; logtable[2]=0; logtable[3]=1;
    
    Gshift_[w][0]=shift_[w]; 
    Gshift_[w][1]=shift_[w]; 
    Gshift_[w][2]=shift_[w];
    Gshift_[w][3]=shift_[w]; // ghosts for l,c,r only but let's keep one spare
      
    //2.5-shifting of which bits <<
    shift_[w]=shift_[w]<<1;
  
    //3-what is routing for incoming SR bits, cycling bit
    // we have default route here
    // BUT for LFSR in we have another route
    if (w==0){
      bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01;  
      Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      bitn^=ADC_(w,SRlength[w],2,0); // XOR with lFSR
    }
    else
      {
    bitn = (Gshift_[defroute[w]][w]>>SRlength[defroute[w]]) & 0x01; 
    Gshift_[defroute[w]][w]=(Gshift_[defroute[w]][w]<<1)+bitn;  
      }

    //4-what is incoming pulsin bit if any? - incoming pulse will always be ORed in
    if (pulsins[w]!=0){
    xx=!(GPIOC->IDR & pulsins[w]); 
    bitn=bitn^xx;
    }
    
    shift_[w]+=bitn;
    
    //6-DAC result for any purposes - do we output in main loop?
    dac[w]=DAC_(w, SRlength[w], dactype[w],0); 

    //7-pulses out if any
    PULSEOUT;    
      }
    }
    else train[w]=0; // train ran out
    
    break;


    /////////////////////////////////////////////////////////////////////////     /////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////// 
    // what other simple modes can be: to list:

    //2-pass and cycle with other logics in L and R, other options PLUS-ADC in options, LFSR for NSR, different DACs out for CSR
  // so L and R have other logics and we go thru DAC and ADC options with simple pass through say
  // see how many modes we can manage then...
  
    // ????eg. cycle with adc, cycle with lfsr, pass with adc, pass with lfsr, pass and cycle with adc, pass and cycle with lfsr    (only for top)

    ///////////////////////////////////////////////////////////////////////// 
  } // switch
  //    } //4x

      // DAC output 
      // for the moment we just output from dac[2] ->[0,1,2C,3]=2 is C
  //  set whichever DAC if there is a special, over-riding mode
      DAC_SetChannel1Data(DAC_Align_12b_R, dac[2]); // 1000/4096 * 3V3 == 0V8 
      int j = DAC_GetDataOutputValue (DAC_Channel_1); // DACout is inverting  

      // and fake CLKs TODO - top NSR is from R/3
      // DAC for normed NSR/PWM 
      tmp= dac[3]; // right hand
      tmp+=320; 
      TIM1->ARR =tmp; // what range this should be? - connect to SRlengthc
      TIM1->CCR1 = tmp/2; // pulse width

      //TODO
      // fake CLKINs for L,R,C are from Cspeed==2 - this needs to be in speeds then but...
      /*
      flipper^=1;
      if (flipper) GPIOB->BSRRH = clk_route[clkr];  // clear bits of fake_one - clkr is 7 so all of them
      // or we can set L and R from an independent SR with only CSR as clocked from here
      else   GPIOB->BSRRL=clk_route[clkr]; //  write bits       
      */

 }
