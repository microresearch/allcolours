* how to sort and classify/generic ideas sept 2021

thinking about multiple routing for DAC, clock DAC an ADC??? how this might work as gives flexibility for timings

or we have anyways routings which are flexible so maybe is ok. just that DAC out clock/speed effects feedback etc...

////

TODO from below:

- set up clockins for basic pass/recirculate SRs and test with norm of CSR DAC to top TIM1 NSR pulse
- test use of manipulated routing tables for one SR
- trial RSR as random register with various routings for simulation of electronotes and TM.
- in test2.c compare generic shiftings with coggs version (and also if we still need to do <<1 if routes to itself?)

- ghostSR in ghostSR in test2.c to trial//also various crossings of delayed ghosts with "real" SRs

from test2.c
// own routing means we have the shifted out bit already (route to self) - but we still need to shift

// we could also lag the ghost so is like a delayed revenant
// so example it only shifts itself if there is a pulse bit

////////////////further

// and cycling/circling array of ghosts which can come back or go forwards/backwards - when these ghosts are copied over (on event)
// with 256 cycles/copies - or we can have variable length of this shifting array

we can also determine cycle we use using another SR

** xxxxx

proof of concept generic routing in test2.c

default or not: CSR DAC out->top PWM/TIM1 which is normed to clock pulse for NSR

*[we need to trial if this makes sense with routing]*

// what bits make sense for SR definition to be changed by other processes?

eg. input types are fixed or not, routing yes

so we have several bit modes for different main SR types...

for example bits determining type and routing = 7 bits

- that we can choose (eg. RSR) to be specific controller or
  determining SR (eg. for random operations we refer to this one
  eg. for TM and electronotes determinings - to test this)

- routing bits (routing table as one SR?) - or routing bits flipped/changed by other SR, incoming pulses...

- generic: new inputs or not, or logiced with - returning bit or not or logic op (inv), parity settings

equals:

generic parity settings in array (0 for no feedback or tag array with meta-array for type of logical operation, or where it comes from)

trial bits:

pulse/cv speed, input ADC/LFSR, output DAC/else?, type SR, type SR, type SR(3 bits of types=8), routing from (4 options)  

1               1               1                 1        1        1                           1 1 1 1 - 4 bits just to make it easier but could be less

is already 8 bits which would be 255 modes!!! we have limit of 64 modes

+ additonal bits: advance on cogg, logical opps, type of ADC, type of DAC, OR of LFSR/ADC 

// and we just leave outpulses as generic/divide down on 2nd set

unless we have other ways of thinking of modes... (mode as itself shift_register, pulses as incrementing modes or is that all too complicated)



*thinking to have special modes - at end of mode dial which implement this kind of thinking: even 3 or 4 last turns which inc bits*

** how to make modes more generic/independent whilst keeping routing options and open-ness?*

- feedback thru RSR makes more sense for ADC in modes and less for LFSR so maybe this decides routing?

- *what if each of the 4 SRs is totally generic* (in/out can be from
  anywhere, routing is unfixed and modifiable in runtime,
  self-modifying) - so there could be multiple ins, mixed outs
  (busses)... how to test this as proof of concept?

- that NSR and CSR can be input and output buses

- what this means for eg. notion of coggs and dependencies on other
  SRs, digital style filters etc. maybe make small test - but problem is to have too many SRs types

but also means we can have routings maybe switchable from pulses or from CV

eg. switch routing on certain conditions...

*or can mix of generic and otherwise work - as long as all are independent and share any necessary information. eg. new cogg/reset function*

as in we can mix use of arrays of (pointers)/srs and shiftregs with names which point to these...

** generic SR classifications to work on:

-routing
-what drives it on: pulses, bits/otherSR, values=speed // values from CV, values from DACs/SRs
-looping/input bits
-output bits
-question of overlap/coggs/SR

or:

-what drives it on: pulses, bits/otherSR, values=speed
-returning bits (eg. LFSR, no bits=pass_through)
-overlap (eg. LFSR in overlap, size of overlap)
-incoming bits - this is routing also and pulses in/ADC, and what is done to them (eg. flip them)
-output bits/DAC

or: shift x bits, length, entry new bits

and ADCpulsesDAC are attached in to this (as NSR, CSR)

** another attempt from notebook

1. basic division speed/pulse ->32 modes
2. output/input ADC/DAC/LFSR/others
3. type of SR-parallel/Turing.etc., logical opp (XOR,OR,AND, leaky)
4. what are incoming bits
5. outgoing bits

** code basis from test2.c

uint32_t *shift_[4], *Gshift_[4][4], coggs[4][4]; // gshift is 4 even though we don't use one

b=0; g=2; // n=0,l=1,c=2,r=3 // so feedback here is from c 
bitn = ((*shift_[b] >> (lfsr_taps[SRlength[b]][0])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][1])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][2])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][3]))) & 1u; // 32 is 31, 29, 25, 24
// need to catch it
if (*shift_[b]==0)     *shift_[b]=0xff;
// copy now to ghost
//we need multiple ghosts for each possible shifter: eg. Gshift_rl, Gshift_rn, Gshift_rc (right ones for left, for n and for c)
*Gshift_[b][0]=*shift_[b]; 
*Gshift_[b][1]=*shift_[b]; 
*Gshift_[b][2]=*shift_[b];
*Gshift_[b][3]=*shift_[b]; // ghosts for l,c,r only but let's keep one spare
// what else it needs to know - for each queued SR we need one cogg=0 for reset as we reset each on reading
cogg[b][0]=0;
cogg[b][1]=0;
cogg[b][2]=0;
cogg[b][3]=0;
  
*shift_[b]=*shift_[b]<<1; // we are shifting left << so bit 31 is out last one

bitr=(*Gshift_[g][b]>>SRlength[b]) & 0x01;
*Gshift_[g][b]=(*Gshift_[g][b]<<1)+bitr; 

*shift_[b]+= bitn;// & bitr;// ^ (!(GPIOC->IDR & 0x0010)); // or goes to 1s, xor is risky, AND works... and clockbit PC4

//also we can make bit access (eg. GPIOC->IDR & 0x0010 - can we access register as pointer TEST???, counters speed etc. all arrays 0,1,2,3

** classify AC SR modes (did we attempt that there?)

in separate file

note that some modes deal with types of pulses out

* general //16/7/2021+

- AC has 64 modes so 64x64x64x64=16 million combinations
- speed CV to use in trigger mode (eg. length of overlap)
- divide into speedCV, trigger/pulse - so that makes 32 modes doubled up (what of SR effecting own/other speeds)

maybe with/without coggs as further option becomes 16 modes

NO freeze: freezing is not so interesting as just locks and gives continuous tone...

*[note for SEG - electronotes wheel thing is passing down of bits so this could also be probability based (based on CV)!]*

/// LOTS TO RESOLVE:

*questions to resolve: routing and feedback, coggs and/or micro-registers, in or out number of bits vs. length of register* 

/////

- *thinking also that coggs are a bit like small shift registers* -
  what could be done with these - rotating/looping SRs handle
  feedthrough of registers TODO! - also that this is more like overlap
  we had in mind - this seems to work

//////

- also odd patterns just realized unless we constrain lengths to odd numbers (which is even lengths) *TEST this - improves but maybe keep odd option//NO!
- reverted to older code 2/9 as if we constrain this favours 101010etc regular outcomes

- at high speeds timing of SR influences other timings

- kind of bug in all lfsr code (28/8/2021) as was passing on bitn
  which was LFSR feedback bit - still was interesting and keep for
  some modes or use that bitn for timing etc...

- also question as CSR is out but speed there determines speed of
  feedback so we should really have different paths:

as we have it is NSR->LSR->CSR->RSR->NSR

eg. NSR->LSR->CSR
            ->RSR->NSR

*NSR->LSR->CSR* // *could be default routing but then we need to see about use of SRlengthc but length is important if we re-circulate???*
*///->RSR->NSR*

NSR->LSR->CSR  ->NSR/or not
   ->RSR->CSR  ->NSR

others: NSR->CSR->LSR ->NSR
                ->RSR ->NSR

need to figure out how to select these from modes - see below

routing can be array of shiftregs

///what does it mean to have multiple routes -> route is only known to incoming SR which updates ghostSR which belongs to itself (so it can have all 4)

so routing table for each incoming SR would be 4 bits 1 1 1 1 N,L,C,R - excluding itself (try version which includes itself and doesn't shift)

*ghost shift registers (GSR) within GSRs - if itself is treated as a ghost revenanting/coming into itself*

//////

- do we always want same flow NSR->LSR->CSR->RSR->backtoNSR (at least
  do we always want feedback to NSR but then if not RSR would be
  redundant)... Q is how to signal different routing across independent modes:

if (routex==1) do this... // or pointers to entries - but we don;t really need pointers

*so we can list routings but how are these selected - by the top mode maybe?*

/////

- see also AC modes.org!
- parallel bits input modes - eg. all x ADC bits are thrown into top or other SR

- speed can go to zero! signal this in array somehows... and speeds should be slower at one end

timing from speed-cv, pulse in, top reg(but no bits in), pulse AND
speedcv (divide, multiply, expect), pulse AND/OR/XOR top (again no
bits), from ghost registers (which can also be themselves clocked by
top register and then we can use bits in or?), timing also from SR->DAC


- question of range of speed - from slow CV (Hz?) to KHz for sigma/delta

- how we prevent running down to zero for SR on length change (trap this?)

variable stopping bits/zeroes

- left hand path/ right hand path: tree of life, kenneth grant and overlays for ...?

- how we deal with overlaps? some test code already but need to think through, could connect to length?

- *use other SR bits to determine length of other SR* then free up length cv for something else? 

also pulse clock or cv advances number/x once eg for cycling ghost sr
or length of ghost sr, or we can have smaller degrees of that advance,
say 1/10 so is not such a big jump

- how clock pulses can be changed for speed - xor with other parts of
  SR, with returning bits (experiment with these timings), with speed bits????

- how to notate SR - black and white, left and right, that a ghost SR
  could decide how to route bits to left or right (but we use right
  for feedback but could still be interesting - general idea of
  routing bits eg ADC to one side, LFSR to other)

- *test with/withouts coggs running - how this works - seems to work so how to deal with this option in modes*

- for overlap: what comes out is only one bit (of course there could be pulses from earlier bits)
  try overlap with multiple << shift (same as or differing from overlap size)
  returning bits

- overlap also in sense that both overlap (XOR etc top and bottom overlapped SRs), what other kinds of overlap?

- how else to use our new multiple shift code?

- what we do with both clock and pulse in bits in CV mode and how we
  norm these bits (NSR clock is normed to TIM1 pwm which we will use
  speedCV/or DAC out as control for) - otherwise we have pulseouts normed to all other pulse/clock ins

[but none of these will advance so maybe sync all to this clock which frees up their own speedCVs]

- experimental modes for LSR, RSR and CSR only advance with cogg=0 from previous (maybe logic op with bit)???

* NSR, LSR, RSR, CSR

** NSR - top register - ADC in, CLKIN only, no pulse outs:

mode 0 is straight LFSR (or with ADC or)

- 1-LFSRnoise/2-ADC in/3-mix of LFSR and ADC //4-comparator? -to-LSR/or/RSR or both (do we decide that here *BUT* RSR is now designated as feedback)

[so that gives us 8 or so modes for each one - or 4 with new coggs setup]

+ comparator function for ADC ins (can we also use this for LFSR -
  ways that we can combine bits from that?) - comp only works when we
  have no speedCV/pulsein only - or we can have 

- feedback of analogue output - eg. comparator using analogue out

- types of ADC (x bits, simple uncombined bits as in digfiltersim, equivalent bits), length in bits, delayed/stored bits

- pulse in/or speedCV and what CV does when pulse in/vice versa! (eg. number of bits, LFSR length if we have as extra)

- can also be clocked by CSR and/or ghosted noise SR 

- *look at AC SRs and see what can be adapted for ADC as incoming bits and cycling bit or RSR return bit (or combinations of these)*

- can be set of parallel SRs which feed into CSR, or just x bits from ADC go straight into CSR

- ADC with LFSR options: that we OR/XOR each incoming ADC bit with
  LFSR generated bit (from ghost LFSR), cases for parallel ADCs, that
  we weight incoming LFSR bits, that we use LFSR as DAC to
  add/subtract from ADC in, that we bulk XOR or just one bit per x
  incoming ADC bits, comparator of incoming DAC against LFSR/DAC

- number of bits in/out by CV or pulse counter(which wraps around)

- what to do if bits in/out is greater than length (options: put in anyways and lose top/bottom bits - shift if necessary // stop at length)

** LSR/RSR - regular shift register modes borrow from AC - CLKIN and PULSIN, 2 pulse outs/bits or flipflops: 

mode 0: feedthrough only - straight shift through with no return

LSR has entry from NSR and feeds into CSR
RSR has entry from CSR and feeds into NSR (so is the feedback register)

*but now we look into different paths!*

dark/light sides, left and right hand paths, mirrors (moon and sun), tree of life (Kenneth Grant - Nightside of Eden)

Question of how we work with entry of pulse ins: as togglers, pausers also, as extra
bits (but do we always have NSR entering in, maybe AND with extra bits
or other logic ops)

List leaky/decay possibilities...

- *look at AC SRs and see what can be adapted for NSR/CSR as incoming bits and cycling bit or pulse in bit (or combinations of these)*

- how we handle entry and overlap from NSR or CSR (logical ops, length of overlap)

- can also be clocked by bits from the NSR top register - but in this case we can't input bits from NSR as these will just be 1s!
 
- regular AC/SR modes

- just one way shift/delay - in one end, out the other (with/without bit degradation)

- looping SR with/without degradation

- leaking/decaying of bits, other logic feedbacks 

- micro-SRs in SRS - additional loops and feedbacks (that we can have loop in loop but also feedback in RSR to LSR and vice versa)

- regular and ghost LFSRs...

- latchings, holdings

- multiple flipflops of various descriptions for pulses out

- RSR is "clocking/logicopwithclocking" LSR and vice versa - need to test how this will work in all cases

** CSR - output register - CLKIN only, 2 pulse outs/bits or flipflops, DAC out: 

mode 0: basic DAC out

- type of DAC (eg. sigma/delta which is low pass of single stream of bits, x bit DAC)
- which of the bits are used for regular DAC: weighted, unweighted, spacings
- overlays, masks for DAC bits

- how we handle the pulseouts so this can also be extra/doubling up of modes

- *look at AC SRs and see what can be adapted for CSR as incoming bits and cycling bit (or combinations of these)*

- DAC outs from SR

- electronotes just has standard weighting ADC, uniform (bits x X) from consecutive taps, and sets of spaced taps -> wide spacings)

what else for 64 modes divided by speedcv/pulsin = 32 still (in pulsin we have bit length for DAC)

- number of bits in/out by CV or pulse counter(which wraps around)

- what to do if bits in/out is greater than length (options: put in anyways and lose top/bottom bits - shift if necessary // stop at length)

* notes... from elsewhere/sketches

- extra SR for random ops and timings maybe - that we can copy other SR to this also...

- what second bits out can be - different taps, divided/flip_flop, diff tap and flip_flop, logical ops with other bit!

- drooling shift register legged caterpillars

- how to do digital filtering - x spaced bits enter, passed down straight SR (with/without bit degradation, any other fancy stuff)
and X spaced bits are sent to DAC from CSR. return bits (how to select) OR/XOR from output (as bits or via DAC/ADC feedback options) to NSR/top register.

- maximum SR length as 32?
- ghost SRs
- parallel entry of data/ADC, sudden mirroring of SRs?

- leaky, rotting and/or infectuous logic/sticky logic/slow logic others?, UFO stuff 

what other kinds of logic gates there can be (based on CA, ternary etc)?

timing of a slow logic leak? 

trigger->latch and slow leak, disappearance of ones, bit by bit (how we could also display this as side project)

- NLC 8 bit cipher simulation: only makes sense for NSR and CSR where we have many bits in

... strobe is always high on 4094 so bits go into SR and are out, but
option for data on strobe which means all SR only change on 1, CV
combines different bits and primitive XOR for 2nd bit/mix with data in...

basically data goes to out when strobe is high, low -> just shifts 

so strobe is pulse in which can latch (incoming-ADC or noise) bits on to NSR or CSR
(outgoings) - and this is different to speedCv/pulse_speed as SR is still operating...

- how to work with overlaps? 

- overlap XOR LSR and RSR

- sieves - that LSR can be used as a sieve or bitmask for
  RSR/others... - how we deal with sudden events such as this, freeze,
  copy, ghost etc. (on a pulse in?)

- marking bits which always stay frozen - concept of sieves, masks,
  ghosts, revenants (eg. slow drift or decay of bits from one set to
  another, frozen, prevous or ghosted - so bit by bit they shift back,
  question of how long they take to go back?)

question of recording position and lifetime for decay - we erase on
death from the list but list handling is slow (finite sets of arrays
and garbage collect in one interrupt?) or we can just record and keep one bit max per SR

- TM encoding for SR_as_tape operations
 
  walk_ins - what else can be borrowed from language, concepts from UFO
  encounters?

- pulse triggers exchange between ghost and real, what pulses might
  mean - primitive programming language like brainfuck

//interpret set of bits as instruction on pulse in - say an x bit
sequence (but how to work with bits rather than bytes)

instructions shift left or right the opposite SR (can also use bits as
mask to do this - so we interpret one SR as shifting the other on each
bit in)

The Infinite Abacus: Brainfuck's "grand-parent" language

A version with explicit memory addressing rather without stack and a
conditional jump was introduced by Joachim Lambek in 1961 under the
name of the Infinite Abacus, consisting of an infinite number of
cells and two instructions:

    X+ (increment cell X)
    X- else jump T (decrement X if it is positive else jump to T)

- reverse direction of register (what this means?)

- glue one LFSR onto end/beginning of another

** parallel SRs

- feed data into top of parallel LFSRs, data read out from all bit outs: test for 12 bits, 12 parallel streams

** two headed SR



* in progress/ideas/todo

- how we pass through SR bits at different speeds - top one resets cycling/circling counter which wheels through SR
- is [0 bit our output?
- smoothing and other aspects from AC to implement
- re-test function pointers/how to make code more modular?


* TODO/plan

- basic structure of the 4 SR and straightforward tests eg. ADC in,
  pass down SR, DAC out

- proof of concept for digital filter and what ideas come from this

- all basic SR concepts implemented

- brainstorm and tests of all concepts

- basic modes layed out and tested - first speed CV then pulse driven and fancier...

