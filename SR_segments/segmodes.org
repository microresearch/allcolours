* plan

serpent's head, caput draconis (rather than heavens\) - lunar node and
link of geomantic figures with dots/dot matrix/bits... (see CCRU also)

dragon with 5 heads!

for calibration use unipolar out/gnded from Quad slope

CODE: modes? normed clocks, how fast we can run?

basic speed and new CV hardware tests, MANUAL

*20Kz fastest dac speed with 32/16 divider...*

signals are inverted so unipolar 0-5v is from 0-2048 values and bipolar -5 to 5v is 0-4095

-2.5 to +2 is 1024 to 1024+2048 = 3072

/////////////////////////////////////////////////////////

- implement sketch of all modes as below with DAC and ADC options
- check all pulsins, outs and clks/clk norm functions
- test/play
- tweaks for slower speed, CLK norms, what else? how we handle one bit audio filter?

* 2022++

*check all logic, pulsins, outs, strobey and implement strobey finally*

*expand modes in prob and bit.h - add cv masks where necessary to these*

*define what CVs we can use, what prob modes, split modes for adc, dac selects, and routes/probs*

settle speeds and test new voltage/CV scheme: what is Hz for 16 octaves slowest and fastest? 0.25 Hz to 16KHz

older notes:
- thinking on scale/speeds - at the moment we have 0-5v CV input and
  covers 2^10 - so 10 octaves...we want say 13 or 14 octaves - 0.1Hz
  to 5K for 14 octaves/doublings

*can we have knob covering this and 0-10v as 1v/OCT*

*100k instead of 200k for -10v and 33k in loop - as in Tides! (and can we adjust/scale input cv)*

// 14 octs in 1024 =73 per octave =140K of cv in maybe approx... (for 730 max)

http://lushprojects.com/circuitjs/circuitjs.html?ctz=CQAgjCAMB0l3BWcMBMcUHYMGZIA4UA2ATmIxAUgoqoQFMBaMMAKACVwU9wwURCALDz5UIA2lEkwELAIYgUCQp24DsfXt27Zo2EAx16w8ePpgnMkBMQQoU4-Bkgoyk4yZYAnFcIX5foiaQ7D4C3MTKYVIg4vrG0dJeodxoqtxUTvAsAO5+3Mx8isoFUElF-EJqfIKSKLhwLADGCkog6jHt7VQC0JlB-WCMxPoovVZkxC4RkMRqkOTmkKy55SXlNcErrTXlUZstkSn+ezkHMSmtXadVbXw3G9ftNTeapQDmZ2ACQuWpUo8aLgxCI+YIAe0kG3OhHI8UWcDIhCUilqkmwLAhYCQULUCCQSHhMwwSMIKIgGiQ6KAA

or 100k cv in, 23k feedback, and -10v is 70k

*figure out calc for filter speeds (once we settle on speeds)*

*TODO: check newmodes, bits_and_prob.org and other c and org files for modes/prob, what we have so far, how to maybe make more generic/new versions...*
*TODO: for dac_out/modeC we don't have speed to freeze/no OUT, also make sure we select DACs, modeC needs more work, also params to fix*
*TODO: if we use adc/modeN.h modes on L,R then check we have pulsins, esp if we use binroute as strobe etc!*

*TODO: maybe clean up in new version if we have to take a break - work on TOUCH/TOAD to complete// 2 may*

RESOLVE ARCH:

*static/frozen speeds in general or not*
*slower speeds/cv*
*check use of clk, pulsin, out*
*5th tail always running and how we switch in to it different streams from SRs*
*dacs with no interpol or not*

*BASIC DECISIONS*

** 9/5/2022

- *resolve 5th tail*

- new CV calculations:

So now we have 16 octaves which are to be covered by knob (full range 3.3v)

-10vknob is x3 feedback

- 16 in 1024 = 64 per oct = 640 max = 2.0v max

10v->2v = 1/5th

*100k cv in, 20k feedback, 60k -10knob - so we just change 2 resistors*

*but maybe return to 14 or 15 octs*

// for 15 octs would be: 68 = 680 max = 2.19v
10v->2.19=4.56 22k feedback

14 octs above

// how slow is slowest now/test? - slowest is now 2 secs/2secs = 0.25 Hz -> 20 KHzaprrox 16KHz = 16 octaves...

changed r65 (66.5k not 60k), r71 on proto board - tested/seems ok but need 1v source defined...

- start maybe again with reduced modes and macros with new modes - to cover all options below// again grid of options

- again how to wrap up: what is new/options:

1.new gshift/old gshift //for mix of we always need to reset/ add into what macro? into GSHIFTS_
2.all dacs interpol/no interpol
3.frozen or not - is that an option? or just keep with lowest frozen and slow speeds - or no freeze on NSR/out
4.use of clk/pulsin-xor
5.clean up so less macros and is a bit more general - also between interpol/direct dac access
6.detachment of CVs - take out of adcetc///
8.clkbit, other params
9.hold or toggle of pulsin/nay processor of values...
10.is we use speedmodes then strobey is more complex

- *new abstractions to be checked out*

- *test speed modes: SR_selspeed*

** 6/5/2022

- grid and use null functions like SRzero, SRone to stop/start options -> more towards moods/modes

- DONE: try alt gshift which keeps intact gsr (cycle through but we need to signal reset) - also if dacs have nointerpol or not
[as gsr as we have it can be destructive if we change lengths]

** 5/5/2022

- *slower speeds to test without stoppings* TESTINGS
- draft new architectures

- mode which is delayed functions of last modes (modes as parameters/crosses/bits of yes/no), CVs which are delays of last CVs
- hold/freeze CV at one point in delay, vars updated on trigger

-difference between SR and delay line, stack of modes/of values/CV/CVL

 O O shift/no shift
  O  speedfrom x/y
  O  binroute/cycle
  O  logic/prob/in

- *5th tail: initiate a stream and keep this running and move on*

           | | 
tail switch V
            |

- *thinking on new arch: that modes initiate streams, channel and modify these rather than one stream per SR, so can be shared streams also*
// but how many streams run simultaneously, also seems go against main idea...

// I initiate and route streams to others 
as in CLRN are not identified with streams but control them, with their clocks for example...

lots of options: x controls and modes stream y, but z can change it for itself, or all streams can modify it, in turn...


** 4/5/2022

head fire C 1=one dot/active. 0=2 dots/passive. 
neck air L
body water R
feet earth N

each figure has active/passive lines for 4 layers - in the 4 elements

*if we can translate 16 figures straight from binary into modes?, or translate figures or... a language to translate - 4 bits interpreter*

//recursion/inversion/or not/// .. probability of recursion

*formalise 5th tail*

*more consistent - pulsin in closing macro, clkins etc..., detach CVs for later/length/speed, draft this as cleaner set of modes 
*- we can keep main, draftspeed and only change modes*

// speed up compile

** 3/5/2022

*xx*
- *like idea of past modes still running/layered and changing params but how: or SR as selecting, running through modes, holding modes, operations ON modes*
- *params can also be shifted along, lag and delay as in SR but for values, or bit on/off selectors*

*a chain of modes cycling*

// notes from notebook and new:

- also division of types between generators (create), routers, speedfrom/routefrom, and global changers/experimental
(as works well with just SRothers on RL and CN as simple! 

eg.
  {adc0}, 
  {SRothers}, // SRX0 is basic route/xor
  {dac0}, 
  {SRothers}

- check/re-check simple types from rung:
1.generators+speedfromX
2.binroute/from and cycle/speedfromX
3.binroute/outDAC (we have)
4.5th tail feedback within a binroute ///

- 16 cards x 4 = 4 x 16 geomantic figures/ 16 SR functions x4 - detach, strobe, dacspeed, normal / figures as models
eg. for split speeds, always 4 layers...
- copy/gshift
- speed of X
- route
- prob/in logic

or * * - gs/no gs
    *  - ?
    *  - bin/cycle
    *  - ?

*also how 4 layers combine -- 4 ** * * * - 4 cards, 4 layers of head, etc... earth etc...

- *chain of for each SR// how???*

1-if [x] bitfrom[y] 
2-if [if [x] bitfrom[y]] bitfrom[y]
3-if [if [if [x] bitfrom[y]] bitfrom[y]] bitfrom[y]
4-if [if [if [if [x] bitfrom[y]] bitfrom[y]] bitfrom[y]] bitfrom[y]

- code layers, depth, descent

- re-check latest processors. values->bits = adc, bits->values = dac, values IS SR made up of bits, but what values other than SR do we operate on!

- inversions/inverted recursion - eg. speedfrom itself fails but does it fail if inverted?

- *SRs which operate on/stuff/change other SRs directly and not just GSRS, do we have these eg. shift on SR if bitx, insert into sr, splice...*

- simple modes/complex modes/detached modes/speed modes/global modes

** 2/5/2022

- speedfrom x [vs] speedfrom[from[x]]
eg. speed from DAC or speed from [chosen by DAC]

speed as value/speed as trigger and translators between? (added value to bits processor)
xfrom x vs xfrom[from[x]] eg. prob from DAC vs prob from choice from DAC

- *how to combine generators/processors (for bits or for values): sets of combos but how to combine and we need more*

** 29/4/2022

- split of spdroutes | binroutes

speed from SR | speedmodeX
route from SR | binmodeX

** 28/4/2022

files:
//org: Xmode, 1apr, thisone, acSRmodes, seg2.org, bits_and_prob, temp, temp2

//.h/c: modeX.h, experiment.h, probability.h, prob.h, newmodes.c, abstraction.h

*can anyone be DAC - but if more than one what do we do? mix? -dacbus?*

*question of 5th tail - if we always have this*

// from below: speedfrom [ADCs/gens=strobe/prob/clksr/DACs/binroute->which route?]------->      gsrcopy // <<SR // <<GSR // binroute/dac

DONEsmaller gen selection eg speedsfrom...

// bitfrom,,,,

- note: param[x] is count between interrupts, clksr_ is SR shifting on strobe bits -> re-worked to test...DONE
*- so we can use clksr as a 5th tail on each - an SR driven by clk but we can copy contents in there (when/how?)*

- DONEbits bump values - bits-> values

- *check bitdsp: recursive boolean networks(int), delta(int), delay(int32), maskedOR(int32)*

// maskedOR:

(MASK AND (A OR B)) OR (NOTMASK AND A)

back to basics/classicSR:
1- speedfromX / or / CV clock speed
2- prob of new entry/vs/cycle - new entry can be route in
3- prob of inversion/vs/cycle - or/xor pulsebit/clkbits

fixed routing (rungler) vs. open routing/dictated routing (last segment of modeR) - see below how we deal with independent modes

maybe simplest thing is just to try some sets of modes out...


** 27/4/2022

- Q, if we replace binroute with generic abstract access... then what do potentially independent modes do?

// so we have: binroute, multi routes in, dacs/SRs dictate parameters, we can patch pulseouts in some cases, they can pull in adc, give dac out
// *binroute is kind of fixed to a routing operational mode!*
// do we need to guarantee that one Sr contributes?

L,C,R we have pulses out... so N is odd one out// 6 pulse outs...

- for slower speeds trigger always needs to coincide or we latch - reset when we use - testing in SRghostlatch

- *also QQQQ we dont use clksr_[w] so much* - try in gen.h to shift out...TESTED?DONE

- that we devolve to each SR as a single function - so not having
  chain of bitstreams as decisions/speed but spdfrom binroute,
  probfrom binroute and manipulation of routes is more important

*again clash of route in->bits and route in->spd/decide...*

*then each needs 2-3 routes in+*

DONE- generic sigma delta - we have for adc and dac in adcetc.h but could also be for other values: SRsigmadelta

DONE - holder function - hold bits for /depth/ time: static inline uint32_t SRproc_h(uint32_t depth, uint8_t bit, uint8_t wh){  
*AS new genre of processors - how these would function*

- *way to express lists of functions/operations/flow - again what is most generic pseudo SR...*

x/y grid of parameters and functions

BITS/STREAM -//- VALUE/CV/DAC

recursion needs some input

N L R
\ | /
  C - 3 bitstreams + strobe + CV/CVL/ADC which can select and control bitstreams 

CV becomes bitstream 
bitstream selects CV source/influences it... *[how to abstract bit choice of DACs, CVL, CV, SR raw, past SR, tails... more pointers?]*

- RSR defines 4 major routes _or_ modes ?

- how to archive and overview all our files... new approaches/evolution...?


** 26/4/2022

*primary question of recursion - heads and tails and how these are connected, what recurs, feedsback on what and how Rmode can change this*
*recursion of geomancy - 4x4 = 16 optiosn, 4 major modes???*
*also recursion by way of jacks, and param[w] not to forget*

- *also forgot about lengthsel functions like adcLSRlengthsel0 in modeN.h*

// added binrouteINVbits in gen.h 26/4/2022

- CV/CVL as bits -vs- CV as param to generate bits? ????

- sequential bits bump up spdroute/binroute - other choices
- bits choose binroute bits -> incoming -> bits choose...

.. 1 bits -> speed
.  2         route    x4 SRs
.  3         prob
.  4         logic/pulse  -> recurse all onto 4x SRs - 4 heads - what that means.... [N-speed, L-route etc]

[bits] selects [bits] for [eg. speed] eg. bit as speed bit selects source (which is other bits)

** 25/4/2022

*4x4x4x4* permutationals caput draconis....

*TODO: /// all generic spdmode modes - these need speed/length being copied over for necessary modes*

- take stock! compare abstractions in new file
- no major modes on R - but how we can achieve eg. vienna-like modes (6/12 bits)
- switch by CV between CVspeed and strobe speed.

- catalogue all: where we get speed from?

strobe, CV, adc, CVL, dac/which?, bitsfrom/which?

** 22/4/2022

- shared bits completed... can also be with other generators embedded

//generators in generators//

** 21/4/2022

- q of stacks of params - but maybe too complex (feedback loops of SR->params)
- working through new abstractions in experiment.h
- potentials of shared bit and rungs in rungs
- maybe get rid of unmoving SR or????
- that we can also have interpol for non-frac speed eg. strobe modesDONE

rungler:

---->0  0<---spds
\  dat\/ spd/
 \    ()   /
  \-- ()--/
      ()
- 2 side SRs and 2 central

** 20/4/2022

- working in experiment.h: abstracting out spdmodes, spdfrom but we
  can't route own bits to speed (of course). no recursion, dies out
  (unless we use clock - added this to binroutebits)

- strategies:

-- too many parameters,,, fix some/mix and match
-- print and cut up functions/python re-workings/further into generic functions
-- *dissect whole diagram TODO!*

speedfrom [ADCs/gens=prob/clk/DACs/binroute->which route?]------->      gsrcopy // <<SR // <<GSR // binroute/dac
infrom [ADCs/gens/DACs/binroute->which route?]
IN/prob? [ADCs/gens/DACs/binroute->which route?]
logic [ADCs/gens/DACs/binroute->which route?]

-- most generic option eg. vienna code ... but how to get recursion in/chasing/chaining, also null route mode is there

recursion and chains:

routes--> spdfrom \-\----> recur onto routes
          bitfroms \-\
          probfrom \-\
          logicfrom \-\ and from is to route in...    

how to be all of? - supplier of bits to determine X, route in as in bitsfrom, and this way in ???

cannot recur on itself or 4 selves..

LRNC are defined by route (and adc,dac out but these can be changed) and doesn't matter who has adc in as all is determined by routes

all have route from 3 which has route from ... or is a gen, or adc

*sync routes, sync speed (on trigger)*

binroute/spdroute / detach / layers of params 

as in mode can set binroute/spdroute and stick with this *trial?*

thinking that layers of params like a stack can be an SR which we pile up... how to remove layers?

- no identity - identity is only from route (pulsins are only identifiers of LR) and physical layout

so key is what provides this identity: one master, 3 slaves, as own chosen identity might be at odds with others

towards something like major/minor modes or modeR chooses from a grid of modes...

abstract out interpol and strobeDONE

*to keep null route in binroutes or route always from 5th/extra tail?!*

** 19/4/2022

- see experiment.h// large notebook notes

- thinking about trigger and how it works in CVspeed modes - if we
  should keep trigger/pulsein over until we process - ie. if was
  trigger or pulse in the interval? - but for long intervals chances
  are there will be a trigger - maybe notion of trigger window?

- *TODO: fix up generators a bit so they make more use of depth and work well*

- other routing N-L N-C L-R R-N: 8, 1, 1, 2

- slice/splice remix and mix of speeds

** 18/4/2022

*TODO: final multispeed modes, modeC still needs non interpol dac and mix outs, an end to modes*

*// some more generic solution???*

- one bit audio doesn't work with unipolar signal (0-2048) as we set
  the middle/zero? 114 is new adcmode, and should also be generator
  but questions bi vs uni entry... same problem with comparator //???

- fixed binroute^=logop in modeN.h

binroute as function on top of binroute cancells itself xor

variations of delay line sharing - what of these modes which only make sense for 1+ Srs to run...

*Q. gate[x].dac and easier access - owndac -> other mode mood scheme*

notebook:
- how too share access to bits in function (master?)
- only copy in when the receiver has made one circulation
[stories for each: ]
when you have circulated, i will copy in. when i have acknowledged that you have circulated you can copy in
what does it mean - when you have circulated...
or bits are shifted into longer register and we keep track of our own index...

- DONE:delay which isn't a slowing down. bit delay line

- rethink/reduce to well-documented and tested sets of functions:
-- basic prob/routes
-- classic SR and excursions
-- ADC/DAC
-- fancier permutations of each characteristic. eg. multiple speeds...

- also functions which convert/use DAC 32 bits values...???

** 15/4/2022

// how we can share a value - who updates it? eg. sample and hold ->? heldsample
// unless is outside the generator and always runs, then we need to always run adc and just sample that...
// or mix and match adcs...

// new signal processors: sample_and_hold, what else?

4094 implemented: outs are each bit, CVs from groups of bits and the QS/serial out (see 4094) below..., clock edges

we have 10vpp so 5vpp has problems with full range comp... also comp and unipolar signals

*fix comp at 2000 and think about signals - comp without depth?*

new: added defdac=3 global, proper 8 bit cipher mode: (we have some as SRN33,34 in modeL.h)

///question eg. with say consecutive ADC values of speeds (should we bring adc in at fastest and just sample from this??)

DONE: chance of prob decay (flip) as it advances down SR... - older bits...- initial chance of decay/flip

/////

*how to start to make sense*

TRIM//back to basics/strip down with details and variations on latest sets of modes:

speedfrom?
from?
inlogic?

to answer for each classic SR:

eg.
TM/WIARD/EN: speedfrom(clock), from=loop/invert loop, inlogic=prob: CVcompNOISE/SR=comp

and what this means for each SR side. eg.

speedfrom: clock/speedCV/DAC(which?), bits
from: ADC, loop, pulsin/clkin, invertedloop, inverted_all
inlogic XvsY: probCV, probDAC [probFROM], strobe, toggle [LOOPvsFROM]

RUNG:

generic rungler: 
SR1: speedfrom clock/dac2, datafrom 3(route or dacNSR)XORloopback // route from C=3
SR2: speedfrom 1, osc/abstract
SR3: speedfrom 1, osc/abstract

functions/philosophies: 

-types of input (ADC abstract) and output (DAC), processing

-generic - also relates to recursion - eg. incoming SR dictates functionality of SR (or a param such as length)

-replicating functions such as digital filter, 8 bit cipher/4094 SR

-didactic: how do we use all the bits we have, and the parameters

(speed and length or more untied params - they are just parameters) -
new model (ie. how useful is length?)

...but SR "has" length and speed/clock as basics (unless we just think of bitstreams)

look again at 4094: 

The HEF4094B is an 8-bit serial-in/serial or parallel-out shift
register with a storage register and 3-state outputs. Both the shift
and storage register have separate clocks. The device features a
serial input (D) and two serial outputs (QS1 and QS2) to enable
cascading. Data is shifted on the LOW-to-HIGH transitions of the CP
input. Data is available at QS1 on the LOW-to-HIGH transitions of the
CP input to allow cascading when clock edges are fast. The same data
is available at QS2 on the next HIGH-to-LOW transition of the CP input
to allow cascading when clock edges are slow.  The data in the shift
register is transferred to the storage register when the STR input is
HIGH.

-patterns (classic SR)
-more about one bit audio/rotting sounds
-input, feedthrough and feedback - ADC/DAC and also abstract functions/SRs
-bit *recursion* onto itself - deciding itself (SR state/function as SR) - how an SR is defined and encoded
-SRs as functions which feed into each other and dictate each other - more as a patch

influences/ideas:

- CCRU/hexagrams
- i ching/geomancy/african binary codes...
- rotting sounds

** 14/4/2022

To resolve: binroute and logics, clkin, pulsin, CV extent, what we get from newmodes.c and if we can discard: list of missing modes to discard or port

basic routings - for new functions, for new routes
basic clk, intmodes, speedmodes
basic SR structures eg. Tm etc.

all the modes we have created
generic modes and how we can create from these///

or follow abstraction route?


see also temp.org, temp2.org, bits_and_prob.org

work through step by step and also new experiment.h - conclusions from abstraction

Q of restraints/simplicity which can then be stacked up and CONTROLLED!

////////////

multiple speeds of:

- copy gshift
- shift own SR
- advance incoming GSRs
- main dac and route in with no shifts


- routing depends a lot on modes...

- abstract works. change gate[w].dac throughout or???

- so we need more logical ops for binroute in! that is not always XOR as standard - but how to vary this (global, local)

logopx(uint32_t bita, uint32_t bitaa, uint32_t type) -- 2 bits

TAKE CARE OF:
- basic SR structures and routings with changing logop
- using new abstractions//functional routings
- new abstract modes and lists // cover basics and extend
- masks

Q of binroute still, of logic ops across all, major and minor, grouped modes etc....

[one idea for grouped modes was to have R as selector of grouped modes and each other mode as moving off to other modes...]

split between functional routings, grouped routes and prob routes and traditional feedback routing and if we can mix the two...

if say L has function such as prob - for pooling of parameters - then ... ways of thinking about modes...

take stock of what we have...

** 13/4/2022

- notebook: recheck generator as speed????
- clkin should be more or less consistent eg. NC, as pulse in XOR, LR ???
- Q of mdoes, sets of modes, major minor...


** 12/4/2022

- norm clk only in clkspd (and essential clk modes) and make use of clk always: as pulsein
  (esp. in C and N), as toggle and non-essential decision, advance GSRs and other elements

more of clk: clk can deliver from gen or cycle in - also toggle

clk
toggle

*to treat as a parameter we need to use - even if is fixed as 0*

- 2s complement and others for noSRadc DONE and some fixes there...

- how we can think about routing/functions... for example, N-incoming, LR-params for entry of N into C/outgoing...

but that is split with "normal" routing of N-L-C-R-N...

** 11/4/2022

- see experiment.h

** 9/4/2022

- *question really of too many bits/params - and strategies for coping with these - eg. each mode as part of the param space (eg. dictating speed)...*

- possibility of a shared gshift, and of dissociated outputs (inputs also into bus?)

- are we done with modeN/incoming?
- start catalogue all - esp L/R and do we have enough from the DAC
- check all files...

// more working out in expr. modes. how much is down to CV, pulses and clocks in and less fancy modes...

** 8/4/2022

- options not to advance the Gshift so there is no cycling in - global option. this and binroute in?
[also has a lot to do with length and incomings]

SR can even be totally static or just fulfill a function /// try some basics with this, new experiment.h file

as below, what elements can be used from delta sigma

//////

DONE/: test/simulate our sigma delta in test.c -DONE - just that we can't sample so fast (16x 20K=320kHz)

notebook notes:

- SR characteristics: independent, they don't dictate to others
------ each has a function, an input, an output?
------ speed

each SR has a route, feedback through decision, altering next but also a FUNCTION!

a patch programming with SR to next, but next determines its own route...

clarify possibility wheel ... wheels in wheels

N-probability of entry from [adc-which?^R] vs cycling
L-fromN
C-fromL
R-fromC

** 7/4/2022

*is there a way to do integration, delta-sigma across seperate SRs -> integratorandcomp we do already (N-entry), flipflop(return to N, so R) with C as out?*
*

DONE:strobemodes to look into for conv to binroute bits: adcbumproute0DONE, adcstrobe1_0DONE, 95DONE ???

but we need to use BINROUTENOS_ for no strobey! checkDONE

*also in adcins more use of strobe with route in for feedback - so not always adc or anything in but more feedback*

can have routes in, speedroutes in, IN?routesin, probroutesin, etc...// but this can be/is abstracted by generators which include route in

either/or from stream in: runornot, stream/bit/whatever in or cycle -> so is a prob

we can use binroute to replace prob and also as strobe for adcinsDONE/// or other strobe modes

params: detach speed/strobe, detach length = max 2 params (with adc as param), dac as param

TODO:
- new model with speedstream, fromstream, instream as functions... other models to look at

N-speedstream, entry
L-from?stream
C-instream?
R

// but how fast do we run speedstream - just test it?

////

//DONE:eg. stream->selectTM, WIARD, EN - stream can also be probability 1 or 0 yes/no 

DONEalso as routingmodeHOW?prob becomes a looping SR of decisions enacting on itself - also slipping of prob running at a different speed

//run prob_wheel at speed x, use it at speed y

different types of prob wheel - is just a stream wheel. wheels in wheels...

can wheels be spread across SR? // need to think more about these wheels - that any generator can enter them - SR is itself a wheel

recursion of generators:

- generator x decides if we extract from generator y (but if we have that in one it lacks speed)...

- x decides if we cycle/enter new gen y which then decides if we... -> and back to x

no route but binrouted ones as decisions for... what? eg. entry of adcbit or cycle... [entry into wheel or from wheel is the same thing // entry_or_cycle]


///

- make new selections for adc and dacs
- draft possible lists functions for mode selections

** 6/4/2022

INstream/DECISIONstream [IN?]

bitstreams all for: speed/FROM?/IN?/WHERE? 

and how we can route those?
... but there are also analogue streams - eg. CV, DAC (which have
different convertors to bitstreams)

split: bitstreams\\\///probability/CVanalogue/DAc

*what a new model for this could look like?*


*would also be nice to have dacs routing in to RSR side - dacmodes input - just as modes we have in adc/dacmodes list*

binroute-count // route in
spdfrom-spdcount // speed from dac
gate[dacfrom[daccount][0]].dac // dac as param or mix in/src

*still Q. of how we deal with/binroute_or_not - set in modeR? - also xor in binroute and addin to gshift options*

binroute:
N- yes/no/how?
L-yes
C-yes
R-yes/no - no for generators/or 2 sets options with without binroute

Rfinds route in via N - so binroute is critical there for uses of DACetc

notebook notes/other:

- DONElist adc modes which use strobe (does strobey still make sense or becomes overcomplex with modes of modes)

*make new selections for adc and dacs// also strobemodes list*

[do any generators use strobe?no]

DONE- use abstract bitstream to IN? eg. if (bitstream) binroute or cycle... DONE: adcLabstractQIN

DONE:abstract generators are not independent so multiple calls across them change them which could be interesting:
draft also independent versions, 

DONE: length=depth and if we add in gshift/addin or just shift out, binroute or not...

DONE: say NLR can be generators into XOR (full mode) on CSR - DAC - can also be mix of logics and prob there...

*also for CSR more modes todo: mixes, using bitstreams to shift between incoming streams etc*

- DONE4 bits in as [binroute/adc/dac/abstract]? - now maybe a successive route in 4  bits...


- DONE...general options for shifting as bits: copy_to_gshift, addin_on_gshift, shift ourselves/double shift, pulsins, other pulsout options, add in bitn - say 6 bits

5th tail in progress

- *extended modes - that can have say modeR to select new sets of modes for others...(then what does their mode knob do?)*

- *thinking how we can have more flexible routes - so we can route cv and/or dac or other streams into functions...* from outside/5th tail or?>?

so we stream in to 5th SR/tail - choose speed and sources from Rmode
and use this in other SR modes - we still need to think on how to sync
across modes

*5th head=tail*

contradiction of severed recursion

eg. we want to use feedback but take it out of the loop, so it isn't feeding back...
so 5th SR would be like RSR but not feeding backin (a copy and not) - SEVERED
- at different speed but where we can get this speed from? opposing speeds?

- we can only simulate potential feedback and use this - how thus could be used in writings as concept...

** 5/4/2022

- maybe no major/minor as we need RSR

- ways of grouping favoured sets of modes (also like RSR syncing modes), splice in modes, extra modes etc.

RSR modes/character: 

- feedback/probability
- independent DAC functions/generators (abstract, some in)
- other functions (more of RSR etc. eg. global routings)

do we have generic, detached probability modes?

*TODO: RSR sync mode (sketched in)*

RSR: that can GSHIFT itself as a 0 always to prevent binroutes into others (but does this effect anything)
check for gate[3].Gshift_[3]

DONEgeneric ADC/DAC generators->function array, abstract gens, 

generic IN?DONE in probability, WHERE? we can't split per SR as we need the bits for logic... just have one bit routed in

out which uses SR (which?) as sieve for multiple bits

/// odd one. route in is determined by bottom 4 bits of another SR (do
we have this?) - we have SRSRroute in model.h - but would be nice to
select which SR we use for this

*still thinking on how to split SRs so we can say mix multiple bitstreams* - think in parallel...

can have 4 parallel generators XOR in say on CSR with prob (we have already)... route all in...

tested new abstract generators 0-16DONE

** 4/4/2022 

*IN/DECISION [IN?]*

extramodes.c: ignore as formed newmodes.c ->

newmodes.c: most of these are in modeL.h

temp.org, temp2.org, bits_and_prob.org

//////////////////////////////

Qs: routing and independence, if we want free SRs which just control/dont route (RSR), binroute or not, major/minor modes or not
what we need to add: new generic bitmodes...

//////////////////////////////

catalogue files // we need overview of what we have:

- DONE: fixed some electronotes mode in probability.h and now we have all modes as generic and called with w!

but we still can't have minor modes as all ADcs/// so how to mix////

+but problem is pulsin (for N and C), and out (for N) - so adc modes have no pulse in, no out if used on LNR sides - should be FIXED now...+

DONE: genericise - only thing we need to watch is count, daccount and spdcount (new)

we can still have specific modes... we also got rid of slow/no_stop for CSR!

we also need to deal with probability.h and bit.hDONE

rung modes fixed as gate[0].dac

/////////////////////////////////
notebook notes+

- +TODO: simulation* sim.c+

- mix and match major and minor modes so are not all same /eg. not all prob. how?

- generic in: 

//FROM?//where from [ADCins/generators, DACins/generators [16 or so each], routes/returns] - how many bits? 6 maybe - and we need one param // combine?

4 bits typegen/2 bits[-eg.adc/dac/abstract/route]=6 bits

//IN?// as [strobe/toggle/bits[from]/probX.Y.Z] - how many bits? // combine?

strobe|toggle|bitsfrom1234|prob1234
1            |1bits/prob|2forwhere = 4 bits or more depending on prob modes 

or we fix as prob/bits only from 3/RSR... then we have 2 bits - but prob needs CV

//WHERE?//where in - route by route? eg, xor, logop - can also be abstracted as an IN?

*or these can be split across SRs: - held in potential as once we have them???*

eg. N is where from, feeds into IN? (L), then C is wherein? (or just first 2)...

but then what is IN against... and where? doesn't work out

with R as majormodes/back in or patterns for others (eg. we can't use DAC/bitss if there are no interesting DACs/bits)


** 1/4/2022 - see new .org file for today/new notes/concept

10 encodings below XxY ADCxDAC mix = or - and we would need 3 parameters: whichencx mix whichency

speed and length as 2 encs only...

*or: trial for overlap/mix across NSR and LSR! so one as ADC one as DAC in*
but that is different kind of mix..
// set up generator list so can be selected...

** 31/3/2022

list of encodings for ADC, DAC: parameter is depth/delayforonebit

16 encoders without comparator

- maximum 12 bits 1
- padded any number of bits 2
- fixed number of bits: 12,8,4 345
- one bit encoding 6
- equivalent bits 7
- energy equivalent bits (abs value) 8
- fixed 12 bits 2s complement: can also be 8,4 //9.10.11
- variable depth 2s comp //12
- fixed 12 bits 1s complement: can also be 8,4 //13/14/15
- variable depth 1s comp 16

- comparator is an encoding???? no?

generators can also just be in modeN (see example Nintone)

complemented by DAC decodings

list of abstract generators and abstract modes:

gens: 

*notebook notes:*

///question of so many params/// 

In modeN ADC is possible param so with all detached we have 3 params... max 2 in other modes

strobe/detach modes - frees speed and length as 2 params

///

- *how we manage routes - sync routes?*

tricky as who syncs? if all mode can do this?

- length of SR as distinct from param for ADC or DAC modes 

length is only relevant for entry into next SR (if there is), and for cycling

- what length and speed mean for each... (eg. in modeN we can free up speed easier)
- how to extrapolate from basic SR (eg. rungler) for each side: L and R should have basic prob modes

- slippage of bitstreams against each other 
// *also that instead of a route we combine two SR eg. N and L??? how? and what is their content///only if both are generators* tEST

- Q. detach ADC mode and leave it there?

also defining basic ADC modes and modes which are more fancy and involve other routings - see how these are divided across adcetc/modeN.h

x abstract modes ----
x ADC modes ---------> bits/params for these eg. depth. + binroute/from/cycle + prob/strobe/toggle + specials...
x DACin modes -------

- stop adding more modes!

** 30/3/2022

generators/bits, encodings if any --> bits, 12 bits/encodings (only for dac and adc so we need these in generators)

generators->prob/etc/mix

*TODO: other basic SR options*  

WIARD: noise/comp selects new input or loop back/inverted loop back (jumper) //options relating to new input: adc/dac, mix, routein - how to select these options

EN: LFSR SR bit is loaded/not loaded onto recycling SR. loading can be random (based on LFSR and set of probability switches)
DONE: as a generator, we have variations otherwise in moden for adc in 

- there were mistakes there which we need to fix from generator code...DONE - port electro to other sides

TRIADEX: see what we have, harder with limited params but what we can get generically from this: multiple bitmasks

///////////////////////////////////////////////////////////////////

DONE:1 and 2s complement for ADC, one DACinDONE

one's complementDONE

also encodings for 12 bit dac // so we can mix these////someDONE

*too many options/params: eg. speedfrom, adcin, mixwith dacfrom etc. stream, encoding*

dacfrom/speedfrom? but also dacfrom is param and for feedback we route from 2 so is different - changed in adcetc to 2 for dacs routed in

*DONE:use speedfrom so dacfrom and speedfrom are different and can be changed globally in modeR-TODO*

eg. gate[speedfrom[spdcnt][3]].dac vs. gate[dacfrom[daccount][3]].dac

- how to genericise rungler so is unfixed in routes... eg. that we can use NSR as oscillator approx... but speedfroms are fixed here....
and with rungler we need all to be kind of synced... but abstract out...

generic rungler: 
SR1: speedfrom 2, datafrom 3(route or dacNSR)XORloopback // route from C=3
SR2: speedfrom 1, osc/abstract
SR3: speedfrom 1, osc/abstract

speedfrom x

encode as:
binroute-9,0,2,0 
speedfrom-1,0,none/0,0

*but there is no sync of modes to use certain routes (count=binroute, spdcount=speed is that sync) - think about this*

out is SR4 with route/dac from any... CSR/generic or we add speedfrom x option

//////////////////////

from notebook?

x speedfrom
x [dacfrom]
x routefrom
x param from 
------------> recurse?

** 29/3/2022

- cut routes? from notebook - what this means/how/why? relating to rungler - to cut the binroute in... =0 but how to put back...

DONE: rungler options.

////

//bitwise not add one

for rungler:

SRN: speed from SRR, data from SRL - new route XOR with loopback

SRL, SRR: speed from SRN: (both run OSC with no binroute)

SRC: output from oscs or from SRN - select our input - route from...

implemented as: NLrung0, Lrung0, Rrung0 and CLrung0

variations around these eg. for L/R type of speed, detach and type of osc...we already have some of these, working on for LandR//DONE

+also idea that if we use ADCIN as CV then we can cut the loopback or is it normed?+

** 28/3/2022

*do we have fake feedback loop at fake speed?* - Ndraft1 heads in this direction

but thinking we can start to work this towards the fifth hidden serpent...

which could be fake feedback tail -> how long? speed - then modes (NLCR) which use this extended feedback, which can take different forms

*?* that in modeN we always run input at full speed and just select
bitn in on own speed - only question is modes which use multiple input

or just run one kind of adc?

*To start to simplify*

ADC/no input abstract modes: 22,23,24-LFSR, 28-clkbit, 29-osc, 30-osc, 31strobeTM, 34osc, 77osc/dac, 78osc/dac, 79osc/dac, 80osc/dac, 89impulses, 95patterns = 14

but most are not straight modes without CV/params - *we need very basic abstract modes here*

DAC input modes: 25,26,27,71,72,73,74,  also mixes of DAC/ADC in adcetc and in modeN to port from INTmodes/DONE  =7 


back to basics - detached TM modes (NLtm101)+, rework classic modes exactly, new
code draft layout

TODO: other bit encodings for negative in adcetc/modeNDONE

classics:
- TM, done - all variations to explore

- Rungler: NLrung + some variations TODO

Original: SR bit out XOR with OSC1 out AND OSC1 speed/freq is determined by SR (itself)

translated: cycling bit XOR with other SR out bit which is clocked by
SR/or DACspeed from itself (bit clock options are set BY SR itself) 

or:

cycling bit XOR with DACout from own/other SR vs. comparator=CV/DAC/DAC+CV/CLKCNT

WIARD: noise/comp selects new input or loop back/inverted loop back (jumper)

EN: LFSR SR bit is loaded/not loaded onto recycling SR. loading can be random (based on LFSR and set of probability switches)

TRIADEX: 

/////////////////////////////////////////////

new code draft layout:

// how to code a new prototype from/also a bitmapped/probbed mode from:

-bitstream /in/ (depth, other params) -routedbit/s from where/ROUTINGS/// - this is also a bitstream... but we have it seperate

parallel bitstreams...

-dotheycomein? - strobe/toggle/probability/ANDbitsotherSR -> using AND
from other downstream SR doesn't work for feedback reasons///

- *how they come in* splicings with other chains, mixing with other
  chains

At the moment we have prototype of:

  if (speedf_[w]!=2.0f){			
  if(gate[w].last_time<gate[w].int_time)      {
  GSHIFT_;	
							
  bitn=ADC_(0,SRlength[0],X,gate[0].trigger,dacfrom[daccount][0],param[0],  &gate[0].shift_); // parallel streams
  BINROUTEOR_; // parallell

  BITN_AND_OUTVN_; //out

gshift/bitn_in/binroute/addinandout!

sources[1]->entry[2]->logic][3]->where[4] (also 4 tails/routes here>>>)

incoming bits vs. interpreted bits

 they are bits - multiple GSR speeds...

ADC/DAC bits: deliver bits/generator, tap into stream ... 
OSC bits: they are bits, also can be streamed/accelerated...
BINROUTE bits: they are bits, can be multiple GSR speeds, where they come from=route
feedback bits: loopback bits


/////////////////////////////////////////////

*simple case of binroute or not?* how  to handle?

/////////////////////////////////////////////

*that DAC out can also have choice of non-interpolated modes eg. c0nov*

slowest speed is not 0.1Hz but 2Hz? 2Hz->14octaves->20Khz as our fastest

////////////////////////

- question of how to advance and finish SEG/Heavens/caput draconis ???

basics such as speeds and CV, layout, modes... survey all modes - what
are we missing?

characters of each tail/branch and new 5th branch...

TODO: split and join 2 branches at different speeds, brainstorm ways
of dealing with 4x tails...

** 25/3/2022

//quickTODO: sliding/splicing bits input adc_doesn't work as we tried
before - forms a block, prototype for new setup from notebook...

working on Ndraft0 - also that mode of fast adc then copy in is also interesting which is what that is as no feedback so far

NEW: N98adcordac, N99 (toggle dac or adc), NLsplice100

*PROGRESS: new org page for each mode - can also be towards manual*

** 24/3/2022

- *5th head of serpent* indicates extra feedback path - uncontrolled -
  sink for other SRs, or free running SR, controlled by? eg. like
  flipflop or generic SR... we can sample and use this 5th head!

what are its parameters?

- probability of feedback return is important

- almost as if there could be chains of ADC operations

SR as a chain.. specifying chain

N95 is now with dac choosing pattern to enter on strobe... *patterns can be geomantic*

- assessing modes 11/12 in DAC and general speeds of DAC...

*still question why length of ADC/DAC doesn't make any/much difference
to signal*

note also that oscillators are more effected by speed of NEXT SR - (eg
modeL)... as if they are unchanging they write the same information -
would be different if they were catching samples like 1/0/1/0 like a
DAC - can we try this! - towards trying to think more generic

DONE: Nflip mode... 

OSC modes can also have strobe or other prob/decider for loopback (dac
decider?)

ADC: *insertion of static bits* /overlap of bits from different sources (where
did we have repeating elements - from adc 87 on strobe) eg. we realise that 1010 from ^=1 (30)
could be static pattern 

on strobe we could enter one of y x-bit patterns (eg. 4 bit
geomantics)... NLpattern95 but we could have other splices (of ADC
etc)

SR keeps shifting/or looping and we insert bit only on speed... - that
is a bit like multiple speeds which we have already

N97 only - we insert 4 bits in on speed otherwise keeps on routing,
can also be route and cycle, other options

// how these new modes fit with generic ideas??? ... more about
splicing in, and seperating elements/shifts/speeds

a lot also about routing...

///modeN-> define abstract modes

*window of feedback... in modeR or N*

** 23/3/2022

- DAC16mode doesn't do much, sliding window, we will need to find use
  for length in DAC as doesn't do hardly anything and we don't use for feedback...

*maybe invert incoming adc and not dac out//or keep dac inverted*

*TODO*- different encoding/decodings for adc/dac eg. one's complement
= bitwise not, two's=one's+1, signed magnitude (MSB is sign 1 for - -
this works better for energies...) - more abstract modes?? what these
could be??

//cut below 2048, energy only/equiv we have but can also be bits,,,,

ADC - encoding, bit codings
DAC - decodings?

////

eg. process/subtractetc, how we interpret these bits

ADC- encodings/depth, how we deal with bits/coding bits (length?) (adcetc), this
becomes bitstream into length SR (moden), do these bits come in, how are they
treated, any other

abtract out routein/vs/adcin/abstractoscin/////

////

do we have comp against changing levelyes-20/otherpar- DONEcan also be detached mode

subtract changing level...Nintsub92 - detached? DONE NLsub92

comp at 2048=mode85

** 22/3/2022

- refining: *that some DACs can have reduced depth/bits=volume* (again
  there we don't need to match to length but then length does even
  less)

Q? modeN. 
0-7 - most basic ADC in
8-15 - strobe modes/abstract modes...
16-31 - detached modes, detached strobe modes

/////modeN
-bitstream in
-routedbit/s from///
-dotheycomein? - strobe/toggle/probability/ANDbitsotherSR -> using AND
from other downstream SR doesn't work for feedback reasons///

*(is just AND of bits with strobe/toggle/emerging bits) - probability as a bit*
*idea of SR of probabilities itself*

*bitstream can also choose wheretheycomefrom* see N91sw (again
question always of detaching feedback - one limb just for DACs or???)
- extra limb...

-howtheycomein?

for other modes we can have this for pulseins and routedins - make generic

/////////////////////////////

- reverted old adc, now back to new as was thinking on ADC noise but
  is caused by fact that 0v is 2048 so x bits, rather than 0 - lower 6
  bits are positive, top 6 negative (as is inverted) - is this a
  problem (on output 2048 is 0 though but just means absence of bits
  is not 0)...

- thus 0 bits in register is -5v DAC output (as inverts there), but
  input is inverted...

- how do we deal with this? for example with equiv bits? or we can use
  some lookups in some cases... (one bit audio in/out seems to work ok
  now...)

but we have no way of signifying pos or neg with bits/// trial
energy/abs->DONE/also as generator

-DONE/TODO: modeL/R where we don't add back in bitrr in gshift so just
  dies out (as kind of impulse)* Lnoggg test

** 21/3/2022

- *TODO: more mixes//bitmix add is an OR*

 *bitstream abstraction-question of sources, plan*

- 17,19 in adcetc as suspect - clean up adcetc with new ideas
  too.... 19isfaulty - replace new test case...DONE - also changes to
  int29mode

- oscillator has length of 1 and 0 bits so 2 sets of params to deal
  with or we have square 50/50 oscillator... 

- what we mean by impulse input? eg. strobe triggers x bits (1s, x
bits from adc, x bits from ...) NLpulse89

- DONE/TODO: sliding DACout from notebook, depth, whereitis and [shift <<]
  params - done to some extent as 16 in dacs

- TEST:N,L,C,R with sequential bits in from generators - Lstream,
  Rstream etc - TESTED fine

- added lookup for mixdivs72,72dacmix-check

** 18/3/2022

- fix adcg and adc mode 7 as this just gives LSBs and check all
  adcmodes, 6 is also same as 3 so replace both, 8 too DONE

- do we have cycling adc/bits in - new mode 8 in adc_

- to fix some of modeN which use old adc_buffer: 71, 72,
  72dacmix-DONE/ - 72dacmix is no good, 72 needs lookup for
  division/DONE - recheck dacmix

[dacmix works only with external pulse ins..., both can be refined]

/////////////////////////////////

thoughts on below - they are already close to bitstreams as they mostly
deliver one bit but we can see how they look more abstracted...

*also with stream model we can switch between streams and mix them,
logical op them, and have differing depths*

- notebook notes: 

[but do we really need?] for modeN idea of generators which keep track
  and deliver bits eg. adc generator, dac, osc generator, impulse generator ...
 - also so as samples can be distributed across L,R,C,N (at moment
   counters are all independent)
 - sample depth independent of length is important 
 
again:
- where the bits come from
- if they come in [according to prob/strobe/toggle/bit pattern]
- where they conme in?
- how/logical ops?

-  maybe abstract out routes in/binroute as the kind of function
   above - test more abstract version...

- impulses

*TODO: entry bit as logical op with a bit pattern (eg.100011101) from another SR!*
how this could work: *we can have a pattern from otherSR or incoming of where/if bits come in*
- if enter bit is an AND operation - we need to cycle bits from other
  reg and where do we do this

** 16/3/2022

*TODO: detach length of SR and bitdepth in modeN/adcetc...* - done to some extent with new generators

** 15/3/2022

*modeN as key*

towards generic treatment of bits from ADC, DAC, oscillator or other function, mix of these/feedback(=DAC?), route in // eg. 4 bits from osc into x length etc...

that we can treat routein as we treat in other SRs or as special ADCin case????

treatment of bits // function(ADC, DAC, OSCetc, routein, mix) they come from // length of SR 

/////

- towards more generic modeN (and other modes) - what are differences in macros (obvious for pulseins/outs we have or not)?

//where bits come from/if they come/where they come... sequential toggles of eg. 1010111 bits in


eg. we use a SR sequence to determine if (1or) we input bit from x. so /if/ is from: prob/comp, strobe/toggle, pattern

also other decisions from bits -> eg. which bits in/....

sequential->ins

*bits in from ADC, DAC, oscillator or other function, mix of these/feedback, switch these - mix/switch*

//////

->  if/prob/strobe/toggle of ->>> bits in from where/and where these bits go (logic of their inputs). eg. multiple bits in...
--> nature of the shift

[where is generic description below?] 

- where is our speed from?
- where do we get bits from?
- which bits
- where do we get prob of bits in
- where do bits come into
- how do we shift?

MODEN: route and DACs in - which DACs we can switch in, different bitstreams to switch...

*if we can abstract out dac, adc and routes in so is like SR bit streams in*

-// also check/catalogue dac modes:

dac:
66: any
67: 4 bits with delay of bits
0: any
1: any equiv
2: any/1bit
3: any/>7
4: any
5: any
6: 4 spaced bits
7: 4 spaced equiv bits
8: any/sieve
9: any/sieve
10: any/len-otherpar
11: any/sequential?
12: any/sequential?
13: any/mask
14: any/mask
15: any

- so we could have more fixed bits eg. 4 bits out, 8 bits out, 12 bits out, regardless of length (so then we should really detach length)...

** 14/3/2022

- *changed adc mode 3 as was same as 0 - check all logics... maybe better group them in modeN*

DONETODO: for adc-> 8 bit fixed modes (12bits and 4 we have),
*TODO:fixed equivalent bits in eg. 4 bits equiv...* then we need to
use length

//catalogue adc modes which have set bit depth(set), variable bit depth(any), restricted to <11 depth(<11)

adc: 
0: <11
1: any
2: any/1bit
3: any/pad 0
4: set4
5: 12 bits always cycle in to our length
6: any
7: any
8: any???
9: <11
10: <11
11: any
12: any
13: <11
14: <11
15: <11
16: any/1bit
17: any/otherpar+3
18: any/otherpar
19: any/otherpar
20: any/1bitcomp
21: <11 *TO FIX*
22: noADC-LFSR
23: noADC-LFSR
24: noADC
25: dac<11
26: dac/onebit
27: dac/any
28: clkin
29: 1bitosc
30: clkspeed
31: TMin
32: *TESTTODO*
33: <11adc/prob - *maybe move*
34: 1 bit osc
35: adc/prob
36: <11adc/prob
37: <11adc/prob
38: <11adc/prob 
39: 1bitadc/prob
66: <11adc mod otherpar
67: <11adc+otherpar
68: <11adc&otherpar
71: anydac
72: anydac
73: 4bitsin
74: anydac
75: adc/daccomp1bit
76: adc/daccomp1bit
77: 1 bit osc
78: 1 bit osc
79: 1 bit osc
80: 1 bit osc
81: 4bitsin
82: comp
101: <11adc
84: comp
85: comp
86: <11dac
87: 4bitsinadc
88: 4bitsinadc 

** 6/3/2022

- *TODO: double samples* so we hit 24 bits long/length is 3-24 then...

- do we already have double length 0-63 SRs - TEST NLdoublelengthDONE

// changed OUTV_ to OUTVN_ in modeN - as we have no pulse out in N!!! only in L, C and R!

- *where are we with extramodes.c and other source files? re-organise all when back*

** 2/3/2022

- *how to think length (again) for modeN and modeC*

modeN:

bit length/SR length - but maybe only for abstract modes does it make
a difference and any modes where we return/prob return, also q bit
length > real12 (our11)

- but at slower speeds there is a difference... (in length but)

** 26/2/2022

- look into 4 bit ADC in: adcetc.h CASE 81 4 bits in - does length change anything? *NO* - so we can detach this...

check basic adc modes - how much length changes things... and how central length is?

modeN/adc: probability of different dacs->

- changed NLcutfeedback86 so is more instant - switch between 2 DACs

check for adc modes where length makes a difference...

16
16 detached
dacspeed - mix of detach...
intspeed - speed and length? cvs free 2x CV...

** 24/2/2022

- fixed new adc for modes in adcetc.h // to TEST

- working through modeN - too many modes! how to make sense of this // order the modes in the file and how these can become more generic


- *TEST*: NLCVDACroute if CV>DAC - entry of new bit from [ADC, route
  or cycle] XOR cycle/route etc... - use what for this choice of
  route - detached - but does as adc or...

N87_4bits_strobein

Nint72dacmix - using dac for mix *NOTWORKING*

*TODO: mix DAC(1)(normed) feedback in - using CV, using DAC - do we have these kind of mixes already? in Nint72 but we could have more*

DONE: list of dacmode in modeN.h// uint8_t dacmodes[16]= { // which use DAC

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

** 22/2/2022

- get back into code and TEST new adc mode 86: cut feedback - eg. cut for CV count clk pulses/on off
// detached mode -> NLcutfeedback86 -> changed so switches between adc
and dac3

- R mode just zero in... (so no RSR feedback): Rnada in modeR.h - TEST

////UP////

** 19/2/2022

- returning to code... define character of each side starting with N, 16/16/16/16 modes - 

modes which use strobe to one side

N: is input and feedback -- RSR feedback//DAC feedback//normed ADC feedback//mix of...

L: passon, route only

C: output and entry?

R: feedback -> N // DAC value...

** 10/2/2022

- noise on adc in seems to be to do with adc mode/multiple bits 

newDONE:
- oscillators (as in 81 tests in adc) few bits repeating which could be pulled in on strobe from income (or from cv bits) - cycle k[reg]DONE as 87inadcetc///

- feedback as in manually cut from in to feedback(norm) pull cable
in software: feedback=dac[2]->adc cut to other dac or adc in or between 2 different dacsDONEabove NLcutfeedback86

challenge of mode N is number of ADCs - less so for modeC


** 9/2/2022

- thinking to re-work noisy ADC to one-shot //
REWORKED but still need to deal with mode/adc DONE - *TEST*


** 8/2/2022

- working in modeN.h to assemble preliminary list of modes there, refining

- added new multiplespeednew - test in modeN

-TODO: test multiple speeds in modeN, 

DONEdetach modes for strobes- 2 cases - need to select arrays of good adc modes and categorise

** 7/2/2022

- DONE:trial basic mode - split length so handles xor/or in - logopxxx has the xor/or option too

- *sort probability and route/bits files* // starting with modeN and cleaning up a bit

- we can have say 64 as mode with no adc in 

** 4/2/2022

DONE- SR in SR again - how to embed one in another properly - with constraints - LLLSWOP

- full generic bit interpreter

- *can use CVL to select dacfrom and also mask in certain modes...*

- *thinking of 0-15 as basic length/speed modes and 15-31 as detached modes*

** 3/2/2022

- fixed speed issues now in interpol code - slowest is around 1Hz with 2^14 octaves scale in log_gen/resources...

- how far did we get with bitmodes? bit.h defining now for modeL, expand and then port!

*thinking about how have whole other path - so feedback is one extra limb perhaps//isolate/un-isolate*

where do we change dactype for NLR?/ C? also is 3-5 bitsDONE - in bit.h - so changes own dactype...

** 2/2/2022

+hit problem with slower speeds and float - fix from test2.c - either reset at 8 or 1024 or reset in ENDER?! test...+

- do we have prob of bumping up local route: in modeL yes

- TODO: generic versions of major modes, start to classify eg. generic version of electronotes with different bits
- routes tagged with NOT/inversion bits

DONEport dacspeed modes from modeN.h // and one xtra one

DONEmodeN: prob modes done, port electronotes and probability modes to L as template

*port from L to R and C maybe new modes* also multiple speed modes are in L - some for R only, some for C
also maybe some new modes across N->

*TODO: port generic ones into R and C from L in probability.h - done for L?!!!!*

- various detached modes for probabilities and generic probs esp. in ADC


DONEcan also have XOR opps for routing tables, where do we get dac/sr from - how to change this, mixes of DACs, all recursions

** 1/2/2022

In modeN (also modeC bit not so critical there) we can't have so many ADC/DAC select modes for each possibility:

so:

- start with 8 total basic ADC/abstract modes in. further mode on Cv select lines only - with probs, other modes...

DONE: prob modes implemented - added probability.h for all sides

DONE: for modeN.h we can select ADC mode (adc or abstract) and use probs, *TEST* probability.h

DONE: port prob_bits mode over to N, added Lintgenericprobx in prob

- added strobe modes in adc/modeN.h - DONE: these could also be toggles toggle entry/no entry

DONEcheck all bit/route options and any implementations

- fixed major bug in new modesL modes - as we already gshifted out the cycling bit

notebook notes:
- DONEin modeN: how to mix between CV control of bits and SR/DAC control - as we need 2 CVs (mix and CV) - detach both (in CV mode or one in intmode)

- NLBURST0: bursts of DACin/ADCin to spawn/seed feedback - so trigger
  means CV length of ADC bits in, no trigger is ROUTEin at otherCV
  speed, +can also be prob of entry vs. no entry/route in - this is already in Nintprob2_0+

- can also be burst outs in modeCDONE


** 31/1/2022

- if binroute and dacfrom follow same count or we move these differently - have 4 bits binroute (16 options) and 4 bits dacfrom (16)

and SR also onto both routes//from DAC - these are done TOTEST - //but what of clkcnt - follows dacfrom/daccount

DONE in L:untether/leave at set speed of entry (also same for length) - run at that set speed but have dac at other speed/cv - see above eg. pass on speed/gshift etc, dac speed*

DONE: port in extra intmodes, 41, 47, 64, 67, 68, 69, 104, 105

added electronotes modes in N


** 30/1/2022

// some DONE from below... question of detach speed or not...

** 28/1/2022

*which way round probs should be?* depends on mode!

+test if we should put speed calc inside loop+ outside as we use in CVOPENing

*again Q of using DAC from 3 when 3 routes in to 0 - how to seperate or did we solve this?* lack of routeins/option of route in...

- DONEdetach length and place assign in headn,l,c,r - TESTed, so we can use CVL if we like... and leave length as is...
- DONEnew mode 82 in adc/moden with incoming bit as comp

- DONEcombine routing and probability modes - to some extent in
  LDACroutestrobe0 but tricky, also prob can be speed, prob of advancing the SR-DONE, or one aspect of the SR-DONE - could be more

new sets of modes where we keep old length and use a new CVL for:
- prob and routings, double speeds/slippage (can also be with DAC), possible triadex mode, how to scale and offset DACs for DACspeeds -  define more of these
-eg. for adc choose adc in cvspeed, dac same, or probs of adc etc... - DONE to some extent in modeN and modeL, modeC for dacsels

- DONEthink how Triadex could use 2 CVs///port to SR

- DONEprob of changing local routing table - in LintDACroute0 and some strobe version in modeN

- TODO: finish new intmodes in L, port newmodes from L to R, figure out calc for filter speeds
  (once we settle on speeds), define all bits, start to organise each set of modes...

*question also if LR pulses in should be XOR or OR? - OR seems better TODO/test/change - or options*


DONE: cycling bit XOR with --> [DACout from own/other SR vs. comparator=CV/DAC/DAC+CV/CLKCNT???] - N84 and some variations

DONE: INTmode: probability mode where CV fixes bits (of prob) and prob is against DAC/SR onlys ???????what means - ?prob is our LFSR - so we fix bits of this one...
Lintprobfixed0/1

DONE: use other SR bits to determine length of SR, eg. can be modded or...  NLSRlengthselL0 and companions

/////////////////////////////////////////////////////////////////////////////////////

*notation system and define/implement all prob modes:*

prob taken from [X] of [Y] bit [LOGIC_WITH] [Z]

eg. TO expand

for ADC:

[LFSR, CV, DAC, SR] against DAC, LRC: ADC_buffer[12], CV, and combinations (ADD, XOR etc) of these - see EN below]

otherDAC, ownDAC

STROBE - invert ADC BIT - XOR/OR routed
       - invert [ADC/xor/or/routed] - NONE
       - ADC BIT vs routed - NONE
       - ADC BIT vs [ADC/xor/or/routed] - NONE
       - ADC BIT vs invert [routed] - NONE
       - ADC BIT vs invert[ADC/xor/or/routed] - NONE

for abstract ADCs we can also have RETURNbit
       - ADC bits vs RETURNbit - XOR/OR routed
       - ADC bits vs [routed/xor/or/RETURNbit]
	 [and inv of 2 above possibly]

for others/L, R, C:

- invert RETURNbit - XOR/OR routed
- RETURNbit vs routed - NONE
- invertRETURNbit vs routed - NONE
- routed versus 0 - RETURNbit

EN: LFSR SR bit is loaded/not loaded onto recycling SR. loading can be random (based on LFSR and set of probability switches). 
*prob is sourced from LFSR ANDed with CV/DAC*

comparators for probability and ADC depending on INT/CV mode

/for prob:
1. if LFSR/SR/DAC<CV  // int mode - as DAC is not necessarily CV!
2.if LFSR/SR<DAC[x]  // cv/int mode
3.if LFSR/SR<DAC[x]+CV // int mode
4.if LFSR/SR/DAC<param[x] // cv mode


** 27/1/2022

try to categorise and clear up modes:

  probability/if_strobe/toggle modes

  ghosts/reflections/walkins

  route modes/bit modes

  what are outs/ins

- how can we detach SRlength as is used everywhere as length?DONE

- ported in all newmodes. 

** 26/1/2022

- thinking on scale/speeds - at the moment we have 0-5v CV input and
  covers 2^10 - so 10 octaves...we want say 13 or 14 octaves - 0.1Hz
  to 5K for 14 octaves/doublings

*can we have knob covering this and 0-10v as 1v/OCT*

*100k instead of 200k for -10v and 33k in loop - as in Tides! (and can we adjust/scale input cv)*

// 14 octs in 1024 =73 per octave =140K of cv in maybe approx... (for 730 max)

http://lushprojects.com/circuitjs/circuitjs.html?ctz=CQAgjCAMB0l3BWcMBMcUHYMGZIA4UA2ATmIxAUgoqoQFMBaMMAKACVwU9wwURCALDz5UIA2lEkwELAIYgUCQp24DsfXt27Zo2EAx16w8ePpgnMkBMQQoU4-Bkgoyk4yZYAnFcIX5foiaQ7D4C3MTKYVIg4vrG0dJeodxoqtxUTvAsAO5+3Mx8isoFUElF-EJqfIKSKLhwLADGCkog6jHt7VQC0JlB-WCMxPoovVZkxC4RkMRqkOTmkKy55SXlNcErrTXlUZstkSn+ezkHMSmtXadVbXw3G9ftNTeapQDmZ2ACQuWpUo8aLgxCI+YIAe0kG3OhHI8UWcDIhCUilqkmwLAhYCQULUCCQSHhMwwSMIKIgGiQ6KAA

or 100k cv in, 23k feedback, and -10v is 70k

- *how to scale and offset DACs for DACspeeds...(two controls - leave length as is maybe)*


** 25/1/2022

- from notebook - DONE:how we could have multiple/split speeds (leave one/length as set and update others on entry?, or use strobe also which maybe we have already)

2x CV, strobe, dacs

1. shifting/SR speed << (but if is not aligned with bitin?)
2. GSR copy speed (own GSR) //copy on strobe? see 37 in newmodes - L3 in modeL - in/outside loop as optionsDONE
3. advance incoming GSR speed - slidings
4. DAC out speed  - slipping

-- porting in from newmodes.c, DONE:4 bit shuffle to come in from modeN.h

** 24/1/2022

- TODOcheck new notebook Qs:

- DONE: added dac comparator mode, compare with itself DONE/TESTED
- DAC as param for some abstract ADC modes (22-31) checkDONE
- all modes have local route in to change - from strobe/bump, from CV. from DAC is already done or? - in modeN, R, L, C tested///DONE
- added Ndacghostincoming0 using incoming ghost for speed in modeN.h
- +fixed speed thing in macro.h a bit/back+ fixed some of adc so can have multiple w (eg. for oldbt etc)
- added ADC choices in intmode: LintselADC_63, RintselADC_63
- added binroute NOG macros to macros.h to test in modes (in all modeX.h): no movement of GSRs....DONE/TESTED

Benjolin style patch: 

R-OSC mode -> N-OSC mode ->L-route in->Nout, R clocks L, L is dacspeed for N and R // multiple OSCs, ADC in L and R... (not in C)

doesn't seem to really work out!

- *modeR/where - change dactypes for 0, 1,2,3 (inc. itself)*, [or intmode in each to change own dactype 0-15 (but no strobe so 3 bits) - but then rest is fixed]
// where we set this? where we reset to defaults... is it necessary to change this


////////////////////

- changed some of modeN to avoid interrupt disturbance for dac incomings

- also dacfrom array is tied to count and gives dac and fake clks... change for new rungling scheme 

- should have array of what we route into - added routeto array with count to use for some Gshift modes

** 21/1/2022

- +maybe makes sense only have DAC speed modes in LR!* else becomes too confusing/noisy and we keep NC as more mode selections and prob for+

- Tested Rdacspeed modes: *problem again is that if we use DAC1 to set it also effects speed of outgoing (unless we route differently 8,1,1,1) but that doesn't make sense*

- added Rmode which bumps on ghosts - variations of this and can also be intmode and dacspeed mode


- DONEghosts of ghosts - strobe records a ghost of incoming ghost and holds this till next strobe/advances it, records new one, holds for length time?

TODO: when we use dac this should be from a table which can also be bumped around by modeR *dacfrom* which also uses/matches count or should it be otherwise?
DONE- but we need to test this thoroughly - clkroutes also follow the same logic

** 20/1/2022

- last of all intmodes selects type of ADC/DAC (except those which use strobe or use param). For LR selects functions with no params or strobe/so no intmodes

- fix for pulse out on C1 (bitn initialised as 0)

R- for CV modes add in bump up global routes, SR as global routing table

L,N,C - // for CV modes add in bump up local routes, SR/ghostSR/DAC as
local routing table - we have some of these in modeN to model from, we
also have a CV intmode router there

- we can also have modes in all cases which use (mix/xor etc in) their own ghosts (as run by the following SR)


** 19/1/2022

*question of 32/32 split of speedcv/dac // int across all modes as gives more param control

- routing and dac control is most important, also which modes use strobe and which not

*question also is if we use right DAC for lowest fake clkin - this also feeds back in to top when it is running:*

- *wider question of multi functions of right hand dac and how this could be otherwise: functions as feed through, as fake clk, as dac feedback input*

--- answer is maybe to have different dac options (where we take from) set in modeR

Still working on modeN.h modes:

- DONEput generic one back in so we can do ADC+DAC opsDONE - to fill out in modeN - what variations do we have? 7 bits

- route could also be N->C N->L L->R R->N which is 8,1,1,2 test

thinking also how it could be to have 2 speeds - one for entry into R feedback and another into L, DAC:

so 2 branch speeds??? how could this work??? depends on routings and if we mean primary speeds then we would need to run one SR twice



//////////////////////////////

how to choose modeN modes now...

we have:

*- 16x or 32x CV modes*

DACin makes sense with mix or is just like normed feedback - but interesting if we can change type of gate[3].dac DONE Nint70

0-7adc basics with XOR

other ADC in

strobe ADCs in

abstract ones

DAC/ADC mixes in

*- 16x DAC+CV to work out -> what makes most sense?*

0-7adc basics with XOR

*- 16x or 32x INTmodes all must use CV! we have too many*

prob modes
special modes-params eg, route, selects

/// *or shall we have 32 INTmodes and reduce CV modes*

//////////////////////////////

- DONEin modeN.h but need to check all/fix modes: for modes which don't use strobe we stop normalled clock and use strobe pulse as input - try OR or XOR
- check if is inverted - is interrupt on falling edge so not inv

*question if for modes which use DAC in ADC if we should NOT route in DAC or at least have both options - tested in N27 and can work/run out*

** 18/1/2022:

TESTED on 19th:
//*TODO19* - retest 6x, 10, 12*, 13, 14, 15, 16*, 18*, 21*, 27*, 35, 36, 37, 38, 39
//-  new ADC modes: 71, 72*, 73, 74,-DAC ins have tendency run out...
// 66, 67, 68 to test-DAC

//- +XOR strobe = 80,81,82,83,84,85+ - now we have strobe scheme so we don't need add modes

add new ones from adc_ into modeN TODO

////////////////////////////

*what are the basic ADC modes?*

-7 here:

  case 0: // basic sequential length of upto 12 bits cycling in MSB first    
  case 1: // equivalent bits: we don't need limit on number of bits
  case 2: // variations on one bit audio - also phasey
  case 3: // basic sequential length as in 0 but with padding if >11 bits **
  case 4:  // special case for spaced bit entry depending on length
  case 5: // basic sequential length of upto 12 bits cycling in - can also be xbits from param, max bits etc...
  case 6: // padded version of SR of bitsin ??? - now is 6 - was 8

- +generic ADCg_ function to implement/TEST (as above) but mostly keep other ADC+ = we get rid of as is only useful for DAC which we have - add modes/MSB there DONE see above

- new ADC_ cases +63+, 64, 65/also int65, int66 tested - 64 not so exciting.
- tested/in progress adc_66,67,68: ADC intmode various mixes of ADC incoming plus/modulo/etc/XOR CV[0]*
- tested: ADC-prob can also be against DAC rather than LFSR - but always CV against - Nintprobdac1_0

- TESTED: in progress: can we have one intmode with CV selecting non-param ADC input modes, can have another mode list or shorter mode list with route bits

- TESTcan also have mix of dac[3] and adc in cv adc_ modes... 66, 67, 68

///TODO:

ADC modes: *prob of entry, prob of return for abstract modes* 22-31 and some others now/new ones... in modeN.h

- theone, it.c, draftdec, extramodes to all be checked for adcmodes, see also temp.org

/////////////////////////////////////

- *for LRC modes we can also have prob using generic top ADC_buffer[12]*


** 17/1/2022:

- DONE: inverting CV for param/int modes as now 0 is top TODO! DONE - to test, but not all work so, changed, and do we need to invert for prob intmodes? no

TESTed/ok dacspeed from itself - Ndacadditself - can also be other variants


modulo LR modes to code/test - done in Lmod and Rmod

TODO: define probability modes, define all bit patterns, ADC modes from all files inc. extramodes, 

prob modes for ADC/ignore cycling:

- invert ADC bit -and- xor/or in routed
- invert [ADC/xor/or/routed) 

- select ADC bit in or routed in
- select ADC bit in or [ADC/xor/or/routed)  

- select ADC bit in or INVrouted in
- select ADC bit in or INV[ADC/xor/or/routed)  

for others/L, R, C:

00 1-TM invert cycling bit - OR with BITIN (OR (routed^pulse)) // OR (routedORpulse) ??
01 2-BITIN or loopback
10 3-INV of above
11 4- BITIN or not into cycling


bit patterns: 

-- where we get bit from=routing, subjected to type of SR inc prob modes, what we do with routed in bits

still LR modulo to test: https://github.com/TuesdayNightMachines/CGS-Serge-Modular-Synth/blob/master/CGS%20Modulo%20Magic/CGS%20Modulo%20Magic%20Guide.md


** 13/1/2022:

- HEAD macro should be fixed but check this DONE
- methods for DAC speed modes: (and now we use CV[w] instead) -> we have now in modeN, to test and to port to other modes TESTED bit *maybe no addmax*

** 12/1/2022:

- dac+cv modes to resolve with new scheme - a lot depends on where we get dac from (cannot all be same but nice to choose - 4 options = 2 bits)

TODO: ADC_for_our_speed - top bits//rest bits as speed/mod for DAC? - DONE in modeN but don't use there

test adc pointerDONE, fill in modes and testings->ADC, DAC, all modes from draftdec, theone, earlier... 

FIXED bug in macro as HEAD CANNOT BE within another macro...( note -E is to show macro expansion, do we need to fix for modeN.h macros?)

1 bit audio is still odd - and length does nothing here *again length issue in adc and adc* - *re-test*

- question of slowest speed as we already have 2^10 for 5v (0.5v octave)

** 10/1/2022:

*TODO: test best fake clk scenario - later when have tidied and basic outlines*

test trigger codeDONE, test multiple ADC and DACS, new macros

problem with init of function pointers from outside file... -> pulled function pointers out of the struct and all fine now, we init them in draftspeed.c

** TODO: Latest notebook notes:

- bump speeds (clock bumped speeds, clock shifts it on one, CV bumps in INT modes (HOW?) )
- bump own routes by trigger (do we do this?) yes in case 16 in draftdec/port!
- more DAC driven routes, use of SR bits for routing/what else, more of RH
- modulo - how that would work? one SR/DAC modulo another?

** 9/1/2022 +:

- DONE: no speed more than 1.0f - how we generate this? increase main.c speed accordingly

xx=numpy.logspace(0, 10, num=1024, endpoint=True, base=2.0) # num is now many we want // in misc/log_gen.py

- simulate fractional speeds and testDONE.

- interpolate or not? as in just keep last value or interpolateDONE -> INTERPOLATE

- draft new structure mode: what we need here... we will need to
  change trigger codeDONE/tested, clkoutsDONE/tested 

- will need clean up all but just test now...

we changed dac out but will need to change adc for pointer as some modes change it in place...DONE/to test!

TODO/DONE/TESTED: we also need to include stop! in speeds - even now for C modes...

- Right and Left are now seperate 
- Right with mode DAC action, more influence. character as routings, DAC and feedback, other INS into right side too (can be more TRIADEX style_
- do we only use DAC2 as out so this can be incorporated...
- jump modes << or slow down, out per every x shifts... 


* diary sept 2021+

PLAN: put first draft together
from generic we had all modes/options as:

6 bits: 1 1 1 1 1 1
- top bit/speed
- 4 bits routing in
- 1 bit prob of inversion

incoming bit bits summary (4 bits) - eg. prob of:

- pulse (if we have) (1,3)  3 bits- mod below?
- routed in = all - 2 bits still - none, route, route/loop, loop
- return/loop = all
- ADC (0) - 3 bits for 0

route in and logop bits:
1111 4 route in bits x 3 logops = 2 bits per... 0, none, 1, xor, 2or, 3leak = 8 bits = 255 too much for CV


trial bits:
pulse/cv speed, input ADC/LFSR/no, output DAC/else?, type SR, type SR, type SR(3 bits of types=8), routing from (4 options)  
1               1     1            1                 1        1        1                           1 1 1 1 - 4 bits just to make it easier but could be less
[11 bits]

speed from DAC/which DAC?

*\\\\\\\\\\\\\\\\\\*

- idea for 1 or 2 versions with different modes... also why generic version is silent on early/first modes - no incoming bits or loopback/fixed
- or major/minor modes from left side???


*QUESTIONS:*

- lengths and changes
- major/minor modes from right hand side
- OR into top/ADC
- generic logics/ all/ logic bits

- if each SR is quite different? or stay generic? ADC and DAC are
  already different, maybe LR should be or can also be swopped,
  re-routed, more routing options on those sides perhaps as extra
  modes

L as delay/entry, R as feedback and DAC - what makes sense for each?

but then ADC and DAC become just about input and output??? ADC in is fine (but we need options to OR in sometimes for pure ADC style modes...)

// re-check generic bit options above

- resolve split personality of patterns and cv//audio filter/crusher (split of modes at top cleanly? or but then what of speeds...)

TODO: re-test ADCs, *fill in CV/DAC modes for DAC and decide/port new LR modes*

[possibly reduce volume of final dacout amplifier as is 10vpp - but leave so!]

2/1/2022:

new approaches: function pointers, try speed scheme from WORM so also oversampling  and interpolation - draftspeed2.c

trial with oversample etc (now divider is 32/32 or 32/64)... seems work fine but we don't get slow enough for CV speeds...
(for cv/dac modes - but that means fullspeed pulse modes will be slower by default??? or we slow down cv modes???)


how to implement function pointers...??? as bit selects???




/////////////////////////////////////////////////////////////////////////////////////

31/12/2021:

- back to testing with OR in on ADC modes (*use XOR for logical/nonadc ADC in modes*)

- tested all ADCs and DACs now - DAC section is a bit samey...

- if we use DAC3 for DAC modes input in ADC is very easy for feedback to run to 0...

    // maybe lose just cycle mode

30/12/2021:

TODO:
- DONE change default dac for all except w==2 to simpler (but we can't just & 4095 for shorter lengths)

- ONLY works for some so removed->try OR in of RIGHT side to top (logic in routings) - in mode 0 and ADCDACETC macro, add to ADCONLY
[OR in at top gives more natural effects but fails too many times - how can we keep as an option? with bits, as one ADC mode]

- DONEtrial of another approach to fake clocks (but would be better as own ghosts???)

question if right hand has more limited trigger or toggle modes

again clash generic LRupdown and more individual...

8 or 12 bit spacers CODE at home

- DONE: bump and toggle routes via trigger as LR case 16
- modulo? // addition of overlapping registers

case 19 to retest on 0 for incomingsDONE

looking at generic code and inputbit there which is not used - more suited to patterns/abstract

resolve split personality of patterns and cv//audio filter/crusher

generic: topbit is speedfrom, 4 bits route and 1 bit doit as prob mode or not!

29/12/2021:

- clk is now HSE and should be 180, we run with 32/16 divider and seems fine
- other small changes and fixes

28/12/2021:

- speed seems to be a big issue now...// how to speed up?

- but there will always be a slowest round of options so doesn't make sense just to speed up some of it if not all

-2. what is in main interrupt loop?
-1. how fast are other interrupts
DONE-0. are we running as fast as we can 180MHz or so... clk is now HSE and should be 180, we run with 32/16 divider and seems fine
1. not execute all DACs but just use SR (and what of shifting? - we simplify to new mode 66)

2. different structure so all in one go w0-3 and slow down all...
3. faster ADC, different structure//one by one? what does sampletime change?
4. generally faster codes, ifs, swicthes, leave out some things
5. check speed of generic code
6, mix of slower and faster modes
7. idea of major and minor modes still and mix between and how we can achieve this...

issue in general to resolve: 
- length as parameter for output (then we need to fix on length as 12/DAC or ignored, or CV so that parameter can have different functions in DAC).
- arbitrariness of modes and positions (L, R etc), again question of being between generic code and very specific modes...
- fake clocks

// also fake clk for lower sometimes gets stuck

- still working/testing ADC and DAC!

- confirming that for straight through length (above 11) doesn't change anything (also length of left pass through) - becomes one long sr

- re-check paddingsDONE- doesn;t seem to effect much as we still have freq of padding?

- how 8 or 12 bit spacers could work

// some problems programming, also had to slow down main.c TIM2 to 10 prescaler - not sure why?

26/12/2021:

- think in ADC of reversing for MSB or at least doubling a few modes - we already try a few, also think more about size and padding

24/12/21:

- think steppiness is from nature of SRs, implementing few other adc, dacs and also MSB dac for MSB first out so is first in and gets shifted right
- sigma delta also makes sense so phasing i guess is normal


*- how to get 8 bit spaced out from DAC?*

- thinking length for L and C is not so active but depends on modes, speeds and what they are used for...

how to have that extra no route in mode for Right side - just leave it in as there are enough options

23/12/21:

still need to test all ADCs and think on steppiness of DAC

*add more binroutes///*

[- add right hand mode 0 where it sets own GSR to 0! so no feed through...DONE/TESTED fine...but skews modes/left in anyways]

Run through of ADCs:

-  length-11 was correct

- mode 2/one bit audio ADC still has phasing despite a few changes...

- fixed dac mode 0 for shortest one bit length - still steppy and added one more dac mode

[why doesn't length of intermediate SR change much/anything - changes nothing if run at same speed // because gshoft is always new]

22/12/21:

-ADC remove cycle and replace with no pass thru//finish DONE-changed modes 0 and 1 for ADC!
re-ordering ADCs but re-check which ones need parameters - put param[0] for all...

- drafted minor/major mode structure in extramodes.c

TODO: re-test all ADC or/esp11, classify LR modes

- for INTMODES: how many speed options here? just keep as pure option so can have 16x INT modes and 3x4 DAC


/////

-removed case 15 from adc cv modes, 10,11,12,13 strobe modes as also boring

thought of only having 16 adc modes but makes no sense for routings - back to 31 but re-ordered and need to re-check params

7-13 are all strobe modes, 17 too - reduce number of strobe modes

15,19,24,25,28,29,33,34 not in CV modes

ADC group by:

-type of input (ADCbits?, LFSR, clock etc)
-strobes/otherparam

Important adc: xbits, one bit, 4bits in (case 16), padded + LFSR etc...


21/12/21:

- check each ADC/DAC in turn - note that modes in adcetc.h don't match the case!

ADC (0-19 now):

TODO: new adc with x bits ADC in subjected to LFSR - doesn't work but added versions of these

0 should have adc in and another mode no in with pass through so all 0s still runsDONE

tested up to 11 (12-19 todo), fixes trigger as static/is it needed?NO/replaced

DACs:

DAC: 2 (is a bit muffly at long lengths - can change divy to fix this in resources.c) RETEST

mode 18: toggle is more exciting for 11prob mode/// whether to change that toggle in LR modes? we did!

changes to case 10 in dac, 11 doesn't really work - replaced with 9, and we had to add missing param[2] in draftdec


///////////////////////////////////////

- DONE: added in normedd L,R,C clocks from Cspeed2 - using new count5 - seems to work// *can also have LR as DACs?? maybeDONE-TOTESTwithINTMODES*


- idea of major modes on R (say 4) - for different ways interpreting bits // different probs // as we have multiple dacs 

// base some on generic but we need to fix 0 no routes/in to default to 1

but problem is we cannot mix and match these... and we can kind of implement similar bit interpretations anyways

TODO: 

20/12/21:

0-15 filled - to test ADC and DAC as fixed and also all modes to find weak points
15-31 modes to fill and rest to figure out this week!

////

- grouping early strobes

proto for SR>DAC is: if ((LFSR_[w] & 4095 ) < dac[LFSR[w]]) // as that is 12 bits and shifted already 

change/d all modes in extramodes.c to use the dac[LFSR[w]] above rather than SR or both & 4095 but if SR is small...


which strobe=prob modes work best with DACout 4x4 in modes 16-31 // we use 00 and 11

4 bit mode works well but does it always need to coincide eg. all 4 bits - seems fine

- fixed bug with many [x] and not [w] outside loop 

- TODO-   // 4x4 bits prob of routing in GSR  so we need 4 probs of x bits?
- DONE: decide/ if implement simultaneous shiftsNO! stick with old one as seems most logical and we don't change order...

16/12/21:

- DONE: probability of advancing a GSR - as mode 14 test 

- DONE/not working as no entries...x bits of sr << y bits of gsr - shifting bits ORed in as/to new SR

15/12/21:

- // can also be change access bit but not cycling bit - also cycling version of this! TODO!->DONE/TODO: mode in which CV/pulse changes which bit ofghostSR we access - mode 13 works fine	
- TODO: also test with CV access for these bits

14/12/21:

- what are 4x4 DAC modes for 16-31: 1cycleandroute, 2/3probs, 4-4bitshuffle? - see temp.org for modes list

- TODO: probability of advance on trigger using CV as probDONE-tested

- organise modes we have in some kind of scheme: 

speed
incoming: routes, manipulate ghosts, change routes, basic routes
what we do with it: prob modes, where we get prob from, what logic we use and where we get choice of logic from?
special modes

or group by way of: strobe in cv, cv in intmodes ???


13/12/21:

- trial of changing way it updates = if new[w] - not sure which to use

  // testing for simultaneous shifter - but what of modes where we hold back the gshift eg. modes: 37, 48, 49

- DONE/TODO: mode in which CV/pulse changes which bit ofghostSR we access - mode 13 works fine


10/12/21:
- re-checked logic of ghostSRs and compared in test2.c

- question of order of SRs (w) - trial changes to tables of orders // test2.c first

// order does of course make a difference/depends also on routings

also how we can update/calculate simultaneously (how this works for feedback, or is a delay necessary?)
- more is that all runs at different speeds///

9/12/2021:

TODO: list regular and extended modes!

- added toggle/pulse prob modes 7,8,9,10,11

- added mode 12 with non-adc ADC_ in to LR - 3 diff possibilities:
  ADC-5, pure LFSR on length, 30 1 bit OSC, 32 clock/square (these
  could also be bits or bumped toggle options)


8/12/2021:

- *manual idea - we have say ascii layout on dot matrix and then subject this to shift register*

- moved the if (w==1 || w==3) // if pulsins[w]!=0) out of the macros as most of the time we don't need to test this - this is now LR[w]!

- for pulsin not so much difference of XOR, OR and we lose AND for zero pulsins... so leaks or xor it is and leaks needs changing probabilities

we try now with own SR as probability and this seems to work well for pulsins

?can also use GhostSRs for probs?

- trialing 2 different bit interpretations in draftdec - DONE

- if LR can have non-adc style inputs (eg. LFSR, pulses, clocks etc) XORed with incoming routing - how many options are here?* DONE
- this could be an INTmode!

- basic prob mode of entry of routed or not (into cycling). and just xor puls in...DONE - mode 6

7/12/2021:

- attempt grand mode with SR and many bits above - we have 8 bits route and logop and 5 bits probability DONE

- in ADC_ added cases 33 and 34, adc prob modes with adcpar (invcycle is more like ADC mode if is without routein)

- TODO: generic prob/strobe/toggle modesDONE

6/12/2021: 

- fixed major problem in MACROS draftdec // if else...
- one bit filter DAC always now has param and is mode 2 - so param can
  be cv/param for variable filter or can be calculated from
  speed/param

3/12/2021: listing modes in temp.org to plan out and also check gaps: conclusions:

how we can temporarily fill modes and change these later? macros but then we have \ always end of line to think of and no comments. maybe...

- question also of modes with global route table or which manipulate their own routetable

*we need more modes which take cv or dac and use this for routing, for probability tables, for logops*

- summarise again probability modes and all modes/cv/INT: = we have too many

32 CV modes, 16 CV+DAC modes, 16 INT modes (very basic and prob driven)

1. basic pass/cycle/passandcycle with logops for cycle and for bitsin

3x logops: xor, or, leaks...

1-pass in - xor pass, xor puls
2-cycle only - xor cycle, xor puls
3-pass and cycle - xor pass, cycle, and puls

4-xor pass in and or puls
5-xor pass in and leak puls
6-or pass in and or puls
7-or pass in and leak puls

8-xor pass in, xor cycle and or puls
9-xor pass in, xor cycle and leak puls
10-or pass, or cycle in and or pass
11-or pass in, or cycle and leak puls

// further permutations of these or just leave to CV/param bits for logops

2. prob modes: 

- where we get prob from. CV/int, DAC/cv&int, DAC+CV/int, param[x]/cv

prob<DAC:

1-inv routed bit/ xor puls
2-inv cycled bit/ xor puls
3-inv routed and cycled bit/ xor puls
4-inv routed, puls and cycle bit
5-inv puls and route in

6-xor cycle in with routed or not

limited selection as above with prob<param

less of pulsins and probs as gets too much

- prob of: -invert incoming bit (ADC/mode0/routed, cycle or pulse-ifwehave) or not
           - XOR bit in from->[cycled//ADCorLFSR//pulseifwehave]->routed in or not
           - incoming bit(routed,ADC,pulse-ifwehave) or cycling bit
           - as above with inverted cycling bit
           - changes/manipulations to the ghostSR

3. binary route/prob/etc. tables - CV as binary route/prob bits/

look again at binary routing tables and prob bits

4. experimental/overlaps/other functions 
5. use of strobe in cvmodes - doubles prob modes

so strobe can toggle or straight do: invert, XOR incoming, incoming or cycle, incoming or inverted cycle

6. use of CV in intmodes // these are probmodes so other uses

7. change global routings
8. maniplates of GSR // GSR on prob, on strobe

modes to add:

- clock101010-DONEinADC32
- toggle ADC entry or pass (0)... check in adc? ADD in modes
- where do we add prob of ADC entry bit - in mode itself - but this doubles up modes//how to deal with that
- prob to shift binary/routing tables

2/12/2021: 

also pulsin_logop  - placed pulsin within adc macrosDONE
and logop in routing (below) 

ghostSR manipulationsDONE

[[[what those manipulations could be - freeze itX, freeze its lengthX, reverse it - but how to reverse based on length - reverse lowest srlength bits
in draftdec, XOR it with SR DONE -> these can also be for circular routes too

1/12/2021: now draftdec

- *logop in routing too*

summarize: TODO: draft all modes in draftdec but we need 14 modes for DAC (lose 1=mode9)  and 29 (lose 3=modes15, 31and19) for ADC, fill in LR modes for these and test

but possibly mode prob modes in ADC or keep these more for INTmodes? think about

but we don't delete them

- check clksr in adc/dac, clksr is in ADC_ = 19, in DAC_ is 9 sieving out  - maybe dont use clksr/both or use clksr more in LR modes

prob for DAC modes, range of clkin params (how to measure?), 

manipulation of ghostSRs: -> eg. from seg2.org: - XOR whole ghost reg shifted by another into itself
 
- TESTED:full test of latest prototype: audioadc?, ADCsX/CVX, DACX, clkins, pulsoutsX, pulsinsX!

30/11/2021: 

*- probability modes for DAC modes are important*

- 333 and 334 tweaked and working, need to watch that we have GSHIFT already in ADCETCblah

29/11/2021:

*ADC_:*
- otherpar modes: 24(len), 25(len), 26(comp), 28(prob), 29(len), 30(lengthforosc), 31 (lengthforosc)
- REGG modes: 2/lfsr, 4/lfsr, 5/lfsr. 6/DAC. 11/lfsr, 12/lfsr, 13/lfsr, 19/dac, 27/lfsr, 

*DAC_:*
- otherpar modes: 10length, 12-5bits, 13mask, 14mask, 15beta 


for otherpar as len let's use otherpar=otherpar&31 rather than >>DONE and we restrict in all cases &4095

all otherpar assumed as 12 bits!

- that we don't need seperate modes for int/cv in adc_ or dac_ as they all use otherpar... we just need to decide which modes...

add modes 15 - param as bits 

MAJOR question is how we can constrain param as INTcounter to be 12 bits - DONEwe need to get an idea of range of param as we treat as 12bits? - param[]

  // crash detect ++ 32/64 in main.c is 14KHz //and/or speed check... we have 32 16 which is 4x14=56KHz

so TIM2 loop is 56000 per second - one second is 56000x2// count to check

1khz is 56 - rather 120 or so...

100hz is 1280 so for 4095 12 bits we have 25Hz

we need to constrain to 12 bits for otherparDONE


TODO/DONE: - modes which manipulate the ghostSRs! - what those manipulations could be - freeze it, freeze its length, reverse it - but how to reverse based on length - reverse lowest srlength bits


26/11/2021: 

- new additive test mode in draftnov.c to test and expand...

/////

18/11/2021: 

QUESTIONS:

- 0-31 all ADC modes - as loopback doesn't make so much sense, only thing would be probability which could be part of modes

(probability of entry or not of ADC bit) - doubles ADC modes though?
these make more sense in INTmodes (also where we have no strobe modes
so this reduces list)

arrange and organise

- again if we don't use redirection of LFSR[reg] then in some ADC modes - how we could work with this//? or replace with reggDONE

17/11/2021:

[fixing some of generic.c for performance use]

Question of max length bits in or padded bits in ADC

- where we also change logic of incoming pulsin bits? 

- test param in DAC for one bit filter/BETA - DONE DAC mode 15

start to fill in draft modes/organise ADC/DAC modes...

16/11/2021:

- shift x bits in/shift Gshift round DONE mode 67 in theone.c

- tested speed with clk and is fast enough so far (re_check after all switch/cases) - can even go faster:   TIM_TimeBase_InitStructure.TIM_Prescaler = 8 ???

- TODO: fill out adc/dac modes in new draft, 

- maybe port in more modes from it.cDONE

- and also maybe deal with ghost tapsDONE

  // try putting LFSR feedback into smaller coggSRs - mode 62 TESTED

- added  case 64:// as 63 but we try INTmode with CV changing length of incoming routes

65 with strobe as barrier DONE

- question of generic/global routing and feedback into itself????? 	if (tmp&0x01 || x==w){   // if we want self-feedback in route whatever... MAYBE
and/or variations of this?

15/11/2021:

- for all w==3 modes except route changers we need to set count back to 0

global routings:
INTmodes: CV as route (CV cycles through list or changes list then binroute would change) + fixed new routes

CVmodes: trigger bumps up binroute + fixed new routes, trigger toggles altroute/regular routes (also prob?)

DONE: fixed otherpar and strobe in DAC...

TODO: port in first it.c modes above// first a few attempts in draftnov

13/11/2021:

- case 59, generic routing with ADC working // test in case 59 w==3 global route changes...TESTED - in case 59 and works ok...

60 very generic routing with MACRO fill in/ 61 speedCV complemented by trigger

- check out macros with variables to throw in - test in case 60 now but possibly too generic or we need to add probabilities...

QUESTION of how to manage modes now - first finish ported in modes/all modes // check logicand then start to see how we can draft modes...

12/11/2021:

- case 58 approx generic mode is workings

- leaks using RSR is a bit odd, but we can have different leaks which could LFSR...

11/11/2021:

- thinking if to have global routes or just individual changes to
  routing table? could have global if have say 4 R modes multiplied by
  4 route modes for each section... test global routes...

- not to have several ADCs in/no multiple DACs - but still keep basic dacs for 12 bit length

10/11/2021:

Q is of a new structure

- LARGE notebook notes: possible to use Rmodes as global modes for:
  global routing changes, +multiple DACs out/mix+, +potential several  ADCs ins (in different modes)+. 

  In CVmodes we would either have fixed modes brought in or param, bump
  up routes. In INTmodes we could use CV for modes.

- probability also to bump/shift or otherwise modify routing/logic etc. tables (single or global)

prob mods bits/masks bits

defroute is the one which we use generally now - unless we are in multi-routing
modes? (or DO we make this global default, but is much slower - think about)

pass/cycle/cycle and pass as routing only

////

- TODO/some for finals: more param[x] modes perhaps, 

different speed options for projected CV+DAC modes 32-47, 

new prob modesDONE, 
check bit routings againDONE and added for testings new bit modes (bits for prob and logop)DONE

try out new routing (eg. bounce back)

can add more mixes in ADC (adc in/lfsr/otherdacs/mult dacs etc)

- removed intcnt but need to fix triadex mode 35 - q is what is range of param? FIXED

- added logopx which can just return our bitn

9/11/2021:

- possible multiple ADC in modes,,,, 

- added case 30: adc |(xor TODO) with length of bits, for INTmode this can also be CV-param

in ADC_ otherpar can also be CV for intmodes

- expanded ADC_ function for extra params but should decide on how many bits for otherpar (dac is 12 bits so) and then fix length/restrictions there

- added logic table bits and fixed leaks in logop for modes 25 and 26

- notebook notes: ADC bits choose: what is compared to what, what is source...???

- one INTmode for ADC/DAC could use CV to select 1 of 64 modes - but
  then we have problem of otherpar being different sizes, sources
  eg. from strobe, for len bits etc.

- mode also (maybe INTmode) to select different DAC modes for LRN too!

- to think about/test multiple DAC outputs - additive, sequential, what else? and how these are signalled...


8/11/2021:

- how to expand and contract routing for each SR. what is contracted=just-to-itself, most expanded= last one..., between=

long routes would be n-l-c-r-n

Q. of whether to have extra ADC/DAC modes available as CV options on 1 or 2 INT modes - see above - would also need to be another long case/switchDONE

- INT modes need to use speedCV (see list in notebook)
- so the 16 INT ADC/DAC modes need to use CV
- added modes, ADC prob mode...

6/11/2021:

- toggle/record/keep frozen bits and keep these ORED with the shift register as it cycles or does whateverDONE now as DACmode 15-TEST!

5/11/2021:

- reverse SR modes - 42 and 43 DONE 43 is not so good/reverse cycle round/// try combine with 42 -> 44 DONE which is better

- toggle/record/keep frozen bits and keep these ORED with the shift
  register as it cycles or does whatever - testing now as DAC but it
  should not mask itself???

4/11/2021:

- question also if we use dac[3] and this also does feedback in - maybe try dac2 or dac1

- also if we make use of dac[x] where do we set this to be other_than_default otherwise we may as well use SR instead (except in multiple dac mode)

//TODO: fix on multiple DACs and which DAC or SR we use by default for each SR...

- DONE: fixed param in DAC so we set par=param[x] or cv in the case! but we need to remember to always add this if need be!

- DONE: changed DAC_ with extra params, added ADC speed and comp modes, some work on DACs, seq DAC not so exciting...

- bit length can also be CV - how to put this in as DAC is quite fixed in macro

ADC modes:

- that we can use param other than LEN for bit length in some of ADC and DAC modes... (eg. CV also as param in INT modes with these)DONE

so we can have standard 12 bits (len==11) adjusted to length, full
length (whatever that is) regardless of len, and xbits from otherpar -
in these cases length doesn't do much...

DONEpadding for seq adc, dac and strobe/adc modes 

*basic routing modes:*

- route in from sr[x] 
- cycling bit
- LOGIC (or,and.xor,leaks) - route in from sr[x] and cycling bit // xor one would be rungler in adc mode with dac from other in, or would be CGS

and LOGIC of pulsins

TODO/check: *all classic probability modes:*
classify:

[prob modes for ADCin/w==0 prob of entry of bits/vs cycle etc, DAC modes can use regular prob mode]

prob to DO:
invert cycling bit (TM)
invert incoming bit (ADC or route or both)

take incoming bit (ADC or route or bothLOGIC)/OR/xor it with cycle bit (RUN)
take incoming bit (ADC or route or bothLOGIC)/OR/LOGIC it with cycle bit

incoming bit(ADC or route or bothLOGIC)/OR/cycling bit (EN/WIARD)
incoming bit(ADC or route or bothLOGIC)/OR/INVcycling bit

////
TM: cycle bit is noise vs. comp less than 1, otherwise invert cycling bit

RUN: ==not prob mod but could be made one: XOR cycle bit with input bit which
comes from oscillator [in benjolin the DAC out effects some parameter
of both clock and data] eg. DAC effects speed/clock of SR

WIARD: noise/comp selects new input or loop back/inverted loop back (jumper)

EN: LFSR SR bit is loaded/not loaded onto recycling SR. loading can be random (based on LFSR and set of probability switches)

*comparators for probability and ADC depending on INT/CV mode*

/for prob:
1. if LFSR/SR/DAC<CV  // int mode - as DAC is not necessarily CV!
2.if LFSR/SR<DAC[x]  // cv/int mode
3.if LFSR/SR<DAC[x]+CV // int mode
4.if LFSR/SR/DAC<param[x] // cv mode

can also use comp clksr_ as SR, and adjust routing of SR for comparators

/for adc:
compare to: CV, DAC, CV+DAC, to clksr_, to param - feed these into otherpar

could it make sense for DACs? DAC could be shifted by CV or by clksr_, other DACs.

CV modes which deal with CLKIN - as a bit // - as a condition // - as a PARAM

- clkin in can toggle entry/no entry of new bits, cycling etcDONE do also for ADC
- clkin in can bump up/shift left/right the routing table, speedfrom table, logic table, dac/adc table?
- clkin in can mask bits as for DAC etc. or SR etc - if we pull it in to a SR for each of N,L,C,R  but bwhen do we do this as can't be in INT
- clkin in can also slip/slow/bump up one CV speeded SR = slip, freeze or jog SR on CLKin

*how we use CV in INT modes (as we need to use it):*

- as comparator for ADC in (and for DAC?)
- for LR modes: as comp. for prob modes, to assign routings, as extra mode selector
- as modifier for CLKIN speed-divider?

3/11/2021:

- DONE: more macros but still need to test/re-test all

- if pulseouts should be after shifts ??? guess so...

- in ADC: why (length-3)? to get down to 1 bit so could also have option for full bits!

- tested speed/stop again for all modes? - TO IMPLEMENT as makes sense
- fixed case 3adc and case1dac so we can have as many bits as 32 for equivbits setupDONE/TESTED
///
- incoming clk bits as further SR in main TIM2 loop (question of speed
  of this now) - or do we just do this as ADC inputDONE but could also
  be custom oneDONE - use also as sieve (case 10 in DAC) - what other uses? as comparator for ADC in?

- strobe or copy clksr in // as adc option... question is how to strobe in - on a counter/length? added as adc case 19

maybe list the SRs that we have available...

shift_[x], Gshift[x], LFSR_[x], ADCshift[x], ADCGshift[x]??ghostforadc/strobe, GGshift[x], clksr[x]

how to swop between relevant ones?

- probability modes can also use DAC, clksr etc,,,  what we compare to what???

LFSR<CV(most), LFSR<DAC+CV (17), LFSR<DAC (18), LFSR<PARAM (19)

also maybe more use of comparator with these in ADC mode

////

- start on first 16 modes/check all ADC/DAC options

- tested speed/stop in case 0! add to templates
- new full 32 bit ADC mode with padded bits in - also add strobes and other ones using this 

2/11/2021:

bit entry SR (from each CLKIN) can also be used for TRIADEX style thing,

all SRs/and CV can select routing/logic/speed bits

ADC could also be used in probability modesDONE

templates for speed/dac modesDONE/, INT modes but also how we deal with split of modes for DAC/ADC? (if...)

test new speed options!TEST!DONE!

////TODO:

- TODOs from theone.c - eg. extra DAC modes but now we have too many modes/cases,,, maybe to simplify

LIST MODES so far! and notation of modes

- what modes we already have implemented? also what ADC/DAC - plan to finish/draft?

- feed back RSR could have stop/no motion at top of speed (but how to do this without an IF clause?)...

/////

TRIADEX notes (from below etc):

- in original: any of SR bits (from any SR), CLK and its divider go as 4 bits into parity generator
- we could use counters from clkins as indicator of which bits from which SR to parity-inDONE

////////////////////////////////////////////////////////////////////////////////////////////////////

1/11/2021:

- DAC_ re-test case 7 and 8 as possibly fixed mistake there...DONE

TODO: 

- macro for pulse outs DONE
- what we need to test/implement and list of modes...

19/10/2021:

basic modes: pass through or cycle is toggled by clkin bit

TO TEST/adc strobe modes a bit similar...

new adc strobe modes: 12,13,14,15,16 - don't notice so much... maybe replace with toggles TRY THIS!DONE

new dac strobe modes: 5 and 6... - 6 toggle one works ok


- hold last DAC value (or ADC/set of bits) on a CLKIN 1
- toggle hold on a CLKIN 1 

- these are like the strobe? strobe is different in both cases - in DAC case is just inverse of strobe

15/10/2021: how to think about squash and expand routings on level of individual SR

- DAC out from ADC in

route goes N->L->R->L->R so implies sequence - order through a
sequence, and a length of sequence but does this not need to be agreed
on across modes as each SR just takes care of WHERE it routes from... but this could for example cycle every X turn 

cycling of in routes!

0123
eg. for N/0 cycle would be: 3,2,1,3,2,1 (depending if we include itself- 3,2,1,0)

what would squash be? 3,2,1,0 to 3,2,1 to 3,2 to 3(R) and how we signal the squash...

14/10/2021: for 4 bit spacers maybe also have options for different routings... squashed routings, compacted routings

sketch out modes:
CVspeed:
1-15 -LR simple modes/all inc prob
      N 8xADC x2 - pass in/circle_and_pass or 16 ADC modes with pass in only!
      C 4xDAC x4 - pass in/circle only/circle and pass/prob

16-31 LR - exp modes
      NC - any match modes 4xADC, 4xDAC

CV+ADCspeed:
32-47 LR - modes mixed
      NC as 1or2

INTspeed:
48-63 LR - mix using CV params - prob,,,
      NC 4x ADC/DAC and prob modes    

13/10/2021:

- fixed 4 bit spacers i think... mode 27/28: xor returning, also 4 spaced equiv bits for DAC DONE/TESTED

- ADC as seperate condition in each mode, maybe DAC too, subset of basic ADC and DAC modes...

so eg. 4x basic ADC and modes would follow: circle, pass on, circle and pass, basic probabilities
and some more exotics...


12/10/2021:

plainer that input mode NSR is most fixed of all, we can have multiple
DACs out from anywhere, also everything does not necessarily need to
be on NSR

- array of certain values eg. dac for each mode, how to simplify if at all?

- probability modes with routing/adc selects for incoming bits

- spaced outTODO

- triadex muse: clocks/divisions/SR bits selected and XOred back in...

- how we select those options -> we need 4 bits back in (so 4 to select from other SRs, bits from own SR)...TODO

or ghost SRs - select 4x bits 0->SRlength from 4x SR? or just stick with itself - variations on parity bits

- inspired mode where we XOR in other SRs. -- and we use static SR or we wind through SRs... or multiple XOrs in -> modes20,21 DONE

//new defroute: uint32_t defroutee[4]={3,0,1,1}; // 0,1,2,3 NLCR - in this one 3 routes from 1 too
but how do we have this in modes as is same just not for RSR...

one option suggest as clkin flips that routing (or any routing, or advances routing table)... DONE


11/10/2021:

- what we can salvage from it.c: overlaps, SR in SR, how we could pick up or work with other ghost regs, revenants, various 4 bit in variations

starting to think about 4 bits in/out for different lengths: GENERATE:
array of masks, 4 values for spacings, SR with 4 bits in needs to
cycle on those 4 bits...

they need to be spaced out x bits apart depending on length - further array


/////////

- from AC: shifting array of ghost taps, otherwise lots of dependency on pulses we don't want

24:	// Insert pulses into SR at points determined by CV or by pulses in - very similar to mode 2 above - TESTED/WORKING!

25:
	// SR loops within SR at certain points?/sizes determined by CV or pulses in = basic SR of OR with incoming bits - TESTED/WORKING!

// pulse in means a divide/flip flop
// pulse in means double a step..

uses CV as speed/flipflop/clock divider in INT modes

using clock as on/off gating of functions

// also we can have one bit data with selection of params for BETA/low pass filter!

DONE: sketched out probability modes - to be filled in, further ADC modes and tests...

- how to reconcile multiple modes with multiple ADC/DAC options -
  reduce number of modes in those cases ...

- working through probability modes - to figure out how ADC options (and DAC) fit with these...
eg. with adc in mode do we do for all 

- also further question if we have multiple ADC ins? (ie. max one for each register?)

- 4 bits In/out with DAC/ADC

///

1-Basic modes/DAC/ADC modes
2-experimental modes DAC/ADC too: eg. *set parity points for LFSR or for entry from other SR... (4 parity points or more max?)*
3-probability modes
4-routing modes/extra speed modes

DAC and CV, INT and CV -> speeds

8/10/2021:

- adding ADC and DAC modes: some still to test like strobe driven...

- where we place probability code?

question of overall structure now:

speed/where we get speed from?

route/bits/in + modes which manipulate routing or SPEED table (with DACs, CV, INT/CLK options, SRCLK)

ADC/DAC types

special modes/emulations: prob modes

7/10/2021:

- modes 6,7,8 are quite destructive noisy with pass&loopback for DAC and ADC - so maybe remove these
- try counting pulses (12 bits=4096) within length of time for use as parameter...(q of speed...

main.c TIM2 32/16=// period 32, prescaler 8 = toggle of 104 KHz - so 50 KHz

- re-did param code so is now time between pulses...

- DONE/TESTEDtest equiv bits ADC code, add in onebit oscillator

4/10/2021:

First 5 modes done with LR/route/logic options and ADC/DAC options-> these also need new routes and logic

TODO: experiment more with leaky code and timings, triggerings of leaks...

/////

add in DACs into ADC and DAC modes/INT modes only if we use CV???

//for input modes
CV/param//+DAC as input
CV/param//+DAC as comparator for input
CV/param//+DAC as input spacings [where is placed into SR]

CV/param+DAC as output spacings

CV/param selects routing 
CV/param+DAC selects routing


Try to condense what we have here in segmodes into:

- ideas for modes to be implemented/tested:
- layout eg. speedfrom, routing, ADC/DAC:
- generic/functional ideas eg. how we count pulsins:
- ideas relating to LFSR, ADC, DAC etc...:
- file under OTHER:
- esoteric:

INT as signifier for interrupt/trigger modes

- re-routing is not so important - can be in INT selected from CV/DACplusCV
so CV/speed is more or less fixed routes only maybe with one exception

Q of more trigger modes?

- can route DAC(+CV if INT) -> ADC inputs

- different ways of counting pulseins (eg. reset generic counter on pulsein) or count gap between pulses = number of pulses in time xDONE

- swap over SRs on pulse in?!!

- INT mode: pulse ins (only have L and R) can toggle SR on/off - eg. hold it even against new CLK/INT

1/10/2021:

from below: for 1 or 2 of trigger modes: SR->bit speed (ANDed with CV/trigger) eg. if && bitx//and_train of pulses also (see below)

- idea that CLK pulsins could trigger train of x pulses at speed y
  (eg. y by CV, by DAC) - descending speed, speed from other SR, train
  from other SR - how to do this?DONE 104/105tested...for INT-DONE

////////////////

30/9/2021//1/10:

- possible SR modes adjust/set certain settings which stay that way until they are re-adjusted?

- that incoming bits/pulse bits could also be formed in SR which can be used (as DAC, as whatever)

- interrupt/trigger modes with CV as divider!

// question of how to organize/list modes as there are simply too many options even with fixed routings

eg. each has:
- basic/logic//type of SR eg. simple pass, loop, pass and loop, other logics, probability of bit in, of a flip

- for CSR we have DAC mode!
- and for NSR we have ADC/LFSR (2 options plus more esoteric options for special cases)

TO RESOLVE then:

1- question of NSR/PWM (which DAC we use - RDAC by default) and more about normed CLKS (L,R,N)
//RDAC for NSR/PWM and ghostSRs for normed clks (with speed of these from what, from RDAC?)

2- which DAC we use for speedCV+DAC// all the same? selected by what means, fixed but different eg. 
N-R
L-R
C-N
R-N
//as this answer also effects next:

3-how we deal with differing DACs across differing modes? do we need to 2x or 3x all modes for all differing DACs?
//just use basic mode for other DACs so we have a fixed dac table

4-list of modes and format for this for each N.L.C.R. also how we deal with N.L.C.R within cases...

5-special meta-modes for say bus of DACs etc.

6-what pulse can do in CV modes eg. PUSH on bits so is like speed plus pulse
7-what CV can do in pulse modes eg. comparator. as well as each as parameters...

other:
- pulses/clkin in can toggle entry/no entry of new bits, cycling etc
- pulses/clkin in can bump up/shift left/right the routing table
- pulses/clkin in can mask bits as for DAC etc. or SR etc
- pulses/clkin in can also slip/slow/bump up one CV speeded SR

29/9/2021:

- possibly we have static routing for R->N L->C and variable for L and R // with ADC/DAC options//but as we note above L and R also have DACs which are used...
 
as first set of modes: what are our modes - DAC/ADC/routings

- for some interrupt/trigger modes we can use CV for routing table...

but there is a problem if CSR CV is normed to speeds of others at the same time...

again question of NSR/PWM (which DAC we use - RDAC by default) and more about normed CLKS (L,R,N)

but as we no have less clk modes we can also use ghost SRs, but at what speed, speed of RDAC???

28/9/2021:

- new speed scheme/cv/dac to test now on speedc/lower one - seems to work well...

- BOM/pos/quote made 28/9 AM pcbcart/ordered30/9

27/9/2021/ notes from last days:

- back to testing in it.c (not generic but slowly port/change that code) - new speed scheme

RESOLVE:

- CV modifier in pulse modes

- fake CLK triggers from?

NSR - always TImx from DACx
L,C, R - from speedC-cv always

what else makes sense - ghostSR but is more complex!

- all simulated modes. eg. EN/electronotes - generalise as probability of new entry/just cycle/of inversion

- test as CV generator

- sequential SRs mean we can also slip one SR or double it (how to control this)

- DAC/multiple DACs -> DAC bus/mix or even one after the other (faster)??? but how do we decide on this:

eg. one SR has DAC out, any can have and is mixed, any can have and is sequential (as is meta-mode not just decided by SR) 

- interrupt modes as 48-63 last quarter...

Modes: // check if we can possibly hit more than 64 modes !?

0-15: CVspeed: NSR, CSR have ADC/DAC options and basic routes in, LSR and RSR have all routing bit possibles, basic logic ops
DAC is fixed from CSR, input bits from NSR

16-31: CVspeed: exp modes, all SR->rerouting options
DAC can be anywheres, ADC also (how many bits we have), resolve this!

32-47: CV+DAC:  simple modes, exp modes, all SR->rerouting options
where do we get speed DAC from - is it always RSR?

48-63: Interrupt/trigger modes as mix of all...

//address issues for each mode (selected) 

other:
- pulses/clkin in can toggle entry/no entry of new bits, cycling etc
- pulses/clkin in can bump up/shift left/right the routing table
- pulses/clkin in can mask bits as for DAC etc. or SR etc
- pulses/clkin in can also slip/slow/bump up one CV speeded SR

//////////////////////////////////

beckett/gray codes for routing ???

21/9/2021:

- how to go further, collate ideas and see how these fit or don't fit with generic model:

eg. in AC Cv modes was lots of use of pulses to do things which now we lose a bit...

or we divide across 2 sets of generic modes, or simply have generic modes for things like routings

- that incoming pulses can eg. change flip or not flip, change routing table, invert mode bits

seperate mode and mode bits: mode determines mode bits (on mode change)

- fixed small bugs (like static in one bit DAC), and routing for fake clks

20/9/2021:

- testing generic SR is it_generic.c

notes:

- had to break down loop though as speed was overlapping/effecting others, can tighten up and make faster from main.c TIM2 dividers
- that we should be able to make bitsize of dac independent from length - maybe?
- lists of modes/settings

- TODO: probability in generic code? TESTING but might work???


17/9/2021:

- question of how we work with probability within generic framework - as in TM etc...

// make it_gen.c + stripped version to test generic code!

16/9/2021:

- idea that CLK pulsins could trigger train of x pulses at speed x
  (eg. x by CV, by DAC) - descending speed, speed from other SR, train
  from other SR

- how to arrange:

CV speed
trigger speed
speed from other DAC (which one) with CV offset
SR->bit speed (ANDed with CV/trigger) eg. if && bitx
train of pulses also (see above)

[SR->fake triggers and mainPWM/normed in - but that is determined by other SRs] -> we need to sort this...
-> how these are all selected as all SR are independent

//MODE - where do I take my speed from?

to resolve fixed scheme eg. CSR->DAC out as we can't have 2x DAC outs simultaneously (or we have bus/mix)?

TODO: implement basic very generic SR for all cases, test if flag in clkin interrupt works so we can place all in main loop

1-Where do I get speed from? if from SR which one and 
1.5-shifting of which bits <<
2-where is the input bit from (LFSR, ADC type?)
3-what is routing for incoming SR bits, cycling bit
4-what is incoming pulsin bit if any?
5-XOR of logic op of all bits and re-insertion
6-DAC output for any purposes
7-pulses out if any

8-fake/pwm for normed clkins - how? or we keep standard?

options/ideas: DAC out runs at full speed and is changed by all/any, clkin interrupts flagged so all is in main loop

  // we can still have specialised SRs but they should all be repeatable
  // so can be placed in a loop!
  SEE:  generic.c

////////////////
how to resolve clock norming?

So we have PWM (TIMx) which norms to NSR clock - this is generated at the moment from RSR DAC

LSR, RSR and CSR have fake clocks - CSR should be from speedc/CV, LSR and RSR???

15/9/2021:

- testing and implementing arrays for puls ins and outs (left, right and c) DONE
- place into not-so-generic pasted LFSR round one at start// DONE

- implementation for Benjolin/halfDONE but need to think about how we
  can make generic one SR clocking another without failure in any loop, and/or generic use of fake clkins

- TODO: Benjolin in trigger mode using fake clks - FIGURE out how to prevent freeze (CSR will have speed)

- so start to think on what general modes for Vienna could be (before we get to rendering as all generic)

// using sigma delta for bit input an low pass out (see test.c)
// all modes with bits in and out

eg.
0-looping only/aka return only!
1-pass on only - straight through
2-pass on and return bitx

3-TM with pass on - trigger mode
4-TM with loop back
5-TM in TM pass on
6-TM in TM loop

7-Rungler XOR pass on
8-Rungler XOR loop back
9+Run with different speeds
10+Run with bits

11other exp modes/trigger modes//what else?

DACs,ADC types

TODO: always have NSR/PWM from RSR DAC for the moment - so to add to the basic/pastey!

13/9/2021:

- clock fake routes: R->L and L->R (output bits of SR to CLKINS), CSR is speed controlled (has to be) - TO TEST!
TESTING but tricky so made all from speed... NSR/pwm is from DAC

- make latest TM SR more generic/start to port to arrays/tables

11/9/2021:

finishing DAC and ADC generic options:
TODO// other options are: comparator, equivalent sets of x bits incoming 

possibly we don't use fake pulse ins for norming left/right - to test that these don't effect incoming
(but we do need to use CLKins normed for L,R,C) - test with incoming bits

10/9/2021:

inline int bits(uint32_t reg, uint32_t length){ // function returns bottom length bits of SR reg

and another inline function which returns different kinds of DAC from
a certain SR eg. standard DAC of x bits, equivalent dac of x bits,
what about one bit dac (more involved as takes time but we should have
a pointer to that value????

9/9/2021 

// always do DACs - but how these are handled according to length as we still want fixed number of bits

implementing TM in TM: slowly start to see how to abstract as work through and implement all modes

- TOWARDS: basic framework to use in Vienna! (using one bit DAC out
  tho which we could also include in routing tables and as an always?)

- each SR delivers DAC, how to do tables which don't allow for overlap of DACs eg.

1000
0100
0010
0001 for each table

structure for all eg. speed from routing table// all is defined by tables/arrays which can be routed

in test2.c speedroute as array of pointers to values...

pulsin bits L, R is XOR always with new bit

basic modes/expanded modes across split of cv/speed, pulse speed...

/////

how to make uncomplicated generic SR options which can interact across all sets of:

1st set: simple SR modes for each SR with fixed routing
1.5th: simple modes but with very specific configurable tables for routes eg. speed routes...
2nd set: generic SRs with configurable routings
3: complex routing with DAC, ADC etc.

generic as all routing is internal - we do not dictate to other SR...

// also from triadex muse:
--> this is an XOR of 4 bits - selected from clocking bits, on/off bit and from shift register feedback

that we can have XORs of bits from other SRs entering our SR
so table would be for 4 bits from 4x maxSRlength=32*4=128 (ignore lengths)

thinking about multiple routing for DAC, clock DAC and ADC??? how this might work as gives flexibility for timings

then we have x bits:

routing / DAC output / LFSR feedback / ADC IN 
1 2 3 4 / 5      /  6            /  7

extra bits: clock DAC/pulse for speed with any offset(CV), comp DAC ->9 bits, 

speed modes: CV as speed, CV plus DAC as speed, pulses, pulses from SR, combination of... see more below...

// and how would routing be for pulse modes: pulses, pulses from SR - but we can't use our own pulses
// we can't make this so generic as one set uses interrupts... also we can always reroute pulses with cables so...

CV plus DAC in CV modes, pulse plus SR in pulse modes????

routing table is for incoming SRs

abstract out LFSR perhaps as just the returning of bits (so is routing)
also we have entry bits, ADC bit/s, pulsin bits, returning bits

what bits come in, logic, what determines speed, other determing factors for specific SRs


speed/routing/logical ops (logical ops as also selected by bits, overlaying of masks)

- question of multiple DAC outs - what we do with them

if each SR has DAC out which can route somewhere, and ADC in

7 bits - which is 0-128 (test if we can reach on CV knob)

Other bits for pulse/cv and type of SR are fixed across multiple modes.

routing also DAC->speed of register x
pulses->speed of register x

seperate DACs for output, speed/NSR normy clock, other uses (comparator)

1 2 3 4 bits - question is if we combine multiple DACs???

how we deal with incoming bits/pulsin?

///

(or we have anyways routings which are flexible so maybe is ok. just that DAC out clock/speed effects feedback etc...)

// to have experimental modes in second half which do routing bits: in
pulse modes these could depend on CV, and in CV on pulse or RSR.

6/9/2021 - important thing is if we have routing table then what do we do if is
  zeroes for one route - we need always to preserve a default route

for first half of modes we fix top SR as in, left as through, right as feedback, bottom CSR as output


////

TODO from below:

- set up clockins for basic pass/recirculate SRs and test with norm of CSR DAC to top TIM1 NSR pulse-DONE
- start porting SRs - more generic from AC!

- test use of manipulated routing tables for one SR
- trial RSR as random register with various routings for simulation of electronotes and TM.
- in test2.c compare generic shiftings with coggs version (and also if we still need to do <<1 if routes to itself?)DONE, yes they are the same, and we do

- ghostSR in ghostSR in test2.c to trial//also various crossings of delayed ghosts with "real" SRs

from test2.c
// own routing means we have the shifted out bit already (route to self) - but we still need to shift

// we could also lag the ghost so is like a delayed revenant
// so example it only shifts itself if there is a pulse bit

////////////////further

// and cycling/circling array of ghosts which can come back or go forwards/backwards - when these ghosts are copied over (on event)
// with 256 cycles/copies - or we can have variable length of this shifting array

we can also determine cycle we use using another SR

** xxxxx

proof of concept generic routing in test2.c

default or not: CSR DAC out->top PWM/TIM1 which is normed to clock pulse for NSR

[we need to trial if this makes sense with routing]

// what bits make sense for SR definition to be changed by other processes?

eg. input types are fixed or not, routing yes

so we have several bit modes for different main SR types...

for example bits determining type and routing = 7 bits

- that we can choose (eg. RSR) to be specific controller or
  determining SR (eg. for random operations we refer to this one
  eg. for TM and electronotes determinings - to test this)

- routing bits (routing table as one SR?) - or routing bits flipped/changed by other SR, incoming pulses...

- generic: new inputs or not, or logiced with - returning bit or not or logic op (inv), parity settings

equals:

generic parity settings in array (0 for no feedback or tag array with meta-array for type of logical operation, or where it comes from)

trial bits:

pulse/cv speed, input ADC/LFSR, output DAC/else?, type SR, type SR, type SR(3 bits of types=8), routing from (4 options)  

1               1               1                 1        1        1                           1 1 1 1 - 4 bits just to make it easier but could be less

is already 8 bits which would be 255 modes!!! we have limit of 64 modes

+ additonal bits: advance on cogg, logical opps, type of ADC, type of DAC, OR of LFSR/ADC 

// and we just leave outpulses as generic/divide down on 2nd set

unless we have other ways of thinking of modes... (mode as itself shift_register, pulses as incrementing modes or is that all too complicated)



thinking to have special modes - at end of mode dial which implement this kind of thinking: even 3 or 4 last turns which inc bits

** how to make modes more generic/independent whilst keeping routing options and open-ness?*

- feedback thru RSR makes more sense for ADC in modes and less for LFSR so maybe this decides routing?

- what if each of the 4 SRs is totally generic (in/out can be from
  anywhere, routing is unfixed and modifiable in runtime,
  self-modifying) - so there could be multiple ins, mixed outs
  (busses)... how to test this as proof of concept?

- that NSR and CSR can be input and output buses

- what this means for eg. notion of coggs and dependencies on other
  SRs, digital style filters etc. maybe make small test - but problem is to have too many SRs types

but also means we can have routings maybe switchable from pulses or from CV

eg. switch routing on certain conditions...

as in we can mix use of arrays of (pointers)/srs and shiftregs with names which point to these...

** generic SR classifications to work on:

-routing
-what drives it on: pulses, bits/otherSR, values=speed // values from CV, values from DACs/SRs
-looping/input bits
-output bits
-question of overlap/coggs/SR

or:

-what drives it on: pulses, bits/otherSR, values=speed
-returning bits (eg. LFSR, no bits=pass_through)
-overlap (eg. LFSR in overlap, size of overlap)
-incoming bits - this is routing also and pulses in/ADC, and what is done to them (eg. flip them)
-output bits/DAC

or: shift x bits, length, entry new bits

and ADCpulsesDAC are attached in to this (as NSR, CSR)

** another attempt from notebook

1. basic division speed/pulse ->32 modes
2. output/input ADC/DAC/LFSR/others
3. type of SR-parallel/Turing.etc., logical opp (XOR,OR,AND, leaky)
4. what are incoming bits
5. outgoing bits

** code basis from test2.c

uint32_t *shift_[4], *Gshift_[4][4], coggs[4][4]; // gshift is 4 even though we don't use one

b=0; g=2; // n=0,l=1,c=2,r=3 // so feedback here is from c 
bitn = ((*shift_[b] >> (lfsr_taps[SRlength[b]][0])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][1])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][2])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][3]))) & 1u; // 32 is 31, 29, 25, 24
// need to catch it
if (*shift_[b]==0)     *shift_[b]=0xff;
// copy now to ghost
//we need multiple ghosts for each possible shifter: eg. Gshift_rl, Gshift_rn, Gshift_rc (right ones for left, for n and for c)
*Gshift_[b][0]=*shift_[b]; 
*Gshift_[b][1]=*shift_[b]; 
*Gshift_[b][2]=*shift_[b];
*Gshift_[b][3]=*shift_[b]; // ghosts for l,c,r only but let's keep one spare
// what else it needs to know - for each queued SR we need one cogg=0 for reset as we reset each on reading
cogg[b][0]=0;
cogg[b][1]=0;
cogg[b][2]=0;
cogg[b][3]=0;
  
*shift_[b]=*shift_[b]<<1; // we are shifting left << so bit 31 is out last one

bitr=(*Gshift_[g][b]>>SRlength[b]) & 0x01;
*Gshift_[g][b]=(*Gshift_[g][b]<<1)+bitr; 

*shift_[b]+= bitn;// & bitr;// ^ (!(GPIOC->IDR & 0x0010)); // or goes to 1s, xor is risky, AND works... and clockbit PC4

//also we can make bit access (eg. GPIOC->IDR & 0x0010 - can we access register as pointer TEST??? WORKS!, counters speed etc. all arrays 0,1,2,3


* general //16/7/2021+

- AC has 64 modes so 64x64x64x64=16 million combinations
- speed CV to use in trigger mode (eg. length of overlap)
- divide into speedCV, trigger/pulse - so that makes 32 modes doubled up (what of SR effecting own/other speeds)

maybe with/without coggs as further option becomes 16 modes

NO freeze: freezing is not so interesting as just locks and gives continuous tone...

[note for SEG - electronotes wheel thing is passing down of bits so this could also be probability based (based on CV)!]

/// LOTS TO RESOLVE:
/////

- thinking also that coggs are a bit like small shift registers
  what could be done with these - rotating/looping SRs handle
  feedthrough of registers TODO! - also that this is more like overlap
  we had in mind - this seems to work

//////

- also odd patterns just realized unless we constrain lengths to odd numbers (which is even lengths) *TEST this - improves but maybe keep odd option//NO!
- reverted to older code 2/9 as if we constrain this favours 101010etc regular outcomes

- at high speeds timing of SR influences other timings

- kind of bug in all lfsr code (28/8/2021) as was passing on bitn
  which was LFSR feedback bit - still was interesting and keep for
  some modes or use that bitn for timing etc...

- also question as CSR is out but speed there determines speed of
  feedback so we should really have different paths:

as we have it is NSR->LSR->CSR->RSR->NSR

eg. NSR->LSR->CSR
            ->RSR->NSR

NSR->LSR->CSR // could be default routing but then we need to see about use of SRlengthc but length is important if we re-circulate???
///->RSR->NSR

NSR->LSR->CSR  ->NSR/or not
   ->RSR->CSR  ->NSR

others: NSR->CSR->LSR ->NSR
                ->RSR ->NSR

need to figure out how to select these from modes - see below

routing can be array of shiftregs

///what does it mean to have multiple routes -> route is only known to incoming SR which updates ghostSR which belongs to itself (so it can have all 4)

so routing table for each incoming SR would be 4 bits 1 1 1 1 N,L,C,R - excluding itself (try version which includes itself and doesn't shift)


//////

- do we always want same flow NSR->LSR->CSR->RSR->backtoNSR (at least
  do we always want feedback to NSR but then if not RSR would be
  redundant)... Q is how to signal different routing across independent modes:

if (routex==1) do this... // or pointers to entries - but we don;t really need pointers

/////

- see also AC modes.org!
- parallel bits input modes - eg. all x ADC bits are thrown into top or other SR

- speed can go to zero! signal this in array somehows... and speeds should be slower at one end

timing from speed-cv, pulse in, top reg(but no bits in), pulse AND
speedcv (divide, multiply, expect), pulse AND/OR/XOR top (again no
bits), from ghost registers (which can also be themselves clocked by
top register and then we can use bits in or?), timing also from SR->DAC


- question of range of speed - from slow CV (Hz?) to KHz for sigma/delta

- how we prevent running down to zero for SR on length change (trap this?)

variable stopping bits/zeroes

- left hand path/ right hand path: tree of life, kenneth grant and overlays for ...?

- how we deal with overlaps? some test code already but need to think through, could connect to length?


also pulse clock or cv advances number/x once eg for cycling ghost sr
or length of ghost sr, or we can have smaller degrees of that advance,
say 1/10 so is not such a big jump

- how clock pulses can be changed for speed - xor with other parts of
  SR, with returning bits (experiment with these timings), with speed bits????

- how to notate SR - black and white, left and right, that a ghost SR
  could decide how to route bits to left or right (but we use right
  for feedback but could still be interesting - general idea of
  routing bits eg ADC to one side, LFSR to other)

- for overlap: what comes out is only one bit (of course there could be pulses from earlier bits)
  try overlap with multiple << shift (same as or differing from overlap size)
  returning bits

- overlap also in sense that both overlap (XOR etc top and bottom overlapped SRs), what other kinds of overlap?

- how else to use our new multiple shift code?

- what we do with both clock and pulse in bits in CV mode and how we
  norm these bits (NSR clock is normed to TIM1 pwm which we will use
  speedCV/or DAC out as control for) - otherwise we have pulseouts normed to all other pulse/clock ins

[but none of these will advance so maybe sync all to this clock which frees up their own speedCVs]

- experimental modes for LSR, RSR and CSR only advance with cogg=0 from previous (maybe logic op with bit)???

* NSR, LSR, RSR, CSR

** NSR - top register - ADC in, CLKIN only, no pulse outs:

mode 0 is straight LFSR (or with ADC or)

- 1-LFSRnoise/2-ADC in/3-mix of LFSR and ADC //4-comparator? -to-LSR/or/RSR or both (do we decide that here = RSR is now designated as feedback)

[so that gives us 8 or so modes for each one - or 4 with new coggs setup]

+ comparator function for ADC ins (can we also use this for LFSR -
  ways that we can combine bits from that?) - comp only works when we
  have no speedCV/pulsein only - or we can have 

comp in as one bit only ADC in comped with CV?

- feedback of analogue output - eg. comparator using analogue out

- types of ADC (x bits, simple uncombined bits as in digfiltersim, equivalent bits), length in bits, delayed/stored bits

- pulse in/or speedCV and what CV does when pulse in/vice versa! (eg. number of bits, LFSR length if we have as extra)

- can also be clocked by CSR and/or ghosted noise SR 

- can be set of parallel SRs which feed into CSR, or just x bits from ADC go straight into CSR

- ADC with LFSR options: that we OR/XOR each incoming ADC bit with
  LFSR generated bit (from ghost LFSR), cases for parallel ADCs, that
  we weight incoming LFSR bits, that we use LFSR as DAC to
  add/subtract from ADC in, that we bulk XOR or just one bit per x
  incoming ADC bits, comparator of incoming DAC against LFSR/DAC

- number of bits in/out by CV or pulse counter(which wraps around)

- what to do if bits in/out is greater than length (options: put in anyways and lose top/bottom bits - shift if necessary // stop at length)

** LSR/RSR - regular shift register modes borrow from AC - CLKIN and PULSIN, 2 pulse outs/bits or flipflops: 

mode 0: feedthrough only - straight shift through with no return

LSR has entry from NSR and feeds into CSR
RSR has entry from CSR and feeds into NSR (so is the feedback register)

but now we look into different paths!

dark/light sides, left and right hand paths, mirrors (moon and sun), tree of life (Kenneth Grant - Nightside of Eden)

Question of how we work with entry of pulse ins: as togglers, pausers also, as extra
bits (but do we always have NSR entering in, maybe AND with extra bits
or other logic ops)

List leaky/decay possibilities...

- look at AC SRs and see what can be adapted for NSR/CSR as incoming bits and cycling bit or pulse in bit (or combinations of these)

- how we handle entry and overlap from NSR or CSR (logical ops, length of overlap)

- can also be clocked by bits from the NSR top register - but in this case we can't input bits from NSR as these will just be 1s!
 
- regular AC/SR modes

- just one way shift/delay - in one end, out the other (with/without bit degradation)

- looping SR with/without degradation

- leaking/decaying of bits, other logic feedbacks 

- micro-SRs in SRS - additional loops and feedbacks (that we can have loop in loop but also feedback in RSR to LSR and vice versa)

- regular and ghost LFSRs...

- latchings, holdings

- multiple flipflops of various descriptions for pulses out

- RSR is "clocking/logicopwithclocking" LSR and vice versa - need to test how this will work in all cases

** CSR - output register - CLKIN only, 2 pulse outs/bits or flipflops, DAC out: 

mode 0: basic DAC out

- type of DAC (eg. sigma/delta which is low pass of single stream of bits, x bit DAC)
- which of the bits are used for regular DAC: weighted, unweighted, spacings
- overlays, masks for DAC bits

- how we handle the pulseouts so this can also be extra/doubling up of modes

- DAC outs from SR

- electronotes just has standard weighting DAC, uniform (bits x X) from consecutive taps, and sets of spaced taps -> wide spacings)

what else for 64 modes divided by speedcv/pulsin = 32 still (in pulsin we have bit length for DAC)

- number of bits in/out by CV or pulse counter(which wraps around)

- what to do if bits in/out is greater than length (options: put in anyways and lose top/bottom bits - shift if necessary // stop at length)

* notes... from elsewhere/sketches

- extra SR for random ops and timings maybe - that we can copy other SR to this also...

- what second bits out can be - different taps, divided/flip_flop, diff tap and flip_flop, logical ops with other bit!

- drooling shift register legged caterpillars

- how to do digital filtering - x spaced bits enter, passed down straight SR (with/without bit degradation, any other fancy stuff)
and X spaced bits are sent to DAC from CSR. return bits (how to select) OR/XOR from output (as bits or via DAC/ADC feedback options) to NSR/top register.

- maximum SR length as 32?
- ghost SRs
- parallel entry of data/ADC, sudden mirroring of SRs?

- leaky, rotting and/or infectuous logic/sticky logic/slow logic others?, UFO stuff 

what other kinds of logic gates there can be (based on CA, ternary etc)?

timing of a slow logic leak? 

trigger->latch and slow leak, disappearance of ones, bit by bit (how we could also display this as side project)

- NLC 8 bit cipher simulation: only makes sense for NSR and CSR where we have many bits in

... strobe is always high on 4094 so bits go into SR and are out, but
option for data on strobe which means all SR only change on 1, CV
combines different bits and primitive XOR for 2nd bit/mix with data in...

basically data goes to out when strobe is high, low -> just shifts 

so strobe is pulse in which can latch (incoming-ADC or noise) bits on to NSR or CSR
(outgoings) - and this is different to speedCv/pulse_speed as SR is still operating...

- how to work with overlaps? 

- overlap XOR LSR and RSR

- sieves - that LSR can be used as a sieve or bitmask for
  RSR/others... - how we deal with sudden events such as this, freeze,
  copy, ghost etc. (on a pulse in?)

- marking bits which always stay frozen - concept of sieves, masks,
  ghosts, revenants (eg. slow drift or decay of bits from one set to
  another, frozen, prevous or ghosted - so bit by bit they shift back,
  question of how long they take to go back?)

question of recording position and lifetime for decay - we erase on
death from the list but list handling is slow (finite sets of arrays
and garbage collect in one interrupt?) or we can just record and keep one bit max per SR

- TM encoding for SR_as_tape operations
 
  walk_ins - what else can be borrowed from language, concepts from UFO
  encounters?

- pulse triggers exchange between ghost and real, what pulses might
  mean - primitive programming language like brainfuck

//interpret set of bits as instruction on pulse in - say an x bit
sequence (but how to work with bits rather than bytes)

instructions shift left or right the opposite SR (can also use bits as
mask to do this - so we interpret one SR as shifting the other on each
bit in)

The Infinite Abacus: Brainfuck's "grand-parent" language

A version with explicit memory addressing rather without stack and a
conditional jump was introduced by Joachim Lambek in 1961 under the
name of the Infinite Abacus, consisting of an infinite number of
cells and two instructions:

    X+ (increment cell X)
    X- else jump T (decrement X if it is positive else jump to T)

- reverse direction of register (what this means?)

- glue one LFSR onto end/beginning of another

** parallel SRs

- feed data into top of parallel LFSRs, data read out from all bit outs: test for 12 bits, 12 parallel streams

** two headed SR



* in progress/ideas/todo

- how we pass through SR bits at different speeds - top one resets cycling/circling counter which wheels through SR
- is [0 bit our output?
- smoothing and other aspects from AC to implement
- re-test function pointers/how to make code more modular?


* TODO/plan

- basic structure of the 4 SR and straightforward tests eg. ADC in,
  pass down SR, DAC out

- proof of concept for digital filter and what ideas come from this

- all basic SR concepts implemented

- brainstorm and tests of all concepts

- basic modes layed out and tested - first speed CV then pulse driven and fancier...

