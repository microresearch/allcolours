* plan

- implement/test all new modes and catalogue these

// need balance of flexibility in modes, access to advanced routing...
// or at least alt routings altroute

- TODO from below and from theone.c
- recheck logic of all sections

- implement sketch of all modes as below with DAC and ADC options
- test/play
- tweaks for slower speed, CLK norms, what else? how we handle one bit audio filter?

* older modes sketch

newer is 1-31 ADC modes
1-15 DAC modes
16-31 4x4 DAC modes...

CVspeed:
1-15 -LR simple modes/all inc. prob
      N 8xADC x2 - pass in/circle_and_pass or 16 ADC modes with pass in only!
      C 4xDAC x4 //or 8xDAC x2 // or 16x DAC - pass in/circle only/circle and pass/prob

16-31 LR - exp modes - place global CV route modes
      NC - any match modes 4xADC, 4xDAC

or 31x ADC and 2x16 DACs = now 4x4 DACs

CV+DACspeed: // other speed options: speed from clkcnt, speed from CV+clkcnt
32-47 LR - modes mixed
      NC as 1or2

INTspeed: // or speed from INT divided by CV->TODO! // SR->bit speed (ANDed with CV/trigger) eg. if && bitx
48-63 LR - mix using CV params - probability, comparator, CV+DAC/ADC as modifier
      NC 4x ADC/DAC and prob modes - special INT modes for ADC/DAC which make use of CV/not trigger

plus global change routes for INTmodes right at the end,,,

CV&DACspeed: -/+/wrapsDAC- tested some...

timing from pulse AND speedcv (divide, multiply, expect), pulse
AND/OR/XOR top? (again no bits), from ghost registers (which can also
be themselves clocked by top register and then we can use bits in
or?), timing also from SR->DAC


** classification

L&R modes...

- basic route/logic modes
- probability modes
- use of CLKIN as bit modes/as toggles etc.
- speedfrom/routings/logic manipulations
- esoteric

** list from theone.c

//0: all pass through only

//1: cycle round only XORbits - basic 0 DAC out

//2: cycle and pass only XORcycleXOR-bits - basic 0 DAC out

//3: N: passon/XOR-LFSR LR: passonORbits C: XOR-DACequiv  // note that for LR with no bits in these are all the same

//4: N: passon/XOR-ADC1bit LR: passonANDbits C:XOR-DAC1bit

//5: N: passon/XOR-ADCxbit LR: passonLEAKbits C: XOR-DACspacers

//// maybe remove 678! and add new ADC/DAC options instead

678: N:cycle/pass/XOR-ADCoptions LR: cycleandpasXOR-LOGOPbits C: as N/DACoptions //NOTE: these ones are quite destructive of ADC ins/orDAC?
6 LFSR
7 ADC1
8 ADCxbits

//////9- test code with other ADC and DAC options
//rung - cycle XOR with pass//=mode2

10 - model for probability modes?

/////
TODO: prob modes below as/and basic INT modes

- probability modes for (DAC, DAC+CV comp to SR,countedclk): 
   - prob of bit in/inverted bit in,
    - XOR bit in from->[cycled//ADCorLFSR//pulseifwehave]->routed in or not
    - bitin OR loopback, prob of bitin or inverted loopback, 

???prob of cycle, new bit from bits/from route -> how many? make this
  clearer:

SR is customSR or RSR(routed SR)

1. if SR<CV  // int mode
2.if SR<DAC  // cv/int mode
3.if SR<DAC+CV // int mode
+4.if sr<CLKCNT // cv mode+
XX
1. invert cycling bit or not, pulsbit is ORed in (TM)
2. invert routedin bit or not, pulsbit is ORed in (TM)
3. mix of this?

3. new input (from pulsbit) or cycling bit (wiard and EN)
4. new input (from route) or cycling bit
5. new input (from ADC) or cycling bit//6. new input (from LFSR) or cycling bit - only for 0

7-10 above with inverted cycling bit

so is quite a few modes for all options

///
- other modes/to fill in:

- Rungler:

Original: SR bit out XOR with OSC1 out AND OSC1 speed/freq is determined by SR (itself)

translated: cycling bit XOR with other SR out bit which is clocked by
SR/or DACspeed from itself (bit clock options are set BY SR itself) 

or:

cycling bit XOR with DACout from own/other SR vs. comparator=CV/DAC/DAC+CV/CLKCNT

///

- leaky logic, memory logic to play with 

- Beckett/gray code.

Gray code: where each line differs in only one bit
Beckett/gray: as gray code but bit first in first out (history of bits also for leaky???)

bit position x which has not changed... FIFO ... we have list of transitions (which bit flips) for n=5 etc.

- modes from original it.c ported to generic form

** ADC modes 

TODO: more comparator modes, adc_in to be compared to what? compare to: CV, DAC, CV+DAC, to clksr_, to param - OR feed these into otherpar already

** DAC modes

** new modes from below

DONEProbability modes: CV//PARAM//SRDACx > SRDACx -> result - case 30 with dacy<dacx

DONE+ADC could also be used in probability modes+ - case 29 now

DONE- *8 bit cipher code* --> we have in ADC_ mode 8 ,, but could also be used for modes case 32,33
accumulate into ggsr and then bang in to realSR on a CLKIN (how many accumulated bits or just whole SR length?)
4094 - on STROBE signal, SR is transferred to the storage register...

DONE- triadex: we could use counters from clkins as indicator of which bits from which SR to parity-in
--> this is an XOR of 4 bits - selected from clocking bits, on/off bit and from shift register feedback
that we can have XORs of bits from other SRs entering our SR
so table would be for 4 bits from 4x maxSRlength=32*4=128 (ignore lengths) - case 35

DONE- pulse triggers exchange between ghost and real case 36

DONEhold ghost 37

DONE- pass through or cycle is toggled by clkin bit - case 38

DONE - multiple DACs - but how we do this as a single mode (add/sub/wrap other DACS, additive DAC into DAC[2]) case 39

DONE- swap over SRs on pulse in?!! or swop in only (can swop in previous SR or another?) 

DONE - TM in TM

DONE - reverse direction of shift register - could be done on a toggle: >> and << and blank/fill in bitn

DONEinDACcase15 - toggle/record/keep frozen bits and keep these ORED with the shift register as it cycles or does whatever

DONE - probability for reverse direction - case 45

DONE - instructions shift left or right the associated LFSR (instruction as 1 or 0)... and enter this bit into our SR... - TRY THIS as ADC mode - case 27
can also be other shiftings using bits (xSR shifts ySR left or right)

DONE - - cycling array of ghosts toggle in/how to toggle out
could be keep recording into array and on INT we cycle through (XOR/OR in pass through) until we get to last recorded of max x case 46
// could also be alternatives but as it is we just replace on INT the revenant SR

- more modes which play with GSRs: GSR as mask for???..., freeze/speed up
  GSR, GSR runs at CV speed in INT mode (try - and vice versa)DONE, re-routing make use of
  GSR already. 

swop GSR/SR or /into/ SR (before copy?)????

DONE- GSR doesn't change (becomes a revenant) 48 and 49

// pulse in means double a step.. ????DONE

- modes which manipulate THEIR OWN SR routing table/speedfrom tables - DAC/CVetc ... - this is already in modes 24,25,26 to re-examine

24: clkin bumps up routing table only

25: INTmode - CV shifts table and lowest 3 bits of DACmode - so total of 6 bits only - we could expand this for other bits - added logic table

26: as 25 but with SR as source - added logic table

also speedfrom_ table->who/ but can't use cv for that... TODO

- most generic table for all elements which could become itself a SR//SRx as determiner...
use DAC, CV or SR as this can be different to DACs (if they are not just default)

////

trial bits:

pulse/cv speed, input ADC/LFSR/no, output DAC/else?, type SR, type SR, type SR(3 bits of types=8), routing from (4 options)  
1               1     1            1                 1        1        1                           1 1 1 1 - 4 bits just to make it easier but could be less

eg.
0-looping only/aka return only!
1-pass on only - straight through
2-pass on and return bitx

- expand all possible probability modes...???

3-TM with pass on - INT mode
4-TM with loop back
5-TM in TM pass on
6-TM in TM loop

7-Rungler XOR pass on
8-Rungler XOR loop back
9+Run with different speeds???
10+Run with bits???

** AC modes and inspirations:

- clkin leaps/flips bits - that we can apply a mask from clkin for
  whole SR - would be nice to be able to freeze this thoughDONE to some extent

- DONE in adc_ - case 31 - TO TEST shifting array of taps/ghost taps/ clksr can also be taps: ghost_tapsL[32][4] = { // left hand path ghost_tapsR

- sr loops in sr

** first it.c modes to port in

[- TM and other prob modes:  CV in as comparator for SR DAC, CV as comparator for ADC in, ADC as comp for SR DAC
all the comparison possibilities]

- overlaps: in overlap we just mask top x bits of previous routed (so only one route or?) in to this one...DONE

- shift x bits in DONE

- SR in SR//barriersDONEkind of


* 2022++

*expand and port modes in prob and bit.h - add cv masks where necessary to these*

*define what CVs we can use, what prob modes, split modes for adc, dac selects, and routes/probs*

multiple speeds are in: model.h

CVL - from length
CV - from speed

detaches
INTmodes

DONE7/2/2022:re-check strobey, pulsins, pulsouts for all modeX.h modes and count=0 where necessary in modeR.h

*settle speeds and test new voltage/CV scheme*
*figure out calc for filter speeds (once we settle on speeds)*
*cleaning, organising, testings!*

** 9/2/2022

- thinking to re-work noisy ADC to one-shot // test with constant speed and lengths and just try adc12 to start in N81_4bits
REWORKED but still need to deal with mode/adc


** 8/2/2022

- working in modeN.h to assemble preliminary list of modes there, refining

- added new multiplespeednew - test in modeN

-TODO: test multiple speeds in modeN, 

DONEdetach modes for strobes- 2 cases - need to select arrays of good adc modes and categorise

** 7/2/2022

- DONE:trial basic mode - split length so handles xor/or in - logopxxx has the xor/or option too

- *sort probability and route/bits files* // starting with modeN and cleaning up a bit

- we can have say 64 as mode with no adc in 

** 4/2/2022

DONE- SR in SR again - how to embed one in another properly - with constraints - LLLSWOP

- full generic bit interpreter

- *can use CVL to select dacfrom and also mask in certain modes...*

- *thinking of 0-15 as basic length/speed modes and 15-31 as detached modes*

** 3/2/2022

- fixed speed issues now in interpol code - slowest is around 1Hz with 2^14 octaves scale in log_gen/resources...

- how far did we get with bitmodes? bit.h defining now for modeL, expand and then port!

*thinking about how have whole other path - so feedback is one extra limb perhaps//isolate/un-isolate*

where do we change dactype for NLR?/ C? also is 3-5 bitsDONE - in bit.h - so changes own dactype...

** 2/2/2022

+hit problem with slower speeds and float - fix from test2.c - either reset at 8 or 1024 or reset in ENDER?! test...+

- do we have prob of bumping up local route: in modeL yes

- TODO: generic versions of major modes, start to classify eg. generic version of electronotes with different bits
- routes tagged with NOT/inversion bits

DONEport dacspeed modes from modeN.h // and one xtra one

DONEmodeN: prob modes done, port electronotes and probability modes to L as template

*port from L to R and C maybe new modes* also multiple speed modes are in L - some for R only, some for C
also maybe some new modes across N->

*TODO: port generic ones into R and C from L in probability.h - done for L?!!!!*

- various detached modes for probabilities and generic probs esp. in ADC


DONEcan also have XOR opps for routing tables, where do we get dac/sr from - how to change this, mixes of DACs, all recursions

** 1/2/2022

In modeN (also modeC bit nor so critical there) we can't have so many ADC/DAC select modes for each possibility:

so:

- start with 8 total basic ADC/abstract modes in. further mode on Cv select lines only - with probs, other modes...

DONE: prob modes implemented - added probability.h for all sides

DONE: for modeN.h we can select ADC mode (adc or abstract) and use probs, *TEST* probability.h

DONE: port prob_bits mode over to N, added Lintgenericprobx in prob

- added strobe modes in adc/modeN.h - DONE: these could also be toggles toggle entry/no entry

DONEcheck all bit/route options and any implementations

- fixed major bug in new modesL modes - as we already gshifted out the cycling bit

notebook notes:
- DONEin modeN: how to mix between CV control of bits and SR/DAC control - as we need 2 CVs (mix and CV) - detach both (in CV mode or one in intmode)

- NLBURST0: bursts of DACin/ADCin to spawn/seed feedback - so trigger
  means CV length of ADC bits in, no trigger is ROUTEin at otherCV
  speed, +can also be prob of entry vs. no entry/route in - this is already in Nintprob2_0+

- can also be burst outs in modeCDONE


** 31/1/2022

- if binroute and dacfrom follow same count or we move these differently - have 4 bits binroute (16 options) and 4 bits dacfrom (16)

and SR also onto both routes//from DAC - these are done TOTEST - //but what of clkcnt - follows dacfrom/daccount

DONE in L:untether/leave at set speed of entry (also same for length) - run at that set speed but have dac at other speed/cv - see above eg. pass on speed/gshift etc, dac speed*

DONE: port in extra intmodes, 41, 47, 64, 67, 68, 69, 104, 105

added electronotes modes in N


** 30/1/2022

// some DONE from below... question of detach speed or not...

** 28/1/2022

*which way round probs should be?* depends on mode!

+test if we should put speed calc inside loop+ outside as we use in CVOPENing

*again Q of using DAC from 3 when 3 routes in to 0 - how to seperate or did we solve this?* lack of routeins/option of route in...

- DONEdetach length and place assign in headn,l,c,r - TESTed, so we can use CVL if we like... and leave length as is...
- DONEnew mode 82 in adc/moden with incoming bit as comp

- DONEcombine routing and probability modes - to some extent in
  LDACroutestrobe0 but tricky, also prob can be speed, prob of advancing the SR-DONE, or one aspect of the SR-DONE - could be more

new sets of modes where we keep old length and use a new CVL for:
- prob and routings, double speeds/slippage (can also be with DAC), possible triadex mode, how to scale and offset DACs for DACspeeds -  define more of these
-eg. for adc choose adc in cvspeed, dac same, or probs of adc etc... - DONE to some extent in modeN and modeL, modeC for dacsels

- DONEthink how Triadex could use 2 CVs///port to SR

- DONEprob of changing local routing table - in LintDACroute0 and some strobe version in modeN

- TODO: finish new intmodes in L, port newmodes from L to R, figure out calc for filter speeds
  (once we settle on speeds), define all bits, start to organise each set of modes...

*question also if LR pulses in should be XOR or OR? - OR seems better TODO/test/change - or options*


DONE: cycling bit XOR with --> [DACout from own/other SR vs. comparator=CV/DAC/DAC+CV/CLKCNT???] - N84 and some variations

DONE: INTmode: probability mode where CV fixes bits (of prob) and prob is against DAC/SR onlys ???????what means - ?prob is our LFSR - so we fix bits of this one...
Lintprobfixed0/1

DONE: use other SR bits to determine length of SR, eg. can be modded or...  NLSRlengthselL0 and companions

/////////////////////////////////////////////////////////////////////////////////////

*notation system and define/implement all prob modes:*

prob taken from [X] of [Y] bit [LOGIC_WITH] [Z]

eg. TO expand

for ADC:

[LFSR, CV, DAC, SR] against DAC, LRC: ADC_buffer[12], CV, and combinations (ADD, XOR etc) of these - see EN below]

otherDAC, ownDAC

STROBE - invert ADC BIT - XOR/OR routed
       - invert [ADC/xor/or/routed] - NONE
       - ADC BIT vs routed - NONE
       - ADC BIT vs [ADC/xor/or/routed] - NONE
       - ADC BIT vs invert [routed] - NONE
       - ADC BIT vs invert[ADC/xor/or/routed] - NONE

for abstract ADCs we can also have RETURNbit
       - ADC bits vs RETURNbit - XOR/OR routed
       - ADC bits vs [routed/xor/or/RETURNbit]
	 [and inv of 2 above possibly]

for others/L, R, C:

- invert RETURNbit - XOR/OR routed
- RETURNbit vs routed - NONE
- invertRETURNbit vs routed - NONE
- routed versus 0 - RETURNbit

EN: LFSR SR bit is loaded/not loaded onto recycling SR. loading can be random (based on LFSR and set of probability switches). 
*prob is sourced from LFSR ANDed with CV/DAC*

comparators for probability and ADC depending on INT/CV mode

/for prob:
1. if LFSR/SR/DAC<CV  // int mode - as DAC is not necessarily CV!
2.if LFSR/SR<DAC[x]  // cv/int mode
3.if LFSR/SR<DAC[x]+CV // int mode
4.if LFSR/SR/DAC<param[x] // cv mode


** 27/1/2022

try to categorise and clear up modes:

  probability/if_strobe/toggle modes

  ghosts/reflections/walkins

  route modes/bit modes

  what are outs/ins

- how can we detach SRlength as is used everywhere as length?DONE

- ported in all newmodes. 

** 26/1/2022

- thinking on scale/speeds - at the moment we have 0-5v CV input and
  covers 2^10 - so 10 octaves...we want say 13 or 14 octaves - 0.1Hz
  to 5K for 14 octaves/doublings

*can we have knob covering this and 0-10v as 1v/OCT*

*100k instead of 200k for -10v and 33k in loop - as in Tides! (and can we adjust/scale input cv)*

// 14 octs in 1024 =73 per octave =140K of cv in maybe approx... (for 730 max)

http://lushprojects.com/circuitjs/circuitjs.html?ctz=CQAgjCAMB0l3BWcMBMcUHYMGZIA4UA2ATmIxAUgoqoQFMBaMMAKACVwU9wwURCALDz5UIA2lEkwELAIYgUCQp24DsfXt27Zo2EAx16w8ePpgnMkBMQQoU4-Bkgoyk4yZYAnFcIX5foiaQ7D4C3MTKYVIg4vrG0dJeodxoqtxUTvAsAO5+3Mx8isoFUElF-EJqfIKSKLhwLADGCkog6jHt7VQC0JlB-WCMxPoovVZkxC4RkMRqkOTmkKy55SXlNcErrTXlUZstkSn+ezkHMSmtXadVbXw3G9ftNTeapQDmZ2ACQuWpUo8aLgxCI+YIAe0kG3OhHI8UWcDIhCUilqkmwLAhYCQULUCCQSHhMwwSMIKIgGiQ6KAA

or 100k cv in, 23k feedback, and -10v is 70k

- how to scale and offset DACs for DACspeeds...(two controls - leave length as is maybe)


** 25/1/2022

- from notebook - DONE:how we could have multiple/split speeds (leave one/length as set and update others on entry?, or use strobe also which maybe we have already)

2x CV, strobe, dacs

1. shifting/SR speed << (but if is not aligned with bitin?)
2. GSR copy speed (own GSR) //copy on strobe? see 37 in newmodes - L3 in modeL - in/outside loop as optionsDONE
3. advance incoming GSR speed - slidings
4. DAC out speed  - slipping

-- porting in from newmodes.c, DONE:4 bit shuffle to come in from modeN.h

** 24/1/2022

- TODOcheck new notebook Qs:

- DONE: added dac comparator mode, compare with itself DONE/TESTED
- DAC as param for some abstract ADC modes (22-31) checkDONE
- all modes have local route in to change - from strobe/bump, from CV. from DAC is already done or? - in modeN, R, L, C tested///DONE
- added Ndacghostincoming0 using incoming ghost for speed in modeN.h
- +fixed speed thing in macro.h a bit/back+ fixed some of adc so can have multiple w (eg. for oldbt etc)
- added ADC choices in intmode: LintselADC_63, RintselADC_63
- added binroute NOG macros to macros.h to test in modes (in all modeX.h): no movement of GSRs....DONE/TESTED

Benjolin style patch: 

R-OSC mode -> N-OSC mode ->L-route in->Nout, R clocks L, L is dacspeed for N and R // multiple OSCs, ADC in L and R... (not in C)

doesn't seem to really work out!

- *modeR/where - change dactypes for 0, 1,2,3 (inc. itself)*, [or intmode in each to change own dactype 0-15 (but no strobe so 3 bits) - but then rest is fixed]
// where we set this? where we reset to defaults... is it necessary to change this


////////////////////

- changed some of modeN to avoid interrupt disturbance for dac incomings

- also dacfrom array is tied to count and gives dac and fake clks... change for new rungling scheme 

- should have array of what we route into - added routeto array with count to use for some Gshift modes

** 21/1/2022

- +maybe makes sense only have DAC speed modes in LR!* else becomes too confusing/noisy and we keep NC as more mode selections and prob for+

- Tested Rdacspeed modes: *problem again is that if we use DAC1 to set it also effects speed of outgoing (unless we route differently 8,1,1,1) but that doesn't make sense*

- added Rmode which bumps on ghosts - variations of this and can also be intmode and dacspeed mode


- DONEghosts of ghosts - strobe records a ghost of incoming ghost and holds this till next strobe/advances it, records new one, holds for length time?

TODO: when we use dac this should be from a table which can also be bumped around by modeR *dacfrom* which also uses/matches count or should it be otherwise?
DONE- but we need to test this thoroughly - clkroutes also follow the same logic

** 20/1/2022

- last of all intmodes selects type of ADC/DAC (except those which use strobe or use param). For LR selects functions with no params or strobe/so no intmodes

- fix for pulse out on C1 (bitn initialised as 0)

R- for CV modes add in bump up global routes, SR as global routing table

L,N,C - // for CV modes add in bump up local routes, SR/ghostSR/DAC as
local routing table - we have some of these in modeN to model from, we
also have a CV intmode router there

- we can also have modes in all cases which use (mix/xor etc in) their own ghosts (as run by the following SR)


** 19/1/2022

*question of 32/32 split of speedcv/dac // int across all modes as gives more param control

- routing and dac control is most important, also which modes use strobe and which not

*question also is if we use right DAC for lowest fake clkin - this also feeds back in to top when it is running:*

- *wider question of multi functions of right hand dac and how this could be otherwise: functions as feed through, as fake clk, as dac feedback input*

--- answer is maybe to have different dac options (where we take from) set in modeR

Still working on modeN.h modes:

- DONEput generic one back in so we can do ADC+DAC opsDONE - to fill out in modeN - what variations do we have? 7 bits

- route could also be N->C N->L L->R R->N which is 8,1,1,2 test

thinking also how it could be to have 2 speeds - one for entry into R feedback and another into L, DAC:

so 2 branch speeds??? how could this work??? depends on routings and if we mean primary speeds then we would need to run one SR twice



//////////////////////////////

how to choose modeN modes now...

we have:

*- 16x or 32x CV modes*

DACin makes sense with mix or is just like normed feedback - but interesting if we can change type of gate[3].dac DONE Nint70

0-7adc basics with XOR

other ADC in

strobe ADCs in

abstract ones

DAC/ADC mixes in

*- 16x DAC+CV to work out -> what makes most sense?*

0-7adc basics with XOR

*- 16x or 32x INTmodes all must use CV! we have too many*

prob modes
special modes-params eg, route, selects

/// *or shall we have 32 INTmodes and reduce CV modes*

//////////////////////////////

- DONEin modeN.h but need to check all/fix modes: for modes which don't use strobe we stop normalled clock and use strobe pulse as input - try OR or XOR
- check if is inverted - is interrupt on falling edge so not inv

*question if for modes which use DAC in ADC if we should NOT route in DAC or at least have both options - tested in N27 and can work/run out*

** 18/1/2022:

TESTED on 19th:
//*TODO19* - retest 6x, 10, 12*, 13, 14, 15, 16*, 18*, 21*, 27*, 35, 36, 37, 38, 39
//-  new ADC modes: 71, 72*, 73, 74,-DAC ins have tendency run out...
// 66, 67, 68 to test-DAC

//- +XOR strobe = 80,81,82,83,84,85+ - now we have strobe scheme so we don't need add modes

add new ones from adc_ into modeN TODO

////////////////////////////

*what are the basic ADC modes?*

-7 here:

  case 0: // basic sequential length of upto 12 bits cycling in MSB first    
  case 1: // equivalent bits: we don't need limit on number of bits
  case 2: // variations on one bit audio - also phasey
  case 3: // basic sequential length as in 0 but with padding if >11 bits **
  case 4:  // special case for spaced bit entry depending on length
  case 5: // basic sequential length of upto 12 bits cycling in - can also be xbits from param, max bits etc...
  case 6: // padded version of SR of bitsin ??? - now is 6 - was 8

- +generic ADCg_ function to implement/TEST (as above) but mostly keep other ADC+ = we get rid of as is only useful for DAC which we have - add modes/MSB there DONE see above

- new ADC_ cases +63+, 64, 65/also int65, int66 tested - 64 not so exciting.
- tested/in progress adc_66,67,68: ADC intmode various mixes of ADC incoming plus/modulo/etc/XOR CV[0]*
- tested: ADC-prob can also be against DAC rather than LFSR - but always CV against - Nintprobdac1_0

- TESTED: in progress: can we have one intmode with CV selecting non-param ADC input modes, can have another mode list or shorter mode list with route bits

- TESTcan also have mix of dac[3] and adc in cv adc_ modes... 66, 67, 68

///TODO:

ADC modes: *prob of entry, prob of return for abstract modes* 22-31 and some others now/new ones... in modeN.h

- theone, it.c, draftdec, extramodes to all be checked for adcmodes, see also temp.org

/////////////////////////////////////

- *for LRC modes we can also have prob using generic top ADC_buffer[12]*


** 17/1/2022:

- DONE: inverting CV for param/int modes as now 0 is top TODO! DONE - to test, but not all work so, changed, and do we need to invert for prob intmodes? no

TESTed/ok dacspeed from itself - Ndacadditself - can also be other variants


modulo LR modes to code/test - done in Lmod and Rmod

TODO: define probability modes, define all bit patterns, ADC modes from all files inc. extramodes, 

prob modes for ADC/ignore cycling:

- invert ADC bit -and- xor/or in routed
- invert [ADC/xor/or/routed) 

- select ADC bit in or routed in
- select ADC bit in or [ADC/xor/or/routed)  

- select ADC bit in or INVrouted in
- select ADC bit in or INV[ADC/xor/or/routed)  

for others/L, R, C:

00 1-TM invert cycling bit - OR with BITIN (OR (routed^pulse)) // OR (routedORpulse) ??
01 2-BITIN or loopback
10 3-INV of above
11 4- BITIN or not into cycling


bit patterns: 

-- where we get bit from=routing, subjected to type of SR inc prob modes, what we do with routed in bits

still LR modulo to test: https://github.com/TuesdayNightMachines/CGS-Serge-Modular-Synth/blob/master/CGS%20Modulo%20Magic/CGS%20Modulo%20Magic%20Guide.md


** 13/1/2022:

- HEAD macro should be fixed but check this DONE
- methods for DAC speed modes: (and now we use CV[w] instead) -> we have now in modeN, to test and to port to other modes TESTED bit *maybe no addmax*

** 12/1/2022:

- dac+cv modes to resolve with new scheme - a lot depends on where we get dac from (cannot all be same but nice to choose - 4 options = 2 bits)

TODO: ADC_for_our_speed - top bits//rest bits as speed/mod for DAC? - DONE in modeN but don't use there

test adc pointerDONE, fill in modes and testings->ADC, DAC, all modes from draftdec, theone, earlier... 

FIXED bug in macro as HEAD CANNOT BE within another macro...( note -E is to show macro expansion, do we need to fix for modeN.h macros?)

1 bit audio is still odd - and length does nothing here *again length issue in adc and adc* - *re-test*

- question of slowest speed as we already have 2^10 for 5v (0.5v octave)

** 10/1/2022:

*TODO: test best fake clk scenario - later when have tidied and basic outlines*

test trigger codeDONE, test multiple ADC and DACS, new macros

problem with init of function pointers from outside file... -> pulled function pointers out of the struct and all fine now, we init them in draftspeed.c

** TODO: Latest notebook notes:

- bump speeds (clock bumped speeds, clock shifts it on one, CV bumps in INT modes (HOW?) )
- bump own routes by trigger (do we do this?) yes in case 16 in draftdec/port!
- more DAC driven routes, use of SR bits for routing/what else, more of RH
- modulo - how that would work? one SR/DAC modulo another?

** 9/1/2022 +:

- DONE: no speed more than 1.0f - how we generate this? increase main.c speed accordingly

xx=numpy.logspace(0, 10, num=1024, endpoint=True, base=2.0) # num is now many we want // in misc/log_gen.py

- simulate fractional speeds and testDONE.

- interpolate or not? as in just keep last value or interpolateDONE -> INTERPOLATE

- draft new structure mode: what we need here... we will need to
  change trigger codeDONE/tested, clkoutsDONE/tested 

- will need clean up all but just test now...

we changed dac out but will need to change adc for pointer as some modes change it in place...DONE/to test!

TODO/DONE/TESTED: we also need to include stop! in speeds - even now for C modes...

- Right and Left are now seperate 
- Right with mode DAC action, more influence. character as routings, DAC and feedback, other INS into right side too (can be more TRIADEX style_
- do we only use DAC2 as out so this can be incorporated...
- jump modes << or slow down, out per every x shifts... 


* diary sept 2021+

PLAN: put first draft together
from generic we had all modes/options as:

6 bits: 1 1 1 1 1 1
- top bit/speed
- 4 bits routing in
- 1 bit prob of inversion

incoming bit bits summary (4 bits) - eg. prob of:

- pulse (if we have) (1,3)  3 bits- mod below?
- routed in = all - 2 bits still - none, route, route/loop, loop
- return/loop = all
- ADC (0) - 3 bits for 0

route in and logop bits:
1111 4 route in bits x 3 logops = 2 bits per... 0, none, 1, xor, 2or, 3leak = 8 bits = 255 too much for CV


trial bits:
pulse/cv speed, input ADC/LFSR/no, output DAC/else?, type SR, type SR, type SR(3 bits of types=8), routing from (4 options)  
1               1     1            1                 1        1        1                           1 1 1 1 - 4 bits just to make it easier but could be less
[11 bits]

speed from DAC/which DAC?

*\\\\\\\\\\\\\\\\\\*

- idea for 1 or 2 versions with different modes... also why generic version is silent on early/first modes - no incoming bits or loopback/fixed
- or major/minor modes from left side???


*QUESTIONS:*

- lengths and changes
- major/minor modes from right hand side
- OR into top/ADC
- generic logics/ all/ logic bits

- if each SR is quite different? or stay generic? ADC and DAC are
  already different, maybe LR should be or can also be swopped,
  re-routed, more routing options on those sides perhaps as extra
  modes

L as delay/entry, R as feedback and DAC - what makes sense for each?

but then ADC and DAC become just about input and output??? ADC in is fine (but we need options to OR in sometimes for pure ADC style modes...)

// re-check generic bit options above

- resolve split personality of patterns and cv//audio filter/crusher (split of modes at top cleanly? or but then what of speeds...)

TODO: re-test ADCs, *fill in CV/DAC modes for DAC and decide/port new LR modes*

[possibly reduce volume of final dacout amplifier as is 10vpp - but leave so!]

2/1/2022:

new approaches: function pointers, try speed scheme from WORM so also oversampling  and interpolation - draftspeed2.c

trial with oversample etc (now divider is 32/32 or 32/64)... seems work fine but we don't get slow enough for CV speeds...
(for cv/dac modes - but that means fullspeed pulse modes will be slower by default??? or we slow down cv modes???)


how to implement function pointers...??? as bit selects???




/////////////////////////////////////////////////////////////////////////////////////

31/12/2021:

- back to testing with OR in on ADC modes (*use XOR for logical/nonadc ADC in modes*)

- tested all ADCs and DACs now - DAC section is a bit samey...

- if we use DAC3 for DAC modes input in ADC is very easy for feedback to run to 0...

    // maybe lose just cycle mode

30/12/2021:

TODO:
- DONE change default dac for all except w==2 to simpler (but we can't just & 4095 for shorter lengths)

- ONLY works for some so removed->try OR in of RIGHT side to top (logic in routings) - in mode 0 and ADCDACETC macro, add to ADCONLY
[OR in at top gives more natural effects but fails too many times - how can we keep as an option? with bits, as one ADC mode]

- DONEtrial of another approach to fake clocks (but would be better as own ghosts???)

question if right hand has more limited trigger or toggle modes

again clash generic LRupdown and more individual...

8 or 12 bit spacers CODE at home

- DONE: bump and toggle routes via trigger as LR case 16
- modulo? // addition of overlapping registers

case 19 to retest on 0 for incomingsDONE

looking at generic code and inputbit there which is not used - more suited to patterns/abstract

resolve split personality of patterns and cv//audio filter/crusher

generic: topbit is speedfrom, 4 bits route and 1 bit doit as prob mode or not!

29/12/2021:

- clk is now HSE and should be 180, we run with 32/16 divider and seems fine
- other small changes and fixes

28/12/2021:

- speed seems to be a big issue now...// how to speed up?

- but there will always be a slowest round of options so doesn't make sense just to speed up some of it if not all

-2. what is in main interrupt loop?
-1. how fast are other interrupts
DONE-0. are we running as fast as we can 180MHz or so... clk is now HSE and should be 180, we run with 32/16 divider and seems fine
1. not execute all DACs but just use SR (and what of shifting? - we simplify to new mode 66)

2. different structure so all in one go w0-3 and slow down all...
3. faster ADC, different structure//one by one? what does sampletime change?
4. generally faster codes, ifs, swicthes, leave out some things
5. check speed of generic code
6, mix of slower and faster modes
7. idea of major and minor modes still and mix between and how we can achieve this...

issue in general to resolve: 
- length as parameter for output (then we need to fix on length as 12/DAC or ignored, or CV so that parameter can have different functions in DAC).
- arbitrariness of modes and positions (L, R etc), again question of being between generic code and very specific modes...
- fake clocks

// also fake clk for lower sometimes gets stuck

- still working/testing ADC and DAC!

- confirming that for straight through length (above 11) doesn't change anything (also length of left pass through) - becomes one long sr

- re-check paddingsDONE- doesn;t seem to effect much as we still have freq of padding?

- how 8 or 12 bit spacers could work

// some problems programming, also had to slow down main.c TIM2 to 10 prescaler - not sure why?

26/12/2021:

- think in ADC of reversing for MSB or at least doubling a few modes - we already try a few, also think more about size and padding

24/12/21:

- think steppiness is from nature of SRs, implementing few other adc, dacs and also MSB dac for MSB first out so is first in and gets shifted right
- sigma delta also makes sense so phasing i guess is normal


*- how to get 8 bit spaced out from DAC?*

- thinking length for L and C is not so active but depends on modes, speeds and what they are used for...

how to have that extra no route in mode for Right side - just leave it in as there are enough options

23/12/21:

still need to test all ADCs and think on steppiness of DAC

*add more binroutes///*

[- add right hand mode 0 where it sets own GSR to 0! so no feed through...DONE/TESTED fine...but skews modes/left in anyways]

Run through of ADCs:

-  length-11 was correct

- mode 2/one bit audio ADC still has phasing despite a few changes...

- fixed dac mode 0 for shortest one bit length - still steppy and added one more dac mode

[why doesn't length of intermediate SR change much/anything - changes nothing if run at same speed // because gshoft is always new]

22/12/21:

-ADC remove cycle and replace with no pass thru//finish DONE-changed modes 0 and 1 for ADC!
re-ordering ADCs but re-check which ones need parameters - put param[0] for all...

- drafted minor/major mode structure in extramodes.c

TODO: re-test all ADC or/esp11, classify LR modes

- for INTMODES: how many speed options here? just keep as pure option so can have 16x INT modes and 3x4 DAC


/////

-removed case 15 from adc cv modes, 10,11,12,13 strobe modes as also boring

thought of only having 16 adc modes but makes no sense for routings - back to 31 but re-ordered and need to re-check params

7-13 are all strobe modes, 17 too - reduce number of strobe modes

15,19,24,25,28,29,33,34 not in CV modes

ADC group by:

-type of input (ADCbits?, LFSR, clock etc)
-strobes/otherparam

Important adc: xbits, one bit, 4bits in (case 16), padded + LFSR etc...


21/12/21:

- check each ADC/DAC in turn - note that modes in adcetc.h don't match the case!

ADC (0-19 now):

TODO: new adc with x bits ADC in subjected to LFSR - doesn't work but added versions of these

0 should have adc in and another mode no in with pass through so all 0s still runsDONE

tested up to 11 (12-19 todo), fixes trigger as static/is it needed?NO/replaced

DACs:

DAC: 2 (is a bit muffly at long lengths - can change divy to fix this in resources.c) RETEST

mode 18: toggle is more exciting for 11prob mode/// whether to change that toggle in LR modes? we did!

changes to case 10 in dac, 11 doesn't really work - replaced with 9, and we had to add missing param[2] in draftdec


///////////////////////////////////////

- DONE: added in normedd L,R,C clocks from Cspeed2 - using new count5 - seems to work// *can also have LR as DACs?? maybeDONE-TOTESTwithINTMODES*


- idea of major modes on R (say 4) - for different ways interpreting bits // different probs // as we have multiple dacs 

// base some on generic but we need to fix 0 no routes/in to default to 1

but problem is we cannot mix and match these... and we can kind of implement similar bit interpretations anyways

TODO: 

20/12/21:

0-15 filled - to test ADC and DAC as fixed and also all modes to find weak points
15-31 modes to fill and rest to figure out this week!

////

- grouping early strobes

proto for SR>DAC is: if ((LFSR_[w] & 4095 ) < dac[LFSR[w]]) // as that is 12 bits and shifted already 

change/d all modes in extramodes.c to use the dac[LFSR[w]] above rather than SR or both & 4095 but if SR is small...


which strobe=prob modes work best with DACout 4x4 in modes 16-31 // we use 00 and 11

4 bit mode works well but does it always need to coincide eg. all 4 bits - seems fine

- fixed bug with many [x] and not [w] outside loop 

- TODO-   // 4x4 bits prob of routing in GSR  so we need 4 probs of x bits?
- DONE: decide/ if implement simultaneous shiftsNO! stick with old one as seems most logical and we don't change order...

16/12/21:

- DONE: probability of advancing a GSR - as mode 14 test 

- DONE/not working as no entries...x bits of sr << y bits of gsr - shifting bits ORed in as/to new SR

15/12/21:

- // can also be change access bit but not cycling bit - also cycling version of this! TODO!->DONE/TODO: mode in which CV/pulse changes which bit ofghostSR we access - mode 13 works fine	
- TODO: also test with CV access for these bits

14/12/21:

- what are 4x4 DAC modes for 16-31: 1cycleandroute, 2/3probs, 4-4bitshuffle? - see temp.org for modes list

- TODO: probability of advance on trigger using CV as probDONE-tested

- organise modes we have in some kind of scheme: 

speed
incoming: routes, manipulate ghosts, change routes, basic routes
what we do with it: prob modes, where we get prob from, what logic we use and where we get choice of logic from?
special modes

or group by way of: strobe in cv, cv in intmodes ???


13/12/21:

- trial of changing way it updates = if new[w] - not sure which to use

  // testing for simultaneous shifter - but what of modes where we hold back the gshift eg. modes: 37, 48, 49

- DONE/TODO: mode in which CV/pulse changes which bit ofghostSR we access - mode 13 works fine


10/12/21:
- re-checked logic of ghostSRs and compared in test2.c

- question of order of SRs (w) - trial changes to tables of orders // test2.c first

// order does of course make a difference/depends also on routings

also how we can update/calculate simultaneously (how this works for feedback, or is a delay necessary?)
- more is that all runs at different speeds///

9/12/2021:

TODO: list regular and extended modes!

- added toggle/pulse prob modes 7,8,9,10,11

- added mode 12 with non-adc ADC_ in to LR - 3 diff possibilities:
  ADC-5, pure LFSR on length, 30 1 bit OSC, 32 clock/square (these
  could also be bits or bumped toggle options)


8/12/2021:

- *manual idea - we have say ascii layout on dot matrix and then subject this to shift register*

- moved the if (w==1 || w==3) // if pulsins[w]!=0) out of the macros as most of the time we don't need to test this - this is now LR[w]!

- for pulsin not so much difference of XOR, OR and we lose AND for zero pulsins... so leaks or xor it is and leaks needs changing probabilities

we try now with own SR as probability and this seems to work well for pulsins

?can also use GhostSRs for probs?

- trialing 2 different bit interpretations in draftdec - DONE

- if LR can have non-adc style inputs (eg. LFSR, pulses, clocks etc) XORed with incoming routing - how many options are here?* DONE
- this could be an INTmode!

- basic prob mode of entry of routed or not (into cycling). and just xor puls in...DONE - mode 6

7/12/2021:

- attempt grand mode with SR and many bits above - we have 8 bits route and logop and 5 bits probability DONE

- in ADC_ added cases 33 and 34, adc prob modes with adcpar (invcycle is more like ADC mode if is without routein)

- TODO: generic prob/strobe/toggle modesDONE

6/12/2021: 

- fixed major problem in MACROS draftdec // if else...
- one bit filter DAC always now has param and is mode 2 - so param can
  be cv/param for variable filter or can be calculated from
  speed/param

3/12/2021: listing modes in temp.org to plan out and also check gaps: conclusions:

how we can temporarily fill modes and change these later? macros but then we have \ always end of line to think of and no comments. maybe...

- question also of modes with global route table or which manipulate their own routetable

*we need more modes which take cv or dac and use this for routing, for probability tables, for logops*

- summarise again probability modes and all modes/cv/INT: = we have too many

32 CV modes, 16 CV+DAC modes, 16 INT modes (very basic and prob driven)

1. basic pass/cycle/passandcycle with logops for cycle and for bitsin

3x logops: xor, or, leaks...

1-pass in - xor pass, xor puls
2-cycle only - xor cycle, xor puls
3-pass and cycle - xor pass, cycle, and puls

4-xor pass in and or puls
5-xor pass in and leak puls
6-or pass in and or puls
7-or pass in and leak puls

8-xor pass in, xor cycle and or puls
9-xor pass in, xor cycle and leak puls
10-or pass, or cycle in and or pass
11-or pass in, or cycle and leak puls

// further permutations of these or just leave to CV/param bits for logops

2. prob modes: 

- where we get prob from. CV/int, DAC/cv&int, DAC+CV/int, param[x]/cv

prob<DAC:

1-inv routed bit/ xor puls
2-inv cycled bit/ xor puls
3-inv routed and cycled bit/ xor puls
4-inv routed, puls and cycle bit
5-inv puls and route in

6-xor cycle in with routed or not

limited selection as above with prob<param

less of pulsins and probs as gets too much

- prob of: -invert incoming bit (ADC/mode0/routed, cycle or pulse-ifwehave) or not
           - XOR bit in from->[cycled//ADCorLFSR//pulseifwehave]->routed in or not
           - incoming bit(routed,ADC,pulse-ifwehave) or cycling bit
           - as above with inverted cycling bit
           - changes/manipulations to the ghostSR

3. binary route/prob/etc. tables - CV as binary route/prob bits/

look again at binary routing tables and prob bits

4. experimental/overlaps/other functions 
5. use of strobe in cvmodes - doubles prob modes

so strobe can toggle or straight do: invert, XOR incoming, incoming or cycle, incoming or inverted cycle

6. use of CV in intmodes // these are probmodes so other uses

7. change global routings
8. maniplates of GSR // GSR on prob, on strobe

modes to add:

- clock101010-DONEinADC32
- toggle ADC entry or pass (0)... check in adc? ADD in modes
- where do we add prob of ADC entry bit - in mode itself - but this doubles up modes//how to deal with that
- prob to shift binary/routing tables

2/12/2021: 

also pulsin_logop  - placed pulsin within adc macrosDONE
and logop in routing (below) 

ghostSR manipulationsDONE

[[[what those manipulations could be - freeze itX, freeze its lengthX, reverse it - but how to reverse based on length - reverse lowest srlength bits
in draftdec, XOR it with SR DONE -> these can also be for circular routes too

1/12/2021: now draftdec

- *logop in routing too*

summarize: TODO: draft all modes in draftdec but we need 14 modes for DAC (lose 1=mode9)  and 29 (lose 3=modes15, 31and19) for ADC, fill in LR modes for these and test

but possibly mode prob modes in ADC or keep these more for INTmodes? think about

but we don't delete them

- check clksr in adc/dac, clksr is in ADC_ = 19, in DAC_ is 9 sieving out  - maybe dont use clksr/both or use clksr more in LR modes

prob for DAC modes, range of clkin params (how to measure?), 

manipulation of ghostSRs: -> eg. from seg2.org: - XOR whole ghost reg shifted by another into itself
 
- TESTED:full test of latest prototype: audioadc?, ADCsX/CVX, DACX, clkins, pulsoutsX, pulsinsX!

30/11/2021: 

*- probability modes for DAC modes are important*

- 333 and 334 tweaked and working, need to watch that we have GSHIFT already in ADCETCblah

29/11/2021:

*ADC_:*
- otherpar modes: 24(len), 25(len), 26(comp), 28(prob), 29(len), 30(lengthforosc), 31 (lengthforosc)
- REGG modes: 2/lfsr, 4/lfsr, 5/lfsr. 6/DAC. 11/lfsr, 12/lfsr, 13/lfsr, 19/dac, 27/lfsr, 

*DAC_:*
- otherpar modes: 10length, 12-5bits, 13mask, 14mask, 15beta 


for otherpar as len let's use otherpar=otherpar&31 rather than >>DONE and we restrict in all cases &4095

all otherpar assumed as 12 bits!

- that we don't need seperate modes for int/cv in adc_ or dac_ as they all use otherpar... we just need to decide which modes...

add modes 15 - param as bits 

MAJOR question is how we can constrain param as INTcounter to be 12 bits - DONEwe need to get an idea of range of param as we treat as 12bits? - param[]

  // crash detect ++ 32/64 in main.c is 14KHz //and/or speed check... we have 32 16 which is 4x14=56KHz

so TIM2 loop is 56000 per second - one second is 56000x2// count to check

1khz is 56 - rather 120 or so...

100hz is 1280 so for 4095 12 bits we have 25Hz

we need to constrain to 12 bits for otherparDONE


TODO/DONE: - modes which manipulate the ghostSRs! - what those manipulations could be - freeze it, freeze its length, reverse it - but how to reverse based on length - reverse lowest srlength bits


26/11/2021: 

- new additive test mode in draftnov.c to test and expand...

/////

18/11/2021: 

QUESTIONS:

- 0-31 all ADC modes - as loopback doesn't make so much sense, only thing would be probability which could be part of modes

(probability of entry or not of ADC bit) - doubles ADC modes though?
these make more sense in INTmodes (also where we have no strobe modes
so this reduces list)

arrange and organise

- again if we don't use redirection of LFSR[reg] then in some ADC modes - how we could work with this//? or replace with reggDONE

17/11/2021:

[fixing some of generic.c for performance use]

Question of max length bits in or padded bits in ADC

- where we also change logic of incoming pulsin bits? 

- test param in DAC for one bit filter/BETA - DONE DAC mode 15

start to fill in draft modes/organise ADC/DAC modes...

16/11/2021:

- shift x bits in/shift Gshift round DONE mode 67 in theone.c

- tested speed with clk and is fast enough so far (re_check after all switch/cases) - can even go faster:   TIM_TimeBase_InitStructure.TIM_Prescaler = 8 ???

- TODO: fill out adc/dac modes in new draft, 

- maybe port in more modes from it.cDONE

- and also maybe deal with ghost tapsDONE

  // try putting LFSR feedback into smaller coggSRs - mode 62 TESTED

- added  case 64:// as 63 but we try INTmode with CV changing length of incoming routes

65 with strobe as barrier DONE

- question of generic/global routing and feedback into itself????? 	if (tmp&0x01 || x==w){   // if we want self-feedback in route whatever... MAYBE
and/or variations of this?

15/11/2021:

- for all w==3 modes except route changers we need to set count back to 0

global routings:
INTmodes: CV as route (CV cycles through list or changes list then binroute would change) + fixed new routes

CVmodes: trigger bumps up binroute + fixed new routes, trigger toggles altroute/regular routes (also prob?)

DONE: fixed otherpar and strobe in DAC...

TODO: port in first it.c modes above// first a few attempts in draftnov

13/11/2021:

- case 59, generic routing with ADC working // test in case 59 w==3 global route changes...TESTED - in case 59 and works ok...

60 very generic routing with MACRO fill in/ 61 speedCV complemented by trigger

- check out macros with variables to throw in - test in case 60 now but possibly too generic or we need to add probabilities...

QUESTION of how to manage modes now - first finish ported in modes/all modes // check logicand then start to see how we can draft modes...

12/11/2021:

- case 58 approx generic mode is workings

- leaks using RSR is a bit odd, but we can have different leaks which could LFSR...

11/11/2021:

- thinking if to have global routes or just individual changes to
  routing table? could have global if have say 4 R modes multiplied by
  4 route modes for each section... test global routes...

- not to have several ADCs in/no multiple DACs - but still keep basic dacs for 12 bit length

10/11/2021:

Q is of a new structure

- LARGE notebook notes: possible to use Rmodes as global modes for:
  global routing changes, +multiple DACs out/mix+, +potential several  ADCs ins (in different modes)+. 

  In CVmodes we would either have fixed modes brought in or param, bump
  up routes. In INTmodes we could use CV for modes.

- probability also to bump/shift or otherwise modify routing/logic etc. tables (single or global)

prob mods bits/masks bits

defroute is the one which we use generally now - unless we are in multi-routing
modes? (or DO we make this global default, but is much slower - think about)

pass/cycle/cycle and pass as routing only

////

- TODO/some for finals: more param[x] modes perhaps, 

different speed options for projected CV+DAC modes 32-47, 

new prob modesDONE, 
check bit routings againDONE and added for testings new bit modes (bits for prob and logop)DONE

try out new routing (eg. bounce back)

can add more mixes in ADC (adc in/lfsr/otherdacs/mult dacs etc)

- removed intcnt but need to fix triadex mode 35 - q is what is range of param? FIXED

- added logopx which can just return our bitn

9/11/2021:

- possible multiple ADC in modes,,,, 

- added case 30: adc |(xor TODO) with length of bits, for INTmode this can also be CV-param

in ADC_ otherpar can also be CV for intmodes

- expanded ADC_ function for extra params but should decide on how many bits for otherpar (dac is 12 bits so) and then fix length/restrictions there

- added logic table bits and fixed leaks in logop for modes 25 and 26

- notebook notes: ADC bits choose: what is compared to what, what is source...???

- one INTmode for ADC/DAC could use CV to select 1 of 64 modes - but
  then we have problem of otherpar being different sizes, sources
  eg. from strobe, for len bits etc.

- mode also (maybe INTmode) to select different DAC modes for LRN too!

- to think about/test multiple DAC outputs - additive, sequential, what else? and how these are signalled...


8/11/2021:

- how to expand and contract routing for each SR. what is contracted=just-to-itself, most expanded= last one..., between=

long routes would be n-l-c-r-n

Q. of whether to have extra ADC/DAC modes available as CV options on 1 or 2 INT modes - see above - would also need to be another long case/switchDONE

- INT modes need to use speedCV (see list in notebook)
- so the 16 INT ADC/DAC modes need to use CV
- added modes, ADC prob mode...

6/11/2021:

- toggle/record/keep frozen bits and keep these ORED with the shift register as it cycles or does whateverDONE now as DACmode 15-TEST!

5/11/2021:

- reverse SR modes - 42 and 43 DONE 43 is not so good/reverse cycle round/// try combine with 42 -> 44 DONE which is better

- toggle/record/keep frozen bits and keep these ORED with the shift
  register as it cycles or does whatever - testing now as DAC but it
  should not mask itself???

4/11/2021:

- question also if we use dac[3] and this also does feedback in - maybe try dac2 or dac1

- also if we make use of dac[x] where do we set this to be other_than_default otherwise we may as well use SR instead (except in multiple dac mode)

//TODO: fix on multiple DACs and which DAC or SR we use by default for each SR...

- DONE: fixed param in DAC so we set par=param[x] or cv in the case! but we need to remember to always add this if need be!

- DONE: changed DAC_ with extra params, added ADC speed and comp modes, some work on DACs, seq DAC not so exciting...

- bit length can also be CV - how to put this in as DAC is quite fixed in macro

ADC modes:

- that we can use param other than LEN for bit length in some of ADC and DAC modes... (eg. CV also as param in INT modes with these)DONE

so we can have standard 12 bits (len==11) adjusted to length, full
length (whatever that is) regardless of len, and xbits from otherpar -
in these cases length doesn't do much...

DONEpadding for seq adc, dac and strobe/adc modes 

*basic routing modes:*

- route in from sr[x] 
- cycling bit
- LOGIC (or,and.xor,leaks) - route in from sr[x] and cycling bit // xor one would be rungler in adc mode with dac from other in, or would be CGS

and LOGIC of pulsins

TODO/check: *all classic probability modes:*
classify:

[prob modes for ADCin/w==0 prob of entry of bits/vs cycle etc, DAC modes can use regular prob mode]

prob to DO:
invert cycling bit (TM)
invert incoming bit (ADC or route or both)

take incoming bit (ADC or route or bothLOGIC)/OR/xor it with cycle bit (RUN)
take incoming bit (ADC or route or bothLOGIC)/OR/LOGIC it with cycle bit

incoming bit(ADC or route or bothLOGIC)/OR/cycling bit (EN/WIARD)
incoming bit(ADC or route or bothLOGIC)/OR/INVcycling bit

////
TM: cycle bit is noise vs. comp less than 1, otherwise invert cycling bit

RUN: ==not prob mod but could be made one: XOR cycle bit with input bit which
comes from oscillator [in benjolin the DAC out effects some parameter
of both clock and data] eg. DAC effects speed/clock of SR

WIARD: noise/comp selects new input or loop back/inverted loop back (jumper)

EN: LFSR SR bit is loaded/not loaded onto recycling SR. loading can be random (based on LFSR and set of probability switches)

*comparators for probability and ADC depending on INT/CV mode*

/for prob:
1. if LFSR/SR/DAC<CV  // int mode - as DAC is not necessarily CV!
2.if LFSR/SR<DAC[x]  // cv/int mode
3.if LFSR/SR<DAC[x]+CV // int mode
4.if LFSR/SR/DAC<param[x] // cv mode

can also use comp clksr_ as SR, and adjust routing of SR for comparators

/for adc:
compare to: CV, DAC, CV+DAC, to clksr_, to param - feed these into otherpar

could it make sense for DACs? DAC could be shifted by CV or by clksr_, other DACs.

CV modes which deal with CLKIN - as a bit // - as a condition // - as a PARAM

- clkin in can toggle entry/no entry of new bits, cycling etcDONE do also for ADC
- clkin in can bump up/shift left/right the routing table, speedfrom table, logic table, dac/adc table?
- clkin in can mask bits as for DAC etc. or SR etc - if we pull it in to a SR for each of N,L,C,R  but bwhen do we do this as can't be in INT
- clkin in can also slip/slow/bump up one CV speeded SR = slip, freeze or jog SR on CLKin

*how we use CV in INT modes (as we need to use it):*

- as comparator for ADC in (and for DAC?)
- for LR modes: as comp. for prob modes, to assign routings, as extra mode selector
- as modifier for CLKIN speed-divider?

3/11/2021:

- DONE: more macros but still need to test/re-test all

- if pulseouts should be after shifts ??? guess so...

- in ADC: why (length-3)? to get down to 1 bit so could also have option for full bits!

- tested speed/stop again for all modes? - TO IMPLEMENT as makes sense
- fixed case 3adc and case1dac so we can have as many bits as 32 for equivbits setupDONE/TESTED
///
- incoming clk bits as further SR in main TIM2 loop (question of speed
  of this now) - or do we just do this as ADC inputDONE but could also
  be custom oneDONE - use also as sieve (case 10 in DAC) - what other uses? as comparator for ADC in?

- strobe or copy clksr in // as adc option... question is how to strobe in - on a counter/length? added as adc case 19

maybe list the SRs that we have available...

shift_[x], Gshift[x], LFSR_[x], ADCshift[x], ADCGshift[x]??ghostforadc/strobe, GGshift[x], clksr[x]

how to swop between relevant ones?

- probability modes can also use DAC, clksr etc,,,  what we compare to what???

LFSR<CV(most), LFSR<DAC+CV (17), LFSR<DAC (18), LFSR<PARAM (19)

also maybe more use of comparator with these in ADC mode

////

- start on first 16 modes/check all ADC/DAC options

- tested speed/stop in case 0! add to templates
- new full 32 bit ADC mode with padded bits in - also add strobes and other ones using this 

2/11/2021:

bit entry SR (from each CLKIN) can also be used for TRIADEX style thing,

all SRs/and CV can select routing/logic/speed bits

ADC could also be used in probability modesDONE

templates for speed/dac modesDONE/, INT modes but also how we deal with split of modes for DAC/ADC? (if...)

test new speed options!TEST!DONE!

////TODO:

- TODOs from theone.c - eg. extra DAC modes but now we have too many modes/cases,,, maybe to simplify

LIST MODES so far! and notation of modes

- what modes we already have implemented? also what ADC/DAC - plan to finish/draft?

- feed back RSR could have stop/no motion at top of speed (but how to do this without an IF clause?)...

/////

TRIADEX notes (from below etc):

- in original: any of SR bits (from any SR), CLK and its divider go as 4 bits into parity generator
- we could use counters from clkins as indicator of which bits from which SR to parity-inDONE

////////////////////////////////////////////////////////////////////////////////////////////////////

1/11/2021:

- DAC_ re-test case 7 and 8 as possibly fixed mistake there...DONE

TODO: 

- macro for pulse outs DONE
- what we need to test/implement and list of modes...

19/10/2021:

basic modes: pass through or cycle is toggled by clkin bit

TO TEST/adc strobe modes a bit similar...

new adc strobe modes: 12,13,14,15,16 - don't notice so much... maybe replace with toggles TRY THIS!DONE

new dac strobe modes: 5 and 6... - 6 toggle one works ok


- hold last DAC value (or ADC/set of bits) on a CLKIN 1
- toggle hold on a CLKIN 1 

- these are like the strobe? strobe is different in both cases - in DAC case is just inverse of strobe

15/10/2021: how to think about squash and expand routings on level of individual SR

- DAC out from ADC in

route goes N->L->R->L->R so implies sequence - order through a
sequence, and a length of sequence but does this not need to be agreed
on across modes as each SR just takes care of WHERE it routes from... but this could for example cycle every X turn 

cycling of in routes!

0123
eg. for N/0 cycle would be: 3,2,1,3,2,1 (depending if we include itself- 3,2,1,0)

what would squash be? 3,2,1,0 to 3,2,1 to 3,2 to 3(R) and how we signal the squash...

14/10/2021: for 4 bit spacers maybe also have options for different routings... squashed routings, compacted routings

sketch out modes:
CVspeed:
1-15 -LR simple modes/all inc prob
      N 8xADC x2 - pass in/circle_and_pass or 16 ADC modes with pass in only!
      C 4xDAC x4 - pass in/circle only/circle and pass/prob

16-31 LR - exp modes
      NC - any match modes 4xADC, 4xDAC

CV+ADCspeed:
32-47 LR - modes mixed
      NC as 1or2

INTspeed:
48-63 LR - mix using CV params - prob,,,
      NC 4x ADC/DAC and prob modes    

13/10/2021:

- fixed 4 bit spacers i think... mode 27/28: xor returning, also 4 spaced equiv bits for DAC DONE/TESTED

- ADC as seperate condition in each mode, maybe DAC too, subset of basic ADC and DAC modes...

so eg. 4x basic ADC and modes would follow: circle, pass on, circle and pass, basic probabilities
and some more exotics...


12/10/2021:

plainer that input mode NSR is most fixed of all, we can have multiple
DACs out from anywhere, also everything does not necessarily need to
be on NSR

- array of certain values eg. dac for each mode, how to simplify if at all?

- probability modes with routing/adc selects for incoming bits

- spaced outTODO

- triadex muse: clocks/divisions/SR bits selected and XOred back in...

- how we select those options -> we need 4 bits back in (so 4 to select from other SRs, bits from own SR)...TODO

or ghost SRs - select 4x bits 0->SRlength from 4x SR? or just stick with itself - variations on parity bits

- inspired mode where we XOR in other SRs. -- and we use static SR or we wind through SRs... or multiple XOrs in -> modes20,21 DONE

//new defroute: uint32_t defroutee[4]={3,0,1,1}; // 0,1,2,3 NLCR - in this one 3 routes from 1 too
but how do we have this in modes as is same just not for RSR...

one option suggest as clkin flips that routing (or any routing, or advances routing table)... DONE


11/10/2021:

- what we can salvage from it.c: overlaps, SR in SR, how we could pick up or work with other ghost regs, revenants, various 4 bit in variations

starting to think about 4 bits in/out for different lengths: GENERATE:
array of masks, 4 values for spacings, SR with 4 bits in needs to
cycle on those 4 bits...

they need to be spaced out x bits apart depending on length - further array


/////////

- from AC: shifting array of ghost taps, otherwise lots of dependency on pulses we don't want

24:	// Insert pulses into SR at points determined by CV or by pulses in - very similar to mode 2 above - TESTED/WORKING!

25:
	// SR loops within SR at certain points?/sizes determined by CV or pulses in = basic SR of OR with incoming bits - TESTED/WORKING!

// pulse in means a divide/flip flop
// pulse in means double a step..

uses CV as speed/flipflop/clock divider in INT modes

using clock as on/off gating of functions

// also we can have one bit data with selection of params for BETA/low pass filter!

DONE: sketched out probability modes - to be filled in, further ADC modes and tests...

- how to reconcile multiple modes with multiple ADC/DAC options -
  reduce number of modes in those cases ...

- working through probability modes - to figure out how ADC options (and DAC) fit with these...
eg. with adc in mode do we do for all 

- also further question if we have multiple ADC ins? (ie. max one for each register?)

- 4 bits In/out with DAC/ADC

///

1-Basic modes/DAC/ADC modes
2-experimental modes DAC/ADC too: eg. *set parity points for LFSR or for entry from other SR... (4 parity points or more max?)*
3-probability modes
4-routing modes/extra speed modes

DAC and CV, INT and CV -> speeds

8/10/2021:

- adding ADC and DAC modes: some still to test like strobe driven...

- where we place probability code?

question of overall structure now:

speed/where we get speed from?

route/bits/in + modes which manipulate routing or SPEED table (with DACs, CV, INT/CLK options, SRCLK)

ADC/DAC types

special modes/emulations: prob modes

7/10/2021:

- modes 6,7,8 are quite destructive noisy with pass&loopback for DAC and ADC - so maybe remove these
- try counting pulses (12 bits=4096) within length of time for use as parameter...(q of speed...

main.c TIM2 32/16=// period 32, prescaler 8 = toggle of 104 KHz - so 50 KHz

- re-did param code so is now time between pulses...

- DONE/TESTEDtest equiv bits ADC code, add in onebit oscillator

4/10/2021:

First 5 modes done with LR/route/logic options and ADC/DAC options-> these also need new routes and logic

TODO: experiment more with leaky code and timings, triggerings of leaks...

/////

add in DACs into ADC and DAC modes/INT modes only if we use CV???

//for input modes
CV/param//+DAC as input
CV/param//+DAC as comparator for input
CV/param//+DAC as input spacings [where is placed into SR]

CV/param+DAC as output spacings

CV/param selects routing 
CV/param+DAC selects routing


Try to condense what we have here in segmodes into:

- ideas for modes to be implemented/tested:
- layout eg. speedfrom, routing, ADC/DAC:
- generic/functional ideas eg. how we count pulsins:
- ideas relating to LFSR, ADC, DAC etc...:
- file under OTHER:
- esoteric:

INT as signifier for interrupt/trigger modes

- re-routing is not so important - can be in INT selected from CV/DACplusCV
so CV/speed is more or less fixed routes only maybe with one exception

Q of more trigger modes?

- can route DAC(+CV if INT) -> ADC inputs

- different ways of counting pulseins (eg. reset generic counter on pulsein) or count gap between pulses = number of pulses in time xDONE

- swap over SRs on pulse in?!!

- INT mode: pulse ins (only have L and R) can toggle SR on/off - eg. hold it even against new CLK/INT

1/10/2021:

from below: for 1 or 2 of trigger modes: SR->bit speed (ANDed with CV/trigger) eg. if && bitx//and_train of pulses also (see below)

- idea that CLK pulsins could trigger train of x pulses at speed y
  (eg. y by CV, by DAC) - descending speed, speed from other SR, train
  from other SR - how to do this?DONE 104/105tested...for INT-DONE

////////////////

30/9/2021//1/10:

- possible SR modes adjust/set certain settings which stay that way until they are re-adjusted?

- that incoming bits/pulse bits could also be formed in SR which can be used (as DAC, as whatever)

- interrupt/trigger modes with CV as divider!

// question of how to organize/list modes as there are simply too many options even with fixed routings

eg. each has:
- basic/logic//type of SR eg. simple pass, loop, pass and loop, other logics, probability of bit in, of a flip

- for CSR we have DAC mode!
- and for NSR we have ADC/LFSR (2 options plus more esoteric options for special cases)

TO RESOLVE then:

1- question of NSR/PWM (which DAC we use - RDAC by default) and more about normed CLKS (L,R,N)
//RDAC for NSR/PWM and ghostSRs for normed clks (with speed of these from what, from RDAC?)

2- which DAC we use for speedCV+DAC// all the same? selected by what means, fixed but different eg. 
N-R
L-R
C-N
R-N
//as this answer also effects next:

3-how we deal with differing DACs across differing modes? do we need to 2x or 3x all modes for all differing DACs?
//just use basic mode for other DACs so we have a fixed dac table

4-list of modes and format for this for each N.L.C.R. also how we deal with N.L.C.R within cases...

5-special meta-modes for say bus of DACs etc.

6-what pulse can do in CV modes eg. PUSH on bits so is like speed plus pulse
7-what CV can do in pulse modes eg. comparator. as well as each as parameters...

other:
- pulses/clkin in can toggle entry/no entry of new bits, cycling etc
- pulses/clkin in can bump up/shift left/right the routing table
- pulses/clkin in can mask bits as for DAC etc. or SR etc
- pulses/clkin in can also slip/slow/bump up one CV speeded SR

29/9/2021:

- possibly we have static routing for R->N L->C and variable for L and R // with ADC/DAC options//but as we note above L and R also have DACs which are used...
 
as first set of modes: what are our modes - DAC/ADC/routings

- for some interrupt/trigger modes we can use CV for routing table...

but there is a problem if CSR CV is normed to speeds of others at the same time...

again question of NSR/PWM (which DAC we use - RDAC by default) and more about normed CLKS (L,R,N)

but as we no have less clk modes we can also use ghost SRs, but at what speed, speed of RDAC???

28/9/2021:

- new speed scheme/cv/dac to test now on speedc/lower one - seems to work well...

- BOM/pos/quote made 28/9 AM pcbcart/ordered30/9

27/9/2021/ notes from last days:

- back to testing in it.c (not generic but slowly port/change that code) - new speed scheme

RESOLVE:

- CV modifier in pulse modes

- fake CLK triggers from?

NSR - always TImx from DACx
L,C, R - from speedC-cv always

what else makes sense - ghostSR but is more complex!

- all simulated modes. eg. EN/electronotes - generalise as probability of new entry/just cycle/of inversion

- test as CV generator

- sequential SRs mean we can also slip one SR or double it (how to control this)

- DAC/multiple DACs -> DAC bus/mix or even one after the other (faster)??? but how do we decide on this:

eg. one SR has DAC out, any can have and is mixed, any can have and is sequential (as is meta-mode not just decided by SR) 

- interrupt modes as 48-63 last quarter...

Modes: // check if we can possibly hit more than 64 modes !?

0-15: CVspeed: NSR, CSR have ADC/DAC options and basic routes in, LSR and RSR have all routing bit possibles, basic logic ops
DAC is fixed from CSR, input bits from NSR

16-31: CVspeed: exp modes, all SR->rerouting options
DAC can be anywheres, ADC also (how many bits we have), resolve this!

32-47: CV+DAC:  simple modes, exp modes, all SR->rerouting options
where do we get speed DAC from - is it always RSR?

48-63: Interrupt/trigger modes as mix of all...

//address issues for each mode (selected) 

other:
- pulses/clkin in can toggle entry/no entry of new bits, cycling etc
- pulses/clkin in can bump up/shift left/right the routing table
- pulses/clkin in can mask bits as for DAC etc. or SR etc
- pulses/clkin in can also slip/slow/bump up one CV speeded SR

//////////////////////////////////

beckett/gray codes for routing ???

21/9/2021:

- how to go further, collate ideas and see how these fit or don't fit with generic model:

eg. in AC Cv modes was lots of use of pulses to do things which now we lose a bit...

or we divide across 2 sets of generic modes, or simply have generic modes for things like routings

- that incoming pulses can eg. change flip or not flip, change routing table, invert mode bits

seperate mode and mode bits: mode determines mode bits (on mode change)

- fixed small bugs (like static in one bit DAC), and routing for fake clks

20/9/2021:

- testing generic SR is it_generic.c

notes:

- had to break down loop though as speed was overlapping/effecting others, can tighten up and make faster from main.c TIM2 dividers
- that we should be able to make bitsize of dac independent from length - maybe?
- lists of modes/settings

- TODO: probability in generic code? TESTING but might work???


17/9/2021:

- question of how we work with probability within generic framework - as in TM etc...

// make it_gen.c + stripped version to test generic code!

16/9/2021:

- idea that CLK pulsins could trigger train of x pulses at speed x
  (eg. x by CV, by DAC) - descending speed, speed from other SR, train
  from other SR

- how to arrange:

CV speed
trigger speed
speed from other DAC (which one) with CV offset
SR->bit speed (ANDed with CV/trigger) eg. if && bitx
train of pulses also (see above)

[SR->fake triggers and mainPWM/normed in - but that is determined by other SRs] -> we need to sort this...
-> how these are all selected as all SR are independent

//MODE - where do I take my speed from?

to resolve fixed scheme eg. CSR->DAC out as we can't have 2x DAC outs simultaneously (or we have bus/mix)?

TODO: implement basic very generic SR for all cases, test if flag in clkin interrupt works so we can place all in main loop

1-Where do I get speed from? if from SR which one and 
1.5-shifting of which bits <<
2-where is the input bit from (LFSR, ADC type?)
3-what is routing for incoming SR bits, cycling bit
4-what is incoming pulsin bit if any?
5-XOR of logic op of all bits and re-insertion
6-DAC output for any purposes
7-pulses out if any

8-fake/pwm for normed clkins - how? or we keep standard?

options/ideas: DAC out runs at full speed and is changed by all/any, clkin interrupts flagged so all is in main loop

  // we can still have specialised SRs but they should all be repeatable
  // so can be placed in a loop!
  SEE:  generic.c

////////////////
how to resolve clock norming?

So we have PWM (TIMx) which norms to NSR clock - this is generated at the moment from RSR DAC

LSR, RSR and CSR have fake clocks - CSR should be from speedc/CV, LSR and RSR???

15/9/2021:

- testing and implementing arrays for puls ins and outs (left, right and c) DONE
- place into not-so-generic pasted LFSR round one at start// DONE

- implementation for Benjolin/halfDONE but need to think about how we
  can make generic one SR clocking another without failure in any loop, and/or generic use of fake clkins

- TODO: Benjolin in trigger mode using fake clks - FIGURE out how to prevent freeze (CSR will have speed)

- so start to think on what general modes for Vienna could be (before we get to rendering as all generic)

// using sigma delta for bit input an low pass out (see test.c)
// all modes with bits in and out

eg.
0-looping only/aka return only!
1-pass on only - straight through
2-pass on and return bitx

3-TM with pass on - trigger mode
4-TM with loop back
5-TM in TM pass on
6-TM in TM loop

7-Rungler XOR pass on
8-Rungler XOR loop back
9+Run with different speeds
10+Run with bits

11other exp modes/trigger modes//what else?

DACs,ADC types

TODO: always have NSR/PWM from RSR DAC for the moment - so to add to the basic/pastey!

13/9/2021:

- clock fake routes: R->L and L->R (output bits of SR to CLKINS), CSR is speed controlled (has to be) - TO TEST!
TESTING but tricky so made all from speed... NSR/pwm is from DAC

- make latest TM SR more generic/start to port to arrays/tables

11/9/2021:

finishing DAC and ADC generic options:
TODO// other options are: comparator, equivalent sets of x bits incoming 

possibly we don't use fake pulse ins for norming left/right - to test that these don't effect incoming
(but we do need to use CLKins normed for L,R,C) - test with incoming bits

10/9/2021:

inline int bits(uint32_t reg, uint32_t length){ // function returns bottom length bits of SR reg

and another inline function which returns different kinds of DAC from
a certain SR eg. standard DAC of x bits, equivalent dac of x bits,
what about one bit dac (more involved as takes time but we should have
a pointer to that value????

9/9/2021 

// always do DACs - but how these are handled according to length as we still want fixed number of bits

implementing TM in TM: slowly start to see how to abstract as work through and implement all modes

- TOWARDS: basic framework to use in Vienna! (using one bit DAC out
  tho which we could also include in routing tables and as an always?)

- each SR delivers DAC, how to do tables which don't allow for overlap of DACs eg.

1000
0100
0010
0001 for each table

structure for all eg. speed from routing table// all is defined by tables/arrays which can be routed

in test2.c speedroute as array of pointers to values...

pulsin bits L, R is XOR always with new bit

basic modes/expanded modes across split of cv/speed, pulse speed...

/////

how to make uncomplicated generic SR options which can interact across all sets of:

1st set: simple SR modes for each SR with fixed routing
1.5th: simple modes but with very specific configurable tables for routes eg. speed routes...
2nd set: generic SRs with configurable routings
3: complex routing with DAC, ADC etc.

generic as all routing is internal - we do not dictate to other SR...

// also from triadex muse:
--> this is an XOR of 4 bits - selected from clocking bits, on/off bit and from shift register feedback

that we can have XORs of bits from other SRs entering our SR
so table would be for 4 bits from 4x maxSRlength=32*4=128 (ignore lengths)

thinking about multiple routing for DAC, clock DAC and ADC??? how this might work as gives flexibility for timings

then we have x bits:

routing / DAC output / LFSR feedback / ADC IN 
1 2 3 4 / 5      /  6            /  7

extra bits: clock DAC/pulse for speed with any offset(CV), comp DAC ->9 bits, 

speed modes: CV as speed, CV plus DAC as speed, pulses, pulses from SR, combination of... see more below...

// and how would routing be for pulse modes: pulses, pulses from SR - but we can't use our own pulses
// we can't make this so generic as one set uses interrupts... also we can always reroute pulses with cables so...

CV plus DAC in CV modes, pulse plus SR in pulse modes????

routing table is for incoming SRs

abstract out LFSR perhaps as just the returning of bits (so is routing)
also we have entry bits, ADC bit/s, pulsin bits, returning bits

what bits come in, logic, what determines speed, other determing factors for specific SRs


speed/routing/logical ops (logical ops as also selected by bits, overlaying of masks)

- question of multiple DAC outs - what we do with them

if each SR has DAC out which can route somewhere, and ADC in

7 bits - which is 0-128 (test if we can reach on CV knob)

Other bits for pulse/cv and type of SR are fixed across multiple modes.

routing also DAC->speed of register x
pulses->speed of register x

seperate DACs for output, speed/NSR normy clock, other uses (comparator)

1 2 3 4 bits - question is if we combine multiple DACs???

how we deal with incoming bits/pulsin?

///

(or we have anyways routings which are flexible so maybe is ok. just that DAC out clock/speed effects feedback etc...)

// to have experimental modes in second half which do routing bits: in
pulse modes these could depend on CV, and in CV on pulse or RSR.

6/9/2021 - important thing is if we have routing table then what do we do if is
  zeroes for one route - we need always to preserve a default route

for first half of modes we fix top SR as in, left as through, right as feedback, bottom CSR as output


////

TODO from below:

- set up clockins for basic pass/recirculate SRs and test with norm of CSR DAC to top TIM1 NSR pulse-DONE
- start porting SRs - more generic from AC!

- test use of manipulated routing tables for one SR
- trial RSR as random register with various routings for simulation of electronotes and TM.
- in test2.c compare generic shiftings with coggs version (and also if we still need to do <<1 if routes to itself?)DONE, yes they are the same, and we do

- ghostSR in ghostSR in test2.c to trial//also various crossings of delayed ghosts with "real" SRs

from test2.c
// own routing means we have the shifted out bit already (route to self) - but we still need to shift

// we could also lag the ghost so is like a delayed revenant
// so example it only shifts itself if there is a pulse bit

////////////////further

// and cycling/circling array of ghosts which can come back or go forwards/backwards - when these ghosts are copied over (on event)
// with 256 cycles/copies - or we can have variable length of this shifting array

we can also determine cycle we use using another SR

** xxxxx

proof of concept generic routing in test2.c

default or not: CSR DAC out->top PWM/TIM1 which is normed to clock pulse for NSR

[we need to trial if this makes sense with routing]

// what bits make sense for SR definition to be changed by other processes?

eg. input types are fixed or not, routing yes

so we have several bit modes for different main SR types...

for example bits determining type and routing = 7 bits

- that we can choose (eg. RSR) to be specific controller or
  determining SR (eg. for random operations we refer to this one
  eg. for TM and electronotes determinings - to test this)

- routing bits (routing table as one SR?) - or routing bits flipped/changed by other SR, incoming pulses...

- generic: new inputs or not, or logiced with - returning bit or not or logic op (inv), parity settings

equals:

generic parity settings in array (0 for no feedback or tag array with meta-array for type of logical operation, or where it comes from)

trial bits:

pulse/cv speed, input ADC/LFSR, output DAC/else?, type SR, type SR, type SR(3 bits of types=8), routing from (4 options)  

1               1               1                 1        1        1                           1 1 1 1 - 4 bits just to make it easier but could be less

is already 8 bits which would be 255 modes!!! we have limit of 64 modes

+ additonal bits: advance on cogg, logical opps, type of ADC, type of DAC, OR of LFSR/ADC 

// and we just leave outpulses as generic/divide down on 2nd set

unless we have other ways of thinking of modes... (mode as itself shift_register, pulses as incrementing modes or is that all too complicated)



thinking to have special modes - at end of mode dial which implement this kind of thinking: even 3 or 4 last turns which inc bits

** how to make modes more generic/independent whilst keeping routing options and open-ness?*

- feedback thru RSR makes more sense for ADC in modes and less for LFSR so maybe this decides routing?

- what if each of the 4 SRs is totally generic (in/out can be from
  anywhere, routing is unfixed and modifiable in runtime,
  self-modifying) - so there could be multiple ins, mixed outs
  (busses)... how to test this as proof of concept?

- that NSR and CSR can be input and output buses

- what this means for eg. notion of coggs and dependencies on other
  SRs, digital style filters etc. maybe make small test - but problem is to have too many SRs types

but also means we can have routings maybe switchable from pulses or from CV

eg. switch routing on certain conditions...

as in we can mix use of arrays of (pointers)/srs and shiftregs with names which point to these...

** generic SR classifications to work on:

-routing
-what drives it on: pulses, bits/otherSR, values=speed // values from CV, values from DACs/SRs
-looping/input bits
-output bits
-question of overlap/coggs/SR

or:

-what drives it on: pulses, bits/otherSR, values=speed
-returning bits (eg. LFSR, no bits=pass_through)
-overlap (eg. LFSR in overlap, size of overlap)
-incoming bits - this is routing also and pulses in/ADC, and what is done to them (eg. flip them)
-output bits/DAC

or: shift x bits, length, entry new bits

and ADCpulsesDAC are attached in to this (as NSR, CSR)

** another attempt from notebook

1. basic division speed/pulse ->32 modes
2. output/input ADC/DAC/LFSR/others
3. type of SR-parallel/Turing.etc., logical opp (XOR,OR,AND, leaky)
4. what are incoming bits
5. outgoing bits

** code basis from test2.c

uint32_t *shift_[4], *Gshift_[4][4], coggs[4][4]; // gshift is 4 even though we don't use one

b=0; g=2; // n=0,l=1,c=2,r=3 // so feedback here is from c 
bitn = ((*shift_[b] >> (lfsr_taps[SRlength[b]][0])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][1])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][2])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][3]))) & 1u; // 32 is 31, 29, 25, 24
// need to catch it
if (*shift_[b]==0)     *shift_[b]=0xff;
// copy now to ghost
//we need multiple ghosts for each possible shifter: eg. Gshift_rl, Gshift_rn, Gshift_rc (right ones for left, for n and for c)
*Gshift_[b][0]=*shift_[b]; 
*Gshift_[b][1]=*shift_[b]; 
*Gshift_[b][2]=*shift_[b];
*Gshift_[b][3]=*shift_[b]; // ghosts for l,c,r only but let's keep one spare
// what else it needs to know - for each queued SR we need one cogg=0 for reset as we reset each on reading
cogg[b][0]=0;
cogg[b][1]=0;
cogg[b][2]=0;
cogg[b][3]=0;
  
*shift_[b]=*shift_[b]<<1; // we are shifting left << so bit 31 is out last one

bitr=(*Gshift_[g][b]>>SRlength[b]) & 0x01;
*Gshift_[g][b]=(*Gshift_[g][b]<<1)+bitr; 

*shift_[b]+= bitn;// & bitr;// ^ (!(GPIOC->IDR & 0x0010)); // or goes to 1s, xor is risky, AND works... and clockbit PC4

//also we can make bit access (eg. GPIOC->IDR & 0x0010 - can we access register as pointer TEST??? WORKS!, counters speed etc. all arrays 0,1,2,3


* general //16/7/2021+

- AC has 64 modes so 64x64x64x64=16 million combinations
- speed CV to use in trigger mode (eg. length of overlap)
- divide into speedCV, trigger/pulse - so that makes 32 modes doubled up (what of SR effecting own/other speeds)

maybe with/without coggs as further option becomes 16 modes

NO freeze: freezing is not so interesting as just locks and gives continuous tone...

[note for SEG - electronotes wheel thing is passing down of bits so this could also be probability based (based on CV)!]

/// LOTS TO RESOLVE:
/////

- thinking also that coggs are a bit like small shift registers
  what could be done with these - rotating/looping SRs handle
  feedthrough of registers TODO! - also that this is more like overlap
  we had in mind - this seems to work

//////

- also odd patterns just realized unless we constrain lengths to odd numbers (which is even lengths) *TEST this - improves but maybe keep odd option//NO!
- reverted to older code 2/9 as if we constrain this favours 101010etc regular outcomes

- at high speeds timing of SR influences other timings

- kind of bug in all lfsr code (28/8/2021) as was passing on bitn
  which was LFSR feedback bit - still was interesting and keep for
  some modes or use that bitn for timing etc...

- also question as CSR is out but speed there determines speed of
  feedback so we should really have different paths:

as we have it is NSR->LSR->CSR->RSR->NSR

eg. NSR->LSR->CSR
            ->RSR->NSR

NSR->LSR->CSR // could be default routing but then we need to see about use of SRlengthc but length is important if we re-circulate???
///->RSR->NSR

NSR->LSR->CSR  ->NSR/or not
   ->RSR->CSR  ->NSR

others: NSR->CSR->LSR ->NSR
                ->RSR ->NSR

need to figure out how to select these from modes - see below

routing can be array of shiftregs

///what does it mean to have multiple routes -> route is only known to incoming SR which updates ghostSR which belongs to itself (so it can have all 4)

so routing table for each incoming SR would be 4 bits 1 1 1 1 N,L,C,R - excluding itself (try version which includes itself and doesn't shift)


//////

- do we always want same flow NSR->LSR->CSR->RSR->backtoNSR (at least
  do we always want feedback to NSR but then if not RSR would be
  redundant)... Q is how to signal different routing across independent modes:

if (routex==1) do this... // or pointers to entries - but we don;t really need pointers

/////

- see also AC modes.org!
- parallel bits input modes - eg. all x ADC bits are thrown into top or other SR

- speed can go to zero! signal this in array somehows... and speeds should be slower at one end

timing from speed-cv, pulse in, top reg(but no bits in), pulse AND
speedcv (divide, multiply, expect), pulse AND/OR/XOR top (again no
bits), from ghost registers (which can also be themselves clocked by
top register and then we can use bits in or?), timing also from SR->DAC


- question of range of speed - from slow CV (Hz?) to KHz for sigma/delta

- how we prevent running down to zero for SR on length change (trap this?)

variable stopping bits/zeroes

- left hand path/ right hand path: tree of life, kenneth grant and overlays for ...?

- how we deal with overlaps? some test code already but need to think through, could connect to length?


also pulse clock or cv advances number/x once eg for cycling ghost sr
or length of ghost sr, or we can have smaller degrees of that advance,
say 1/10 so is not such a big jump

- how clock pulses can be changed for speed - xor with other parts of
  SR, with returning bits (experiment with these timings), with speed bits????

- how to notate SR - black and white, left and right, that a ghost SR
  could decide how to route bits to left or right (but we use right
  for feedback but could still be interesting - general idea of
  routing bits eg ADC to one side, LFSR to other)

- for overlap: what comes out is only one bit (of course there could be pulses from earlier bits)
  try overlap with multiple << shift (same as or differing from overlap size)
  returning bits

- overlap also in sense that both overlap (XOR etc top and bottom overlapped SRs), what other kinds of overlap?

- how else to use our new multiple shift code?

- what we do with both clock and pulse in bits in CV mode and how we
  norm these bits (NSR clock is normed to TIM1 pwm which we will use
  speedCV/or DAC out as control for) - otherwise we have pulseouts normed to all other pulse/clock ins

[but none of these will advance so maybe sync all to this clock which frees up their own speedCVs]

- experimental modes for LSR, RSR and CSR only advance with cogg=0 from previous (maybe logic op with bit)???

* NSR, LSR, RSR, CSR

** NSR - top register - ADC in, CLKIN only, no pulse outs:

mode 0 is straight LFSR (or with ADC or)

- 1-LFSRnoise/2-ADC in/3-mix of LFSR and ADC //4-comparator? -to-LSR/or/RSR or both (do we decide that here = RSR is now designated as feedback)

[so that gives us 8 or so modes for each one - or 4 with new coggs setup]

+ comparator function for ADC ins (can we also use this for LFSR -
  ways that we can combine bits from that?) - comp only works when we
  have no speedCV/pulsein only - or we can have 

comp in as one bit only ADC in comped with CV?

- feedback of analogue output - eg. comparator using analogue out

- types of ADC (x bits, simple uncombined bits as in digfiltersim, equivalent bits), length in bits, delayed/stored bits

- pulse in/or speedCV and what CV does when pulse in/vice versa! (eg. number of bits, LFSR length if we have as extra)

- can also be clocked by CSR and/or ghosted noise SR 

- can be set of parallel SRs which feed into CSR, or just x bits from ADC go straight into CSR

- ADC with LFSR options: that we OR/XOR each incoming ADC bit with
  LFSR generated bit (from ghost LFSR), cases for parallel ADCs, that
  we weight incoming LFSR bits, that we use LFSR as DAC to
  add/subtract from ADC in, that we bulk XOR or just one bit per x
  incoming ADC bits, comparator of incoming DAC against LFSR/DAC

- number of bits in/out by CV or pulse counter(which wraps around)

- what to do if bits in/out is greater than length (options: put in anyways and lose top/bottom bits - shift if necessary // stop at length)

** LSR/RSR - regular shift register modes borrow from AC - CLKIN and PULSIN, 2 pulse outs/bits or flipflops: 

mode 0: feedthrough only - straight shift through with no return

LSR has entry from NSR and feeds into CSR
RSR has entry from CSR and feeds into NSR (so is the feedback register)

but now we look into different paths!

dark/light sides, left and right hand paths, mirrors (moon and sun), tree of life (Kenneth Grant - Nightside of Eden)

Question of how we work with entry of pulse ins: as togglers, pausers also, as extra
bits (but do we always have NSR entering in, maybe AND with extra bits
or other logic ops)

List leaky/decay possibilities...

- look at AC SRs and see what can be adapted for NSR/CSR as incoming bits and cycling bit or pulse in bit (or combinations of these)

- how we handle entry and overlap from NSR or CSR (logical ops, length of overlap)

- can also be clocked by bits from the NSR top register - but in this case we can't input bits from NSR as these will just be 1s!
 
- regular AC/SR modes

- just one way shift/delay - in one end, out the other (with/without bit degradation)

- looping SR with/without degradation

- leaking/decaying of bits, other logic feedbacks 

- micro-SRs in SRS - additional loops and feedbacks (that we can have loop in loop but also feedback in RSR to LSR and vice versa)

- regular and ghost LFSRs...

- latchings, holdings

- multiple flipflops of various descriptions for pulses out

- RSR is "clocking/logicopwithclocking" LSR and vice versa - need to test how this will work in all cases

** CSR - output register - CLKIN only, 2 pulse outs/bits or flipflops, DAC out: 

mode 0: basic DAC out

- type of DAC (eg. sigma/delta which is low pass of single stream of bits, x bit DAC)
- which of the bits are used for regular DAC: weighted, unweighted, spacings
- overlays, masks for DAC bits

- how we handle the pulseouts so this can also be extra/doubling up of modes

- DAC outs from SR

- electronotes just has standard weighting DAC, uniform (bits x X) from consecutive taps, and sets of spaced taps -> wide spacings)

what else for 64 modes divided by speedcv/pulsin = 32 still (in pulsin we have bit length for DAC)

- number of bits in/out by CV or pulse counter(which wraps around)

- what to do if bits in/out is greater than length (options: put in anyways and lose top/bottom bits - shift if necessary // stop at length)

* notes... from elsewhere/sketches

- extra SR for random ops and timings maybe - that we can copy other SR to this also...

- what second bits out can be - different taps, divided/flip_flop, diff tap and flip_flop, logical ops with other bit!

- drooling shift register legged caterpillars

- how to do digital filtering - x spaced bits enter, passed down straight SR (with/without bit degradation, any other fancy stuff)
and X spaced bits are sent to DAC from CSR. return bits (how to select) OR/XOR from output (as bits or via DAC/ADC feedback options) to NSR/top register.

- maximum SR length as 32?
- ghost SRs
- parallel entry of data/ADC, sudden mirroring of SRs?

- leaky, rotting and/or infectuous logic/sticky logic/slow logic others?, UFO stuff 

what other kinds of logic gates there can be (based on CA, ternary etc)?

timing of a slow logic leak? 

trigger->latch and slow leak, disappearance of ones, bit by bit (how we could also display this as side project)

- NLC 8 bit cipher simulation: only makes sense for NSR and CSR where we have many bits in

... strobe is always high on 4094 so bits go into SR and are out, but
option for data on strobe which means all SR only change on 1, CV
combines different bits and primitive XOR for 2nd bit/mix with data in...

basically data goes to out when strobe is high, low -> just shifts 

so strobe is pulse in which can latch (incoming-ADC or noise) bits on to NSR or CSR
(outgoings) - and this is different to speedCv/pulse_speed as SR is still operating...

- how to work with overlaps? 

- overlap XOR LSR and RSR

- sieves - that LSR can be used as a sieve or bitmask for
  RSR/others... - how we deal with sudden events such as this, freeze,
  copy, ghost etc. (on a pulse in?)

- marking bits which always stay frozen - concept of sieves, masks,
  ghosts, revenants (eg. slow drift or decay of bits from one set to
  another, frozen, prevous or ghosted - so bit by bit they shift back,
  question of how long they take to go back?)

question of recording position and lifetime for decay - we erase on
death from the list but list handling is slow (finite sets of arrays
and garbage collect in one interrupt?) or we can just record and keep one bit max per SR

- TM encoding for SR_as_tape operations
 
  walk_ins - what else can be borrowed from language, concepts from UFO
  encounters?

- pulse triggers exchange between ghost and real, what pulses might
  mean - primitive programming language like brainfuck

//interpret set of bits as instruction on pulse in - say an x bit
sequence (but how to work with bits rather than bytes)

instructions shift left or right the opposite SR (can also use bits as
mask to do this - so we interpret one SR as shifting the other on each
bit in)

The Infinite Abacus: Brainfuck's "grand-parent" language

A version with explicit memory addressing rather without stack and a
conditional jump was introduced by Joachim Lambek in 1961 under the
name of the Infinite Abacus, consisting of an infinite number of
cells and two instructions:

    X+ (increment cell X)
    X- else jump T (decrement X if it is positive else jump to T)

- reverse direction of register (what this means?)

- glue one LFSR onto end/beginning of another

** parallel SRs

- feed data into top of parallel LFSRs, data read out from all bit outs: test for 12 bits, 12 parallel streams

** two headed SR



* in progress/ideas/todo

- how we pass through SR bits at different speeds - top one resets cycling/circling counter which wheels through SR
- is [0 bit our output?
- smoothing and other aspects from AC to implement
- re-test function pointers/how to make code more modular?


* TODO/plan

- basic structure of the 4 SR and straightforward tests eg. ADC in,
  pass down SR, DAC out

- proof of concept for digital filter and what ideas come from this

- all basic SR concepts implemented

- brainstorm and tests of all concepts

- basic modes layed out and tested - first speed CV then pulse driven and fancier...

