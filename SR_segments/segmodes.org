* how to sort and classify/generic ideas sept 2021

beckett/gray codes for routing ???

21/9/2021:

- how to go further, collate ideas and see how these fit or don't fit with generic model:

eg. in AC Cv modes was lots of use of pulses to do things which now we lose a bit...

or we divide across 2 sets of generic modes, or simply have generic modes for things like routings

- that incoming pulses can eg. change flip or not flip, change routing table, invert mode bits

seperate mode and mode bits: mode determines mode bits (on mode change)

20/9/2021:

- testing generic SR is it_generic.c

notes:

- had to break down loop though as speed was overlapping/effecting others, can tighten up and make faster from main.c TIM2 dividers
- that we should be able to make bitsize of dac independent from length - maybe?
- lists of modes/settings

- TODO: probability in generic code? TESTING but might work???


17/9/2021:

- question of how we work with probability within generic framework - as in TM etc...

// make it_gen.c + stripped version to test generic code!

16/9/2021:

- idea that CLK pulsins could trigger train of pulses at speed x
  (eg. x by CV, by DAC) - descending speed, speed from other SR, train
  from other SR

- how to arrange:

CV speed
trigger speed
speed from other DAC (which one) with CV offset
SR->bit speed (ANDed with CV/trigger) eg. if && bitx
train of pulses also (see above)

[SR->fake triggers and mainPWM/normed in - but that is determined by other SRs] -> we need to sort this...
-> how these are all selected as all SR are independent

//MODE - where do I take my speed from?

to resolve fixed scheme eg. CSR->DAC out as we can't have 2x DAC outs simultaneously (or we have bus/mix)?

TODO: implement basic very generic SR for all cases, test if flag in clkin interrupt works so we can place all in main loop

1-Where do I get speed from? if from SR which one and 
1.5-shifting of which bits <<
2-where is the input bit from (LFSR, ADC type?)
3-what is routing for incoming SR bits, cycling bit
4-what is incoming pulsin bit if any?
5-XOR of logic op of all bits and re-insertion
6-DAC output for any purposes
7-pulses out if any

8-fake/pwm for normed clkins - how? or we keep standard?

options/ideas: DAC out runs at full speed and is changed by all/any, clkin interrupts flagged so all is in main loop

  // we can still have specialised SRs but they should all be repeatable
  // so can be placed in a loop!
  SEE:  *generic.c*

////////////////
how to resolve clock norming?

So we have PWM (TIMx) which norms to NSR clock - this is generated at the moment from RSR DAC

LSR, RSR and CSR have fake clocks - CSR should be from speedc/CV, LSR and RSR???

15/9/2021:

- testing and implementing arrays for puls ins and outs (left, right and c) DONE
- place into not-so-generic pasted LFSR round one at start// DONE

- implementation for Benjolin/halfDONE but need to think about how we
  can make generic one SR clocking another without failure in any loop, and/or generic use of fake clkins

- TODO: Benjolin in trigger mode using fake clks - FIGURE out how to prevent freeze (CSR will have speed)

- so start to think on what general modes for Vienna could be (before we get to rendering as all generic)

// using sigma delta for bit input an low pass out (see test.c)
// all modes with bits in and out

eg.
0-looping only/aka return only!
1-pass on only - straight through
2-pass on and return bitx
3-TM with pass on - trigger mode
4-TM with loop back
5-TM in TM pass on
6-TM in TM loop
7-Rungler XOR pass on
8-Rungler XOR loop back
9+Run with different speeds
10+Run with bits

11other exp modes/trigger modes//what else?

DACs,ADC types

TODO: always have NSR/PWM from RSR DAC for the moment - so to add to the basic/pastey!

13/9/2021:

- clock fake routes: R->L and L->R (output bits of SR to CLKINS), CSR is speed controlled (has to be) - TO TEST!
TESTING but tricky so made all from speed... NSR/pwm is from DAC

- make latest TM SR more generic/start to port to arrays/tables

11/9/2021:

finishing DAC and ADC generic options:
TODO// other options are: comparator, equivalent sets of x bits incoming 

possibly we don't use fake pulse ins for norming left/right - to test that these don't effect incoming
(but we do need to use CLKins normed for L,R,C) - test with incoming bits

10/9/2021:

inline int bits(uint32_t reg, uint32_t length){ // function returns bottom length bits of SR reg

and another inline function which returns different kinds of DAC from
a certain SR eg. standard DAC of x bits, equivalent dac of x bits,
what about one bit dac (more involved as takes time but we should have
a pointer to that value

9/9/2021 

// always do DACs - but how these are handled according to length as we still want fixed number of bits

implementing TM in TM: slowly start to see how to abstract as work through and implement all modes
- TOWARDS: basic framework to use in Vienna! (using one bit DAC out
  tho which we could also include in routing tables and as an always?)

- each SR delivers DAC, how to do tables which don't allow for overlap of DACs eg.

1000
0100
0010
0001 for each table

structure for all eg. speed from routing table// all is defined by tables/arrays which can be routed

in test2.c speedroute as array of pointers to values...

pulsin bits L, R is XOR always with new bit

basic modes/expanded modes across split of cv/speed, pulse speed...

/////

how to make uncomplicated generic SR options which can interact across all sets of:

1st set: simple SR modes for each SR with fixed routing
1.5th: simple modes but with very specific configurable tables for routes eg. speed routes...
2nd set: generic SRs with configurable routings
3: complex routing with DAC, ADC etc.

generic as all routing is internal - we do not dictate to other SR...

// also from triadex muse:
--> this is an XOR of 4 bits - selected from clocking bits, on/off bit and from shift register feedback

that we can have XORs of bits from other SRs entering our SR
so table would be for 4 bits from 4x maxSRlength=32*4=128 (ignore lengths)

thinking about multiple routing for DAC, clock DAC and ADC??? how this might work as gives flexibility for timings

then we have x bits:

routing / DAC output / LFSR feedback / ADC IN 
1 2 3 4 / 5      /  6            /  7

extra bits: clock DAC/pulse for speed with any offset(CV), comp DAC ->9 bits, 

speed modes: CV as speed, CV plus DAC as speed, pulses, pulses from SR, combination of... see more below...

// and how would routing be for pulse modes: pulses, pulses from SR - but we can't use our own pulses
// we can't make this so generic as one set uses interrupts... also we can always reroute pulses with cables so...

CV plus DAC in CV modes, pulse plus SR in pulse modes????

routing table is for incoming SRs

abstract out LFSR perhaps as just the returning of bits (so is routing)
also we have entry bits, ADC bit/s, pulsin bits, returning bits

what bits come in, logic, what determines speed, other determing factors for specific SRs


speed/routing/logical ops (logical ops as also selected by bits, overlaying of masks)

- question of multiple DAC outs - what we do with them

if each SR has DAC out which can route somewhere, and ADC in

7 bits - which is 0-128 (test if we can reach on CV knob)

Other bits for pulse/cv and type of SR are fixed across multiple modes.

routing also DAC->speed of register x
pulses->speed of register x

seperate DACs for output, speed/NSR normy clock, other uses (comparator)

1 2 3 4 bits - question is if we combine multiple DACs???

how we deal with incoming bits/pulsin?

///

(or we have anyways routings which are flexible so maybe is ok. just that DAC out clock/speed effects feedback etc...)

// to have experimental modes in second half which do routing bits: in
pulse modes these could depend on CV, and in CV on pulse or RSR.

6/9/2021 - important thing is if we have routing table then what do we do if is
  zeroes for one route - we need always to preserve a default route

for first half of modes we fix top SR as in, left as through, right as feedback, bottom CSR as output


////

TODO from below:

- set up clockins for basic pass/recirculate SRs and test with norm of CSR DAC to top TIM1 NSR pulse-DONE
- start porting SRs - more generic from AC!

- test use of manipulated routing tables for one SR
- trial RSR as random register with various routings for simulation of electronotes and TM.
- in test2.c compare generic shiftings with coggs version (and also if we still need to do <<1 if routes to itself?)DONE, yes they are the same, and we do

- ghostSR in ghostSR in test2.c to trial//also various crossings of delayed ghosts with "real" SRs

from test2.c
// own routing means we have the shifted out bit already (route to self) - but we still need to shift

// we could also lag the ghost so is like a delayed revenant
// so example it only shifts itself if there is a pulse bit

////////////////further

// and cycling/circling array of ghosts which can come back or go forwards/backwards - when these ghosts are copied over (on event)
// with 256 cycles/copies - or we can have variable length of this shifting array

we can also determine cycle we use using another SR

** xxxxx

proof of concept generic routing in test2.c

default or not: CSR DAC out->top PWM/TIM1 which is normed to clock pulse for NSR

*[we need to trial if this makes sense with routing]*

// what bits make sense for SR definition to be changed by other processes?

eg. input types are fixed or not, routing yes

so we have several bit modes for different main SR types...

for example bits determining type and routing = 7 bits

- that we can choose (eg. RSR) to be specific controller or
  determining SR (eg. for random operations we refer to this one
  eg. for TM and electronotes determinings - to test this)

- routing bits (routing table as one SR?) - or routing bits flipped/changed by other SR, incoming pulses...

- generic: new inputs or not, or logiced with - returning bit or not or logic op (inv), parity settings

equals:

generic parity settings in array (0 for no feedback or tag array with meta-array for type of logical operation, or where it comes from)

trial bits:

pulse/cv speed, input ADC/LFSR, output DAC/else?, type SR, type SR, type SR(3 bits of types=8), routing from (4 options)  

1               1               1                 1        1        1                           1 1 1 1 - 4 bits just to make it easier but could be less

is already 8 bits which would be 255 modes!!! we have limit of 64 modes

+ additonal bits: advance on cogg, logical opps, type of ADC, type of DAC, OR of LFSR/ADC 

// and we just leave outpulses as generic/divide down on 2nd set

unless we have other ways of thinking of modes... (mode as itself shift_register, pulses as incrementing modes or is that all too complicated)



*thinking to have special modes - at end of mode dial which implement this kind of thinking: even 3 or 4 last turns which inc bits*

** how to make modes more generic/independent whilst keeping routing options and open-ness?*

- feedback thru RSR makes more sense for ADC in modes and less for LFSR so maybe this decides routing?

- *what if each of the 4 SRs is totally generic* (in/out can be from
  anywhere, routing is unfixed and modifiable in runtime,
  self-modifying) - so there could be multiple ins, mixed outs
  (busses)... how to test this as proof of concept?

- that NSR and CSR can be input and output buses

- what this means for eg. notion of coggs and dependencies on other
  SRs, digital style filters etc. maybe make small test - but problem is to have too many SRs types

but also means we can have routings maybe switchable from pulses or from CV

eg. switch routing on certain conditions...

*or can mix of generic and otherwise work - as long as all are independent and share any necessary information. eg. new cogg/reset function*

as in we can mix use of arrays of (pointers)/srs and shiftregs with names which point to these...

** generic SR classifications to work on:

-routing
-what drives it on: pulses, bits/otherSR, values=speed // values from CV, values from DACs/SRs
-looping/input bits
-output bits
-question of overlap/coggs/SR

or:

-what drives it on: pulses, bits/otherSR, values=speed
-returning bits (eg. LFSR, no bits=pass_through)
-overlap (eg. LFSR in overlap, size of overlap)
-incoming bits - this is routing also and pulses in/ADC, and what is done to them (eg. flip them)
-output bits/DAC

or: shift x bits, length, entry new bits

and ADCpulsesDAC are attached in to this (as NSR, CSR)

** another attempt from notebook

1. basic division speed/pulse ->32 modes
2. output/input ADC/DAC/LFSR/others
3. type of SR-parallel/Turing.etc., logical opp (XOR,OR,AND, leaky)
4. what are incoming bits
5. outgoing bits

** code basis from test2.c

uint32_t *shift_[4], *Gshift_[4][4], coggs[4][4]; // gshift is 4 even though we don't use one

b=0; g=2; // n=0,l=1,c=2,r=3 // so feedback here is from c 
bitn = ((*shift_[b] >> (lfsr_taps[SRlength[b]][0])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][1])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][2])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][3]))) & 1u; // 32 is 31, 29, 25, 24
// need to catch it
if (*shift_[b]==0)     *shift_[b]=0xff;
// copy now to ghost
//we need multiple ghosts for each possible shifter: eg. Gshift_rl, Gshift_rn, Gshift_rc (right ones for left, for n and for c)
*Gshift_[b][0]=*shift_[b]; 
*Gshift_[b][1]=*shift_[b]; 
*Gshift_[b][2]=*shift_[b];
*Gshift_[b][3]=*shift_[b]; // ghosts for l,c,r only but let's keep one spare
// what else it needs to know - for each queued SR we need one cogg=0 for reset as we reset each on reading
cogg[b][0]=0;
cogg[b][1]=0;
cogg[b][2]=0;
cogg[b][3]=0;
  
*shift_[b]=*shift_[b]<<1; // we are shifting left << so bit 31 is out last one

bitr=(*Gshift_[g][b]>>SRlength[b]) & 0x01;
*Gshift_[g][b]=(*Gshift_[g][b]<<1)+bitr; 

*shift_[b]+= bitn;// & bitr;// ^ (!(GPIOC->IDR & 0x0010)); // or goes to 1s, xor is risky, AND works... and clockbit PC4

//also we can make bit access (eg. GPIOC->IDR & 0x0010 - can we access register as pointer TEST??? WORKS!, counters speed etc. all arrays 0,1,2,3

** classify AC SR modes (did we attempt that there?)

in separate file

note that some modes deal with types of pulses out

* general //16/7/2021+

- AC has 64 modes so 64x64x64x64=16 million combinations
- speed CV to use in trigger mode (eg. length of overlap)
- divide into speedCV, trigger/pulse - so that makes 32 modes doubled up (what of SR effecting own/other speeds)

maybe with/without coggs as further option becomes 16 modes

NO freeze: freezing is not so interesting as just locks and gives continuous tone...

*[note for SEG - electronotes wheel thing is passing down of bits so this could also be probability based (based on CV)!]*

/// LOTS TO RESOLVE:

*questions to resolve: routing and feedback, coggs and/or micro-registers, in or out number of bits vs. length of register* 

/////

- *thinking also that coggs are a bit like small shift registers* -
  what could be done with these - rotating/looping SRs handle
  feedthrough of registers TODO! - also that this is more like overlap
  we had in mind - this seems to work

//////

- also odd patterns just realized unless we constrain lengths to odd numbers (which is even lengths) *TEST this - improves but maybe keep odd option//NO!
- reverted to older code 2/9 as if we constrain this favours 101010etc regular outcomes

- at high speeds timing of SR influences other timings

- kind of bug in all lfsr code (28/8/2021) as was passing on bitn
  which was LFSR feedback bit - still was interesting and keep for
  some modes or use that bitn for timing etc...

- also question as CSR is out but speed there determines speed of
  feedback so we should really have different paths:

as we have it is NSR->LSR->CSR->RSR->NSR

eg. NSR->LSR->CSR
            ->RSR->NSR

*NSR->LSR->CSR* // *could be default routing but then we need to see about use of SRlengthc but length is important if we re-circulate???*
*///->RSR->NSR*

NSR->LSR->CSR  ->NSR/or not
   ->RSR->CSR  ->NSR

others: NSR->CSR->LSR ->NSR
                ->RSR ->NSR

need to figure out how to select these from modes - see below

routing can be array of shiftregs

///what does it mean to have multiple routes -> route is only known to incoming SR which updates ghostSR which belongs to itself (so it can have all 4)

so routing table for each incoming SR would be 4 bits 1 1 1 1 N,L,C,R - excluding itself (try version which includes itself and doesn't shift)

*ghost shift registers (GSR) within GSRs - if itself is treated as a ghost revenanting/coming into itself*

//////

- do we always want same flow NSR->LSR->CSR->RSR->backtoNSR (at least
  do we always want feedback to NSR but then if not RSR would be
  redundant)... Q is how to signal different routing across independent modes:

if (routex==1) do this... // or pointers to entries - but we don;t really need pointers

*so we can list routings but how are these selected - by the top mode maybe?*

/////

- see also AC modes.org!
- parallel bits input modes - eg. all x ADC bits are thrown into top or other SR

- speed can go to zero! signal this in array somehows... and speeds should be slower at one end

timing from speed-cv, pulse in, top reg(but no bits in), pulse AND
speedcv (divide, multiply, expect), pulse AND/OR/XOR top (again no
bits), from ghost registers (which can also be themselves clocked by
top register and then we can use bits in or?), timing also from SR->DAC


- question of range of speed - from slow CV (Hz?) to KHz for sigma/delta

- how we prevent running down to zero for SR on length change (trap this?)

variable stopping bits/zeroes

- left hand path/ right hand path: tree of life, kenneth grant and overlays for ...?

- how we deal with overlaps? some test code already but need to think through, could connect to length?

- *use other SR bits to determine length of other SR* then free up length cv for something else? 

also pulse clock or cv advances number/x once eg for cycling ghost sr
or length of ghost sr, or we can have smaller degrees of that advance,
say 1/10 so is not such a big jump

- how clock pulses can be changed for speed - xor with other parts of
  SR, with returning bits (experiment with these timings), with speed bits????

- how to notate SR - black and white, left and right, that a ghost SR
  could decide how to route bits to left or right (but we use right
  for feedback but could still be interesting - general idea of
  routing bits eg ADC to one side, LFSR to other)

- *test with/withouts coggs running - how this works - seems to work so how to deal with this option in modes*

- for overlap: what comes out is only one bit (of course there could be pulses from earlier bits)
  try overlap with multiple << shift (same as or differing from overlap size)
  returning bits

- overlap also in sense that both overlap (XOR etc top and bottom overlapped SRs), what other kinds of overlap?

- how else to use our new multiple shift code?

- what we do with both clock and pulse in bits in CV mode and how we
  norm these bits (NSR clock is normed to TIM1 pwm which we will use
  speedCV/or DAC out as control for) - otherwise we have pulseouts normed to all other pulse/clock ins

[but none of these will advance so maybe sync all to this clock which frees up their own speedCVs]

- experimental modes for LSR, RSR and CSR only advance with cogg=0 from previous (maybe logic op with bit)???

* NSR, LSR, RSR, CSR

** NSR - top register - ADC in, CLKIN only, no pulse outs:

mode 0 is straight LFSR (or with ADC or)

- 1-LFSRnoise/2-ADC in/3-mix of LFSR and ADC //4-comparator? -to-LSR/or/RSR or both (do we decide that here *BUT* RSR is now designated as feedback)

[so that gives us 8 or so modes for each one - or 4 with new coggs setup]

+ comparator function for ADC ins (can we also use this for LFSR -
  ways that we can combine bits from that?) - comp only works when we
  have no speedCV/pulsein only - or we can have 

comp in as one bit only ADC in comped with CV?

- feedback of analogue output - eg. comparator using analogue out

- types of ADC (x bits, simple uncombined bits as in digfiltersim, equivalent bits), length in bits, delayed/stored bits

- pulse in/or speedCV and what CV does when pulse in/vice versa! (eg. number of bits, LFSR length if we have as extra)

- can also be clocked by CSR and/or ghosted noise SR 

- *look at AC SRs and see what can be adapted for ADC as incoming bits and cycling bit or RSR return bit (or combinations of these)*

- can be set of parallel SRs which feed into CSR, or just x bits from ADC go straight into CSR

- ADC with LFSR options: that we OR/XOR each incoming ADC bit with
  LFSR generated bit (from ghost LFSR), cases for parallel ADCs, that
  we weight incoming LFSR bits, that we use LFSR as DAC to
  add/subtract from ADC in, that we bulk XOR or just one bit per x
  incoming ADC bits, comparator of incoming DAC against LFSR/DAC

- number of bits in/out by CV or pulse counter(which wraps around)

- what to do if bits in/out is greater than length (options: put in anyways and lose top/bottom bits - shift if necessary // stop at length)

** LSR/RSR - regular shift register modes borrow from AC - CLKIN and PULSIN, 2 pulse outs/bits or flipflops: 

mode 0: feedthrough only - straight shift through with no return

LSR has entry from NSR and feeds into CSR
RSR has entry from CSR and feeds into NSR (so is the feedback register)

*but now we look into different paths!*

dark/light sides, left and right hand paths, mirrors (moon and sun), tree of life (Kenneth Grant - Nightside of Eden)

Question of how we work with entry of pulse ins: as togglers, pausers also, as extra
bits (but do we always have NSR entering in, maybe AND with extra bits
or other logic ops)

List leaky/decay possibilities...

- *look at AC SRs and see what can be adapted for NSR/CSR as incoming bits and cycling bit or pulse in bit (or combinations of these)*

- how we handle entry and overlap from NSR or CSR (logical ops, length of overlap)

- can also be clocked by bits from the NSR top register - but in this case we can't input bits from NSR as these will just be 1s!
 
- regular AC/SR modes

- just one way shift/delay - in one end, out the other (with/without bit degradation)

- looping SR with/without degradation

- leaking/decaying of bits, other logic feedbacks 

- micro-SRs in SRS - additional loops and feedbacks (that we can have loop in loop but also feedback in RSR to LSR and vice versa)

- regular and ghost LFSRs...

- latchings, holdings

- multiple flipflops of various descriptions for pulses out

- RSR is "clocking/logicopwithclocking" LSR and vice versa - need to test how this will work in all cases

** CSR - output register - CLKIN only, 2 pulse outs/bits or flipflops, DAC out: 

mode 0: basic DAC out

- type of DAC (eg. sigma/delta which is low pass of single stream of bits, x bit DAC)
- which of the bits are used for regular DAC: weighted, unweighted, spacings
- overlays, masks for DAC bits

- how we handle the pulseouts so this can also be extra/doubling up of modes

- *look at AC SRs and see what can be adapted for CSR as incoming bits and cycling bit (or combinations of these)*

- DAC outs from SR

- electronotes just has standard weighting ADC, uniform (bits x X) from consecutive taps, and sets of spaced taps -> wide spacings)

what else for 64 modes divided by speedcv/pulsin = 32 still (in pulsin we have bit length for DAC)

- number of bits in/out by CV or pulse counter(which wraps around)

- what to do if bits in/out is greater than length (options: put in anyways and lose top/bottom bits - shift if necessary // stop at length)

* notes... from elsewhere/sketches

- extra SR for random ops and timings maybe - that we can copy other SR to this also...

- what second bits out can be - different taps, divided/flip_flop, diff tap and flip_flop, logical ops with other bit!

- drooling shift register legged caterpillars

- how to do digital filtering - x spaced bits enter, passed down straight SR (with/without bit degradation, any other fancy stuff)
and X spaced bits are sent to DAC from CSR. return bits (how to select) OR/XOR from output (as bits or via DAC/ADC feedback options) to NSR/top register.

- maximum SR length as 32?
- ghost SRs
- parallel entry of data/ADC, sudden mirroring of SRs?

- leaky, rotting and/or infectuous logic/sticky logic/slow logic others?, UFO stuff 

what other kinds of logic gates there can be (based on CA, ternary etc)?

timing of a slow logic leak? 

trigger->latch and slow leak, disappearance of ones, bit by bit (how we could also display this as side project)

- NLC 8 bit cipher simulation: only makes sense for NSR and CSR where we have many bits in

... strobe is always high on 4094 so bits go into SR and are out, but
option for data on strobe which means all SR only change on 1, CV
combines different bits and primitive XOR for 2nd bit/mix with data in...

basically data goes to out when strobe is high, low -> just shifts 

so strobe is pulse in which can latch (incoming-ADC or noise) bits on to NSR or CSR
(outgoings) - and this is different to speedCv/pulse_speed as SR is still operating...

- how to work with overlaps? 

- overlap XOR LSR and RSR

- sieves - that LSR can be used as a sieve or bitmask for
  RSR/others... - how we deal with sudden events such as this, freeze,
  copy, ghost etc. (on a pulse in?)

- marking bits which always stay frozen - concept of sieves, masks,
  ghosts, revenants (eg. slow drift or decay of bits from one set to
  another, frozen, prevous or ghosted - so bit by bit they shift back,
  question of how long they take to go back?)

question of recording position and lifetime for decay - we erase on
death from the list but list handling is slow (finite sets of arrays
and garbage collect in one interrupt?) or we can just record and keep one bit max per SR

- TM encoding for SR_as_tape operations
 
  walk_ins - what else can be borrowed from language, concepts from UFO
  encounters?

- pulse triggers exchange between ghost and real, what pulses might
  mean - primitive programming language like brainfuck

//interpret set of bits as instruction on pulse in - say an x bit
sequence (but how to work with bits rather than bytes)

instructions shift left or right the opposite SR (can also use bits as
mask to do this - so we interpret one SR as shifting the other on each
bit in)

The Infinite Abacus: Brainfuck's "grand-parent" language

A version with explicit memory addressing rather without stack and a
conditional jump was introduced by Joachim Lambek in 1961 under the
name of the Infinite Abacus, consisting of an infinite number of
cells and two instructions:

    X+ (increment cell X)
    X- else jump T (decrement X if it is positive else jump to T)

- reverse direction of register (what this means?)

- glue one LFSR onto end/beginning of another

** parallel SRs

- feed data into top of parallel LFSRs, data read out from all bit outs: test for 12 bits, 12 parallel streams

** two headed SR



* in progress/ideas/todo

- how we pass through SR bits at different speeds - top one resets cycling/circling counter which wheels through SR
- is [0 bit our output?
- smoothing and other aspects from AC to implement
- re-test function pointers/how to make code more modular?


* TODO/plan

- basic structure of the 4 SR and straightforward tests eg. ADC in,
  pass down SR, DAC out

- proof of concept for digital filter and what ideas come from this

- all basic SR concepts implemented

- brainstorm and tests of all concepts

- basic modes layed out and tested - first speed CV then pulse driven and fancier...

