* plan

- implement/test all new modes and catalogue these

// need balance of flexibility in modes, access to advanced routing...
// or at least alt routings altroute

- TODO from below and from theone.c
- recheck logic of all sections

- implement sketch of all modes as below with DAC and ADC options
- test/play
- tweaks for slower speed, CLK norms, what else? how we handle one bit audio filter?

* modes sketch

CVspeed:
1-15 -LR simple modes/all inc prob
      N 8xADC x2 - pass in/circle_and_pass or 16 ADC modes with pass in only!
      C 4xDAC x4 - pass in/circle only/circle and pass/prob

16-31 LR - exp modes
      NC - any match modes 4xADC, 4xDAC

place global CV route modes

CV+DACspeed: // other speed options: speed from clkcnt, speed from CV+clkcnt
32-47 LR - modes mixed
      NC as 1or2

also which DAC (can be rerouted too)

INTspeed: // or speed from INT divided by CV->TODO! // SR->bit speed (ANDed with CV/trigger) eg. if && bitx
48-63 LR - mix using CV params - probability, comparator, CV+DAC/ADC as modifier
      NC 4x ADC/DAC and prob modes - special INT modes for ADC/DAC which make use of CV/not trigger

plus global change routes for INTmodes right at the end,,,

CV&DACspeed: -/+/wrapsDAC- tested some...

timing from pulse AND speedcv (divide, multiply, expect), pulse
AND/OR/XOR top? (again no bits), from ghost registers (which can also
be themselves clocked by top register and then we can use bits in
or?), timing also from SR->DAC


** classification

L&R modes...

- basic route/logic modes
- probability modes
- use of CLKIN as bit modes/as toggles etc.
- speedfrom/routings/logic manipulations
- esoteric

** list from theone.c

//0: all pass through only

//1: cycle round only XORbits - basic 0 DAC out

//2: cycle and pass only XORcycleXOR-bits - basic 0 DAC out

//3: N: passon/XOR-LFSR LR: passonORbits C: XOR-DACequiv  // note that for LR with no bits in these are all the same

//4: N: passon/XOR-ADC1bit LR: passonANDbits C:XOR-DAC1bit

//5: N: passon/XOR-ADCxbit LR: passonLEAKbits C: XOR-DACspacers

//// maybe remove 678! and add new ADC/DAC options instead

678: N:cycle/pass/XOR-ADCoptions LR: cycleandpasXOR-LOGOPbits C: as N/DACoptions //NOTE: these ones are quite destructive of ADC ins/orDAC?
6 LFSR
7 ADC1
8 ADCxbits

//////9- test code with other ADC and DAC options
//rung - cycle XOR with pass//=mode2

10 - model for probability modes?

/////
TODO: prob modes below as/and basic INT modes

- probability modes for (DAC, DAC+CV comp to SR,countedclk), prob of bit in/inverted bit in,
  XOR bit in from->[routed//cycled//ADCorLFSR//pulseifwehave], prob of
  bitin OR loopback, prob of bitin or inverted loopback, prob of
  cycle, new bit from bits/from route -> how many? make this clearer:

SR is customSR or RSR(routed SR)

1. if SR<CV  // int mode
2.if SR<DAC  // cv/int mode
3.if SR<DAC+CV // int mode
4.if sr<CLKCNT // cv mode
XX
1. invert cycling bit or not, pulsbit is ORed in (TM)
2. invert routedin bit or not, pulsbit is ORed in (TM)
3. mix of this?

3. new input (from pulsbit) or cycling bit (wiard and EN)
4. new input (from route) or cycling bit
5. new input (from ADC) or cycling bit//6. new input (from LFSR) or cycling bit

7-10 above with inverted cycling bit

so is quite a few modes for all options
///
- other modes/to fill in:

- Rungler:

Original: SR bit out XOR with OSC1 out (OSC1 speed/freq) is determined by SR (itself)

translated: cycling bit XOR with other SR out bit which is clocked by
SR/or DACspeed from itself (bit clock options are set BY SR itself) 

or:

cycling bit XOR with DACout from own/other SR vs. comparator=CV/DAC/DAC+CV/CLKCNT

///

- leaky logic, memory logic to play with 

- Beckett/gray code.

Gray code: where each line differs in only one bit
Beckett/gray: as gray code but bit first in first out (history of bits also for leaky???)

bit position x which has not changed... FIFO ... we have list of transitions (which bit flips) for n=5 etc.

- modes from original it.c ported to generic form

- use of clkins for LR to select options in CVmode as in AC

** ADC modes 

TODO: more comparator modes, adc_in to be compared to what? compare to: CV, DAC, CV+DAC, to clksr_, to param - OR feed these into otherpar already

** DAC modes

** new modes from below

DONEProbability modes: CV//PARAM//SRDACx > SRDACx -> result - case 30 with dacy<dacx

DONE+ADC could also be used in probability modes+ - case 29 now

DONE- 8 bit cipher code --> we have in ADC_ mode 8 ,, but could also be used for modes case 32,33
accumulate into ggsr and then bang in to realSR on a CLKIN (how many accumulated bits or just whole SR length?)
4094 - on STROBE signal, SR is transferred to the storage register...

DONE- triadex: we could use counters from clkins as indicator of which bits from which SR to parity-in
--> this is an XOR of 4 bits - selected from clocking bits, on/off bit and from shift register feedback
that we can have XORs of bits from other SRs entering our SR
so table would be for 4 bits from 4x maxSRlength=32*4=128 (ignore lengths) - case 35

DONE- pulse triggers exchange between ghost and real case 36

DONEhold ghost 37

DONE- pass through or cycle is toggled by clkin bit - case 38

DONE - multiple DACs - but how we do this as a single mode (add/sub/wrap other DACS, additive DAC into DAC[2]) case 39

DONE- swap over SRs on pulse in?!! or swop in only (can swop in previous SR or another?) 

DONE - TM in TM

DONE - reverse direction of shift register - could be done on a toggle: >> and << and blank/fill in bitn

DONEinDACcase15 - toggle/record/keep frozen bits and keep these ORED with the shift register as it cycles or does whatever

DONE - probability for reverse direction - case 45

DONE - instructions shift left or right the associated LFSR (instruction as 1 or 0)... and enter this bit into our SR... - TRY THIS as ADC mode - case 27
can also be other shiftings using bits (xSR shifts ySR left or right)

DONE - - cycling array of ghosts toggle in/how to toggle out
could be keep recording into array and on INT we cycle through (XOR/OR in pass through) until we get to last recorded of max x case 46
// could also be alternatives but as it is we just replace on INT the revenant SR

- more modes which play with GSRs: GSR as mask for???..., freeze/speed up
  GSR, GSR runs at CV speed in INT mode (try - and vice versa)DONE, re-routing make use of
  GSR already. 

swop GSR/SR or /into/ SR (before copy?)????

DONE- GSR doesn't change (becomes a revenant) 48 and 49

// pulse in means double a step.. ????DONE

- modes which manipulate THEIR OWN SR routing table/speedfrom tables - DAC/CVetc ... - this is already in modes 24,25,26 to re-examine

24: clkin bumps up routing table only

25: INTmode - CV shifts table and lowest 3 bits of DACmode - so total of 6 bits only - we could expand this for other bits - added logic table

26: as 25 but with SR as source - added logic table

*TODO: use SR/GSR as bits - other important bits: basic ADC type, multiple DAC out/no DAC, SR-logic_table, routing (includes type of SR)*

*also speedfrom_ table->who/ but can't use cv for that... TODO*

- most generic table for all elements which could become itself a SR//SRx as determiner...
use DAC, CV or SR as this can be different to DACs (if they are not just default)

////

trial bits:

pulse/cv speed, input ADC/LFSR/no, output DAC/else?, type SR, type SR, type SR(3 bits of types=8), routing from (4 options)  
1               1     1            1                 1        1        1                           1 1 1 1 - 4 bits just to make it easier but could be less

eg.
0-looping only/aka return only!
1-pass on only - straight through
2-pass on and return bitx


- expand all possible probability modes...???

3-TM with pass on - INT mode
4-TM with loop back
5-TM in TM pass on
6-TM in TM loop

7-Rungler XOR pass on
8-Rungler XOR loop back
9+Run with different speeds???
10+Run with bits???

** AC modes and inspirations: TODO TOOO

- clkin leaps/flips bits - that we can apply a mask from clkin for
  whole SR - would be nice to be able to freeze this thoughDONE to some extent

- DONE in adc_ - case 31 - TO TEST shifting array of taps/ghost taps/ clksr can also be taps: ghost_tapsL[32][4] = { // left hand path ghost_tapsR

- sr loops in sr

** first it.c modes to port in

[- TM and other prob modes:  CV in as comparator for SR DAC, CV as comparator for ADC in, ADC as comp for SR DAC
all the comparison possibilities]

- overlaps

- shift x bits

- SR in SR//barriers


* diary sept 2021+

PLAN: all new modes, put first draft together

16/11/2021:

- tested speed with clk and is fast enough so far (re_check after all switch/cases) - can even go faster:   TIM_TimeBase_InitStructure.TIM_Prescaler = 8 ???

- TODO: fill out adc/dac modes in new draft, maybe port in more modes
  from it.c and also maybe deal with ghost taps

  // try putting LFSR feedback into smaller coggSRs!DONE
  // also testing LFSR as structure for all... - but this is maybe too noisy



15/11/2021:

- for all w==3 modes except route changers we need to set count back to 0

global routings:
INTmodes: CV as route (CV cycles through list or changes list then binroute would change) + fixed new routes

CVmodes: trigger bumps up binroute + fixed new routes, trigger toggles altroute/regular routes (also prob?)

DONE: fixed otherpar and strobe in DAC...

TODO: port in first it.c modes above// first a few attempts in draftnov

13/11/2021:

- case 59, generic routing with ADC working // test in case 59 w==3 global route changes...TESTED - in case 59 and works ok...

60 very generic routing with MACRO fill in/ 61 speedCV complemented by trigger

- check out macros with variables to throw in - test in case 60 now but possibly too generic or we need to add probabilities...

QUESTION of how to manage modes now - first finish ported in modes/all modes // check logicand then start to see how we can draft modes...

12/11/2021:

- case 58 approx generic mode is workings

- leaks using RSR is a bit odd, but we can have different leaks which could LFSR...

11/11/2021:

- thinking if to have global routes or just individual changes to
  routing table? could have global if have say 4 R modes multiplied by
  4 route modes for each section... test global routes...

- not to have several ADCs in/no multiple DACs - but still keep basic dacs for 12 bit length

10/11/2021:

Q is of a new structure

- LARGE notebook notes: possible to use Rmodes as global modes for:
  global routing changes, +multiple DACs out/mix+, +potential several  ADCs ins (in different modes)+. 

  In CVmodes we would either have fixed modes brought in or param, bump
  up routes. In INTmodes we could use CV for modes.

- probability also to bump/shift or otherwise modify routing/logic etc. tables (single or global)

prob mods bits/masks bits

defroute is the one which we use generally now - unless we are in multi-routing
modes? (or DO we make this global default, but is much slower - think about)

pass/cycle/cycle and pass as routing only

- *see if we can program generic routing, probability mode*

////

- TODO/some for finals: more param[x] modes perhaps, 

different speed options for projected CV+DAC modes 32-47, 

new prob modesDONE, 
check bit routings againDONE and added for testings new bit modes (bits for prob and logop)DONE

try out new routing (eg. bounce back)

can add more mixes in ADC (adc in/lfsr/otherdacs/mult dacs etc)

- removed intcnt but need to fix triadex mode 35 - q is what is range of param? FIXED

- added logopx which can just return our bitn

9/11/2021:

- possible multiple ADC in modes,,,, 

- added case 30: adc |(xor TODO) with length of bits, for INTmode this can also be CV-param

*in ADC_ otherpar can also be CV for intmodes*

- expanded ADC_ function for extra params but should decide on how many bits for otherpar (dac is 12 bits so) and then fix length/restrictions there

- added logic table bits and fixed leaks in logop for modes 25 and 26

- notebook notes: ADC bits choose: what is compared to what, what is source...???

- one INTmode for ADC/DAC could use CV to select 1 of 64 modes - but
  then we have problem of otherpar being different sizes, sources
  eg. from strobe, for len bits etc.

- mode also (maybe INTmode) to select different DAC modes for LRN too!

- to think about/test multiple DAC outputs - additive, sequential, what else? and how these are signalled...


8/11/2021:

- how to expand and contract routing for each SR. what is contracted=just-to-itself, most expanded= last one..., between=

long routes would be n-l-c-r-n

*Q. of whether to have extra ADC/DAC modes available as CV options on 1 or 2 INT modes - see above - would also need to be another long case/switch*

- INT modes need to use speedCV (see list in notebook)
- so the 16 INT ADC/DAC modes need to use CV
- added modes, ADC prob mode...

6/11/2021:

- toggle/record/keep frozen bits and keep these ORED with the shift register as it cycles or does whateverDONE now as DACmode 15-TEST!

5/11/2021:

- reverse SR modes - 42 and 43 DONE 43 is not so good/reverse cycle round/// try combine with 42 -> 44 DONE which is better

- toggle/record/keep frozen bits and keep these ORED with the shift
  register as it cycles or does whatever - testing now as DAC but it
  should not mask itself???

4/11/2021:

- question also if we use dac[3] and this also does feedback in - maybe try dac2 or dac1

- also if we make use of dac[x] where do we set this to be other_than_default otherwise we may as well use SR instead (except in multiple dac mode)

//TODO: fix on multiple DACs and which DAC or SR we use by default for each SR...

- DONE: fixed param in DAC so we set par=param[x] or cv in the case! but we need to remember to always add this if need be!

- DONE: changed DAC_ with extra params, added ADC speed and comp modes, some work on DACs, seq DAC not so exciting...

- bit length can also be CV - how to put this in as DAC is quite fixed in macro

ADC modes:

- that we can use param other than LEN for bit length in some of ADC and DAC modes... (eg. CV also as param in INT modes with these)DONE

so we can have standard 12 bits (len==11) adjusted to length, full
length (whatever that is) regardless of len, and xbits from otherpar -
in these cases length doesn't do much...

DONEpadding for seq adc, dac and strobe/adc modes 

*basic routing modes:*

- route in from sr[x] 
- cycling bit
- LOGIC (or,and.xor,leaks) - route in from sr[x] and cycling bit // xor one would be rungler in adc mode with dac from other in, or would be CGS

and LOGIC of pulsins

TODO/check: *all classic probability modes:*
classify:

[prob modes for ADCin/w==0 prob of entry of bits/vs cycle etc, DAC modes can use regular prob mode]

prob to DO:
invert cycling bit (TM)
invert incoming bit (ADC or route or both)

take incoming bit (ADC or route or bothLOGIC)/OR/xor it with cycle bit (RUN)
take incoming bit (ADC or route or bothLOGIC)/OR/LOGIC it with cycle bit

incoming bit(ADC or route or bothLOGIC)/OR/cycling bit (EN/WIARD)
incoming bit(ADC or route or bothLOGIC)/OR/INVcycling bit

////
TM: cycle bit is noise vs. comp less than 1, otherwise invert cycling bit

RUN: ==not prob mod but could be made one: XOR cycle bit with input bit which
comes from oscillator [in benjolin the DAC out effects some parameter
of both clock and data] eg. DAC effects speed/clock of SR

WIARD: noise/comp selects new input or loop back/inverted loop back (jumper)

EN: LFSR SR bit is loaded/not loaded onto recycling SR. loading can be random (based on LFSR and set of probability switches)

*comparators for probability and ADC depending on INT/CV mode*

/for prob:
1. if LFSR/SR/DAC<CV  // int mode - as DAC is not necessarily CV!
2.if LFSR/SR<DAC[x]  // cv/int mode
3.if LFSR/SR<DAC[x]+CV // int mode
4.if LFSR/SR/DAC<param[x] // cv mode

can also use comp clksr_ as SR, and adjust routing of SR for comparators

/for adc:
compare to: CV, DAC, CV+DAC, to clksr_, to param - feed these into otherpar

could it make sense for DACs? DAC could be shifted by CV or by clksr_, other DACs.

*CV modes which deal with CLKIN* - as a bit // - as a condition // - as a PARAM

- clkin in can toggle entry/no entry of new bits, cycling etcDONE do also for ADC
- clkin in can bump up/shift left/right the routing table, speedfrom table, logic table, dac/adc table?
- clkin in can mask bits as for DAC etc. or SR etc - if we pull it in to a SR for each of N,L,C,R  but bwhen do we do this as can't be in INT
- clkin in can also slip/slow/bump up one CV speeded SR = slip, freeze or jog SR on CLKin

*how we use CV in INT modes (as we need to use it):*

- as comparator for ADC in (and for DAC?)
- for LR modes: as comp. for prob modes, to assign routings, as extra mode selector
- as modifier for CLKIN speed-divider?

3/11/2021:

- DONE: more macros but still need to test/re-test all

*Q* if pulseouts should be after shifts ??? guess so...

- in ADC: why (length-3)? to get down to 1 bit so could also have option for full bits!

- tested speed/stop again for all modes? - TO IMPLEMENT as makes sense
- fixed case 3adc and case1dac so we can have as many bits as 32 for equivbits setupDONE/TESTED
///
- incoming clk bits as further SR in main TIM2 loop (question of speed
  of this now) - or do we just do this as ADC inputDONE but could also
  be custom oneDONE - use also as sieve (case 10 in DAC) - what other uses? as comparator for ADC in?

- strobe or copy clksr in // as adc option... question is how to strobe in - on a counter/length? added as adc case 19

maybe list the SRs that we have available...

shift_[x], Gshift[x], LFSR_[x], ADCshift[x], ADCGshift[x]??ghostforadc/strobe, GGshift[x], clksr[x]

how to swop between relevant ones?

- probability modes can also use DAC, clksr etc,,,  what we compare to what???

LFSR<CV(most), LFSR<DAC+CV (17), LFSR<DAC (18), LFSR<PARAM (19)

also mayeb more use of comparator with these in ADC mode

////

- start on first 16 modes/check all ADC/DAC options

- tested speed/stop in case 0! add to templates
- new full 32 bit ADC mode with padded bits in - also add strobes and other ones using this 

2/11/2021:

bit entry SR (from each CLKIN) can also be used for TRIADEX style thing,

all SRs/and CV can select routing/logic/speed bits

ADC could also be used in probability modesDONE

templates for speed/dac modesDONE/, INT modes but also how we deal with split of modes for DAC/ADC? (if...)

test new speed options!TEST!DONE!

////TODO:

- TODOs from theone.c - eg. extra DAC modes but now we have too many modes/cases,,, maybe to simplify

LIST MODES so far! and notation of modes

- what modes we already have implemented? also what ADC/DAC - plan to finish/draft?

- feed back RSR could have stop/no motion at top of speed (but how to do this without an IF clause?)...

/////

TRIADEX notes (from below etc):

- in original: any of SR bits (from any SR), CLK and its divider go as 4 bits into parity generator
- we could use counters from clkins as indicator of which bits from which SR to parity-inDONE

////////////////////////////////////////////////////////////////////////////////////////////////////

1/11/2021:

- DAC_ re-test case 7 and 8 as possibly fixed mistake there...DONE

TODO: 

- macro for pulse outs DONE
- what we need to test/implement and list of modes...

19/10/2021:

basic modes: pass through or cycle is toggled by clkin bit

TO TEST/adc strobe modes a bit similar...

new adc strobe modes: 12,13,14,15,16 - don't notice so much... maybe replace with toggles TRY THIS!DONE

new dac strobe modes: 5 and 6... - 6 toggle one works ok


- hold last DAC value (or ADC/set of bits) on a CLKIN 1
- toggle hold on a CLKIN 1 

- these are like the strobe? strobe is different in both cases - in DAC case is just inverse of strobe

15/10/2021: how to think about squash and expand routings on level of individual SR

- DAC out from ADC in

route goes N->L->R->L->R so implies sequence - order through a
sequence, and a length of sequence but does this not need to be agreed
on across modes as each SR just takes care of WHERE it routes from... but this could for example cycle every X turn 

cycling of in routes!

0123
eg. for N/0 cycle would be: 3,2,1,3,2,1 (depending if we include itself- 3,2,1,0)

what would squash be? 3,2,1,0 to 3,2,1 to 3,2 to 3(R) and how we signal the squash...

14/10/2021: for 4 bit spacers maybe also have options for different routings... squashed routings, compacted routings

sketch out modes:
CVspeed:
1-15 -LR simple modes/all inc prob
      N 8xADC x2 - pass in/circle_and_pass or 16 ADC modes with pass in only!
      C 4xDAC x4 - pass in/circle only/circle and pass/prob

16-31 LR - exp modes
      NC - any match modes 4xADC, 4xDAC

CV+ADCspeed:
32-47 LR - modes mixed
      NC as 1or2

INTspeed:
48-63 LR - mix using CV params - prob,,,
      NC 4x ADC/DAC and prob modes    

13/10/2021:

- fixed 4 bit spacers i think... mode 27/28: xor returning, also 4 spaced equiv bits for DAC DONE/TESTED

- ADC as seperate condition in each mode, maybe DAC too, subset of basic ADC and DAC modes...

so eg. 4x basic ADC and modes would follow: circle, pass on, circle and pass, basic probabilities
and some more exotics...


12/10/2021:

plainer that input mode NSR is most fixed of all, we can have multiple
DACs out from anywhere, also everything does not necessarily need to
be on NSR

- array of certain values eg. dac for each mode, how to simplify if at all?

- probability modes with routing/adc selects for incoming bits

- spaced outTODO

- triadex muse: clocks/divisions/SR bits selected and XOred back in...

- how we select those options -> we need 4 bits back in (so 4 to select from other SRs, bits from own SR)...TODO

or ghost SRs - select 4x bits 0->SRlength from 4x SR? or just stick with itself - variations on parity bits

- inspired mode where we XOR in other SRs. -- and we use static SR or we wind through SRs... or multiple XOrs in -> modes20,21 DONE

//new defroute: uint32_t defroutee[4]={3,0,1,1}; // 0,1,2,3 NLCR - in this one 3 routes from 1 too
but how do we have this in modes as is same just not for RSR...

one option suggest as clkin flips that routing (or any routing, or advances routing table)... DONE


11/10/2021:

- what we can salvage from it.c: overlaps, SR in SR, how we could pick up or work with other ghost regs, revenants, various 4 bit in variations

starting to think about 4 bits in/out for different lengths: GENERATE:
array of masks, 4 values for spacings, SR with 4 bits in needs to
cycle on those 4 bits...

they need to be spaced out x bits apart depending on length - further array


/////////

- from AC: shifting array of ghost taps, otherwise lots of dependency on pulses we don't want

24:	// Insert pulses into SR at points determined by CV or by pulses in - very similar to mode 2 above - TESTED/WORKING!

25:
	// SR loops within SR at certain points?/sizes determined by CV or pulses in = basic SR of OR with incoming bits - TESTED/WORKING!

// pulse in means a divide/flip flop
// pulse in means double a step..

uses CV as speed/flipflop/clock divider in INT modes

using clock as on/off gating of functions

// also we can have one bit data with selection of params for BETA/low pass filter!

DONE: sketched out probability modes - to be filled in, further ADC modes and tests...

- how to reconcile multiple modes with multiple ADC/DAC options -
  reduce number of modes in those cases ...

- working through probability modes - to figure out how ADC options (and DAC) fit with these...
eg. with adc in mode do we do for all 

- also further question if we have multiple ADC ins? (ie. max one for each register?)

- 4 bits In/out with DAC/ADC

///

1-Basic modes/DAC/ADC modes
2-experimental modes DAC/ADC too: eg. *set parity points for LFSR or for entry from other SR... (4 parity points or more max?)*
3-probability modes
4-routing modes/extra speed modes

DAC and CV, INT and CV -> speeds

8/10/2021:

- adding ADC and DAC modes: some still to test like strobe driven...

- where we place probability code?

question of overall structure now:

speed/where we get speed from?

route/bits/in + modes which manipulate routing or SPEED table (with DACs, CV, INT/CLK options, SRCLK)

ADC/DAC types

special modes/emulations: prob modes

7/10/2021:

- modes 6,7,8 are quite destructive noisy with pass&loopback for DAC and ADC - so maybe remove these
- try counting pulses (12 bits=4096) within length of time for use as parameter...(q of speed...

main.c TIM2 32/16=// period 32, prescaler 8 = toggle of 104 KHz - so 50 KHz

- re-did param code so is now time between pulses...

- DONE/TESTEDtest equiv bits ADC code, add in onebit oscillator

4/10/2021:

First 5 modes done with LR/route/logic options and ADC/DAC options-> these also need new routes and logic

TODO: experiment more with leaky code and timings, triggerings of leaks...

/////

add in DACs into ADC and DAC modes/INT modes only if we use CV???

//for input modes
CV/param//+DAC as input
CV/param//+DAC as comparator for input
CV/param//+DAC as input spacings [where is placed into SR]

CV/param+DAC as output spacings

CV/param selects routing 
CV/param+DAC selects routing


Try to condense what we have here in segmodes into:

- ideas for modes to be implemented/tested:
- layout eg. speedfrom, routing, ADC/DAC:
- generic/functional ideas eg. how we count pulsins:
- ideas relating to LFSR, ADC, DAC etc...:
- file under OTHER:
- esoteric:

*INT as signifier for interrupt/trigger modes*

- re-routing is not so important - can be in INT selected from CV/DACplusCV
so CV/speed is more or less fixed routes only maybe with one exception

Q of more trigger modes?

- can route DAC(+CV if INT) -> ADC inputs

- different ways of counting pulseins (eg. reset generic counter on pulsein) or count gap between pulses = number of pulses in time xDONE

- swap over SRs on pulse in?!!

- INT mode: pulse ins (only have L and R) can toggle SR on/off - eg. hold it even against new CLK/INT

1/10/2021:

from below: for 1 or 2 of trigger modes: SR->bit speed (ANDed with CV/trigger) eg. if && bitx//and_train of pulses also (see below)

- idea that CLK pulsins could trigger train of x pulses at speed y
  (eg. y by CV, by DAC) - descending speed, speed from other SR, train
  from other SR - how to do this?DONE 104/105tested...for INT-DONE

////////////////

30/9/2021//1/10:

- possible SR modes adjust/set certain settings which stay that way until they are re-adjusted?

- that incoming bits/pulse bits could also be formed in SR which can be used (as DAC, as whatever)

- interrupt/trigger modes with CV as divider!

// question of how to organize/list modes as there are simply too many options even with fixed routings

eg. each has:
- basic/logic//type of SR eg. simple pass, loop, pass and loop, other logics, probability of bit in, of a flip

- for CSR we have DAC mode!
- and for NSR we have ADC/LFSR (2 options plus more esoteric options for special cases)

TO RESOLVE then:

1- question of NSR/PWM (which DAC we use - RDAC by default) and more about normed CLKS (L,R,N)
//RDAC for NSR/PWM and ghostSRs for normed clks (with speed of these from what, from RDAC?)

2- which DAC we use for speedCV+DAC// all the same? selected by what means, fixed but different eg. 
N-R
L-R
C-N
R-N
//as this answer also effects next:

3-how we deal with differing DACs across differing modes? do we need to 2x or 3x all modes for all differing DACs?
//just use basic mode for other DACs so we have a fixed dac table

4-list of modes and format for this for each N.L.C.R. also how we deal with N.L.C.R within cases...

5-special meta-modes for say bus of DACs etc.

6-what pulse can do in CV modes eg. PUSH on bits so is like speed plus pulse
7-what CV can do in pulse modes eg. comparator. as well as each as parameters...

other:
- pulses/clkin in can toggle entry/no entry of new bits, cycling etc
- pulses/clkin in can bump up/shift left/right the routing table
- pulses/clkin in can mask bits as for DAC etc. or SR etc
- pulses/clkin in can also slip/slow/bump up one CV speeded SR

29/9/2021:

- possibly we have static routing for R->N L->C and variable for L and R // with ADC/DAC options//but as we note above L and R also have DACs which are used...
 
as first set of modes: what are our modes - DAC/ADC/routings

- for some interrupt/trigger modes we can use CV for routing table...

but there is a problem if CSR CV is normed to speeds of others at the same time...

again question of NSR/PWM (which DAC we use - RDAC by default) and more about normed CLKS (L,R,N)

but as we no have less clk modes we can also use ghost SRs, but at what speed, speed of RDAC???

28/9/2021:

- new speed scheme/cv/dac to test now on speedc/lower one - seems to work well...

- BOM/pos/quote made 28/9 AM pcbcart/ordered30/9

27/9/2021/ notes from last days:

- back to testing in it.c (not generic but slowly port/change that code) - new speed scheme

RESOLVE:

- CV modifier in pulse modes

- fake CLK triggers from?

NSR - always TImx from DACx
L,C, R - from speedC-cv always

what else makes sense - ghostSR but is more complex!

- all simulated modes. eg. EN/electronotes - generalise as probability of new entry/just cycle/of inversion

- test as CV generator

- sequential SRs mean we can also slip one SR or double it (how to control this)

- DAC/multiple DACs -> DAC bus/mix or even one after the other (faster)??? but how do we decide on this:

eg. one SR has DAC out, any can have and is mixed, any can have and is sequential (as is meta-mode not just decided by SR) 

- interrupt modes as 48-63 last quarter...

Modes: // check if we can possibly hit more than 64 modes !?

0-15: CVspeed: NSR, CSR have ADC/DAC options and basic routes in, LSR and RSR have all routing bit possibles, basic logic ops
DAC is fixed from CSR, input bits from NSR

16-31: CVspeed: exp modes, all SR->rerouting options
DAC can be anywheres, ADC also (how many bits we have), resolve this!

32-47: CV+DAC:  simple modes, exp modes, all SR->rerouting options
where do we get speed DAC from - is it always RSR?

48-63: Interrupt/trigger modes as mix of all...

//address issues for each mode (selected) 

other:
- pulses/clkin in can toggle entry/no entry of new bits, cycling etc
- pulses/clkin in can bump up/shift left/right the routing table
- pulses/clkin in can mask bits as for DAC etc. or SR etc
- pulses/clkin in can also slip/slow/bump up one CV speeded SR

//////////////////////////////////

beckett/gray codes for routing ???

21/9/2021:

- how to go further, collate ideas and see how these fit or don't fit with generic model:

eg. in AC Cv modes was lots of use of pulses to do things which now we lose a bit...

or we divide across 2 sets of generic modes, or simply have generic modes for things like routings

- that incoming pulses can eg. change flip or not flip, change routing table, invert mode bits

seperate mode and mode bits: mode determines mode bits (on mode change)

- fixed small bugs (like static in one bit DAC), and routing for fake clks

20/9/2021:

- testing generic SR is it_generic.c

notes:

- had to break down loop though as speed was overlapping/effecting others, can tighten up and make faster from main.c TIM2 dividers
- that we should be able to make bitsize of dac independent from length - maybe?
- lists of modes/settings

- TODO: probability in generic code? TESTING but might work???


17/9/2021:

- question of how we work with probability within generic framework - as in TM etc...

// make it_gen.c + stripped version to test generic code!

16/9/2021:

- idea that CLK pulsins could trigger train of x pulses at speed x
  (eg. x by CV, by DAC) - descending speed, speed from other SR, train
  from other SR

- how to arrange:

CV speed
trigger speed
speed from other DAC (which one) with CV offset
SR->bit speed (ANDed with CV/trigger) eg. if && bitx
train of pulses also (see above)

[SR->fake triggers and mainPWM/normed in - but that is determined by other SRs] -> we need to sort this...
-> how these are all selected as all SR are independent

//MODE - where do I take my speed from?

to resolve fixed scheme eg. CSR->DAC out as we can't have 2x DAC outs simultaneously (or we have bus/mix)?

TODO: implement basic very generic SR for all cases, test if flag in clkin interrupt works so we can place all in main loop

1-Where do I get speed from? if from SR which one and 
1.5-shifting of which bits <<
2-where is the input bit from (LFSR, ADC type?)
3-what is routing for incoming SR bits, cycling bit
4-what is incoming pulsin bit if any?
5-XOR of logic op of all bits and re-insertion
6-DAC output for any purposes
7-pulses out if any

8-fake/pwm for normed clkins - how? or we keep standard?

options/ideas: DAC out runs at full speed and is changed by all/any, clkin interrupts flagged so all is in main loop

  // we can still have specialised SRs but they should all be repeatable
  // so can be placed in a loop!
  SEE:  *generic.c*

////////////////
how to resolve clock norming?

So we have PWM (TIMx) which norms to NSR clock - this is generated at the moment from RSR DAC

LSR, RSR and CSR have fake clocks - CSR should be from speedc/CV, LSR and RSR???

15/9/2021:

- testing and implementing arrays for puls ins and outs (left, right and c) DONE
- place into not-so-generic pasted LFSR round one at start// DONE

- implementation for Benjolin/halfDONE but need to think about how we
  can make generic one SR clocking another without failure in any loop, and/or generic use of fake clkins

- TODO: Benjolin in trigger mode using fake clks - FIGURE out how to prevent freeze (CSR will have speed)

- so start to think on what general modes for Vienna could be (before we get to rendering as all generic)

// using sigma delta for bit input an low pass out (see test.c)
// all modes with bits in and out

eg.
0-looping only/aka return only!
1-pass on only - straight through
2-pass on and return bitx

3-TM with pass on - trigger mode
4-TM with loop back
5-TM in TM pass on
6-TM in TM loop

7-Rungler XOR pass on
8-Rungler XOR loop back
9+Run with different speeds
10+Run with bits

11other exp modes/trigger modes//what else?

DACs,ADC types

TODO: always have NSR/PWM from RSR DAC for the moment - so to add to the basic/pastey!

13/9/2021:

- clock fake routes: R->L and L->R (output bits of SR to CLKINS), CSR is speed controlled (has to be) - TO TEST!
TESTING but tricky so made all from speed... NSR/pwm is from DAC

- make latest TM SR more generic/start to port to arrays/tables

11/9/2021:

finishing DAC and ADC generic options:
TODO// other options are: comparator, equivalent sets of x bits incoming 

possibly we don't use fake pulse ins for norming left/right - to test that these don't effect incoming
(but we do need to use CLKins normed for L,R,C) - test with incoming bits

10/9/2021:

inline int bits(uint32_t reg, uint32_t length){ // function returns bottom length bits of SR reg

and another inline function which returns different kinds of DAC from
a certain SR eg. standard DAC of x bits, equivalent dac of x bits,
what about one bit dac (more involved as takes time but we should have
a pointer to that value????

9/9/2021 

// always do DACs - but how these are handled according to length as we still want fixed number of bits

implementing TM in TM: slowly start to see how to abstract as work through and implement all modes

- TOWARDS: basic framework to use in Vienna! (using one bit DAC out
  tho which we could also include in routing tables and as an always?)

- each SR delivers DAC, how to do tables which don't allow for overlap of DACs eg.

1000
0100
0010
0001 for each table

structure for all eg. speed from routing table// all is defined by tables/arrays which can be routed

in test2.c speedroute as array of pointers to values...

pulsin bits L, R is XOR always with new bit

basic modes/expanded modes across split of cv/speed, pulse speed...

/////

how to make uncomplicated generic SR options which can interact across all sets of:

1st set: simple SR modes for each SR with fixed routing
1.5th: simple modes but with very specific configurable tables for routes eg. speed routes...
2nd set: generic SRs with configurable routings
3: complex routing with DAC, ADC etc.

generic as all routing is internal - we do not dictate to other SR...

// also from triadex muse:
--> this is an XOR of 4 bits - selected from clocking bits, on/off bit and from shift register feedback

that we can have XORs of bits from other SRs entering our SR
so table would be for 4 bits from 4x maxSRlength=32*4=128 (ignore lengths)

thinking about multiple routing for DAC, clock DAC and ADC??? how this might work as gives flexibility for timings

then we have x bits:

routing / DAC output / LFSR feedback / ADC IN 
1 2 3 4 / 5      /  6            /  7

extra bits: clock DAC/pulse for speed with any offset(CV), comp DAC ->9 bits, 

speed modes: CV as speed, CV plus DAC as speed, pulses, pulses from SR, combination of... see more below...

// and how would routing be for pulse modes: pulses, pulses from SR - but we can't use our own pulses
// we can't make this so generic as one set uses interrupts... also we can always reroute pulses with cables so...

CV plus DAC in CV modes, pulse plus SR in pulse modes????

routing table is for incoming SRs

abstract out LFSR perhaps as just the returning of bits (so is routing)
also we have entry bits, ADC bit/s, pulsin bits, returning bits

what bits come in, logic, what determines speed, other determing factors for specific SRs


speed/routing/logical ops (logical ops as also selected by bits, overlaying of masks)

- question of multiple DAC outs - what we do with them

if each SR has DAC out which can route somewhere, and ADC in

7 bits - which is 0-128 (test if we can reach on CV knob)

Other bits for pulse/cv and type of SR are fixed across multiple modes.

routing also DAC->speed of register x
pulses->speed of register x

seperate DACs for output, speed/NSR normy clock, other uses (comparator)

1 2 3 4 bits - question is if we combine multiple DACs???

how we deal with incoming bits/pulsin?

///

(or we have anyways routings which are flexible so maybe is ok. just that DAC out clock/speed effects feedback etc...)

// to have experimental modes in second half which do routing bits: in
pulse modes these could depend on CV, and in CV on pulse or RSR.

6/9/2021 - important thing is if we have routing table then what do we do if is
  zeroes for one route - we need always to preserve a default route

for first half of modes we fix top SR as in, left as through, right as feedback, bottom CSR as output


////

TODO from below:

- set up clockins for basic pass/recirculate SRs and test with norm of CSR DAC to top TIM1 NSR pulse-DONE
- start porting SRs - more generic from AC!

- test use of manipulated routing tables for one SR
- trial RSR as random register with various routings for simulation of electronotes and TM.
- in test2.c compare generic shiftings with coggs version (and also if we still need to do <<1 if routes to itself?)DONE, yes they are the same, and we do

- ghostSR in ghostSR in test2.c to trial//also various crossings of delayed ghosts with "real" SRs

from test2.c
// own routing means we have the shifted out bit already (route to self) - but we still need to shift

// we could also lag the ghost so is like a delayed revenant
// so example it only shifts itself if there is a pulse bit

////////////////further

// and cycling/circling array of ghosts which can come back or go forwards/backwards - when these ghosts are copied over (on event)
// with 256 cycles/copies - or we can have variable length of this shifting array

we can also determine cycle we use using another SR

** xxxxx

proof of concept generic routing in test2.c

default or not: CSR DAC out->top PWM/TIM1 which is normed to clock pulse for NSR

*[we need to trial if this makes sense with routing]*

// what bits make sense for SR definition to be changed by other processes?

eg. input types are fixed or not, routing yes

so we have several bit modes for different main SR types...

for example bits determining type and routing = 7 bits

- that we can choose (eg. RSR) to be specific controller or
  determining SR (eg. for random operations we refer to this one
  eg. for TM and electronotes determinings - to test this)

- routing bits (routing table as one SR?) - or routing bits flipped/changed by other SR, incoming pulses...

- generic: new inputs or not, or logiced with - returning bit or not or logic op (inv), parity settings

equals:

generic parity settings in array (0 for no feedback or tag array with meta-array for type of logical operation, or where it comes from)

trial bits:

pulse/cv speed, input ADC/LFSR, output DAC/else?, type SR, type SR, type SR(3 bits of types=8), routing from (4 options)  

1               1               1                 1        1        1                           1 1 1 1 - 4 bits just to make it easier but could be less

is already 8 bits which would be 255 modes!!! we have limit of 64 modes

+ additonal bits: advance on cogg, logical opps, type of ADC, type of DAC, OR of LFSR/ADC 

// and we just leave outpulses as generic/divide down on 2nd set

unless we have other ways of thinking of modes... (mode as itself shift_register, pulses as incrementing modes or is that all too complicated)



*thinking to have special modes - at end of mode dial which implement this kind of thinking: even 3 or 4 last turns which inc bits*

** how to make modes more generic/independent whilst keeping routing options and open-ness?*

- feedback thru RSR makes more sense for ADC in modes and less for LFSR so maybe this decides routing?

- *what if each of the 4 SRs is totally generic* (in/out can be from
  anywhere, routing is unfixed and modifiable in runtime,
  self-modifying) - so there could be multiple ins, mixed outs
  (busses)... how to test this as proof of concept?

- that NSR and CSR can be input and output buses

- what this means for eg. notion of coggs and dependencies on other
  SRs, digital style filters etc. maybe make small test - but problem is to have too many SRs types

but also means we can have routings maybe switchable from pulses or from CV

eg. switch routing on certain conditions...

*or can mix of generic and otherwise work - as long as all are independent and share any necessary information. eg. new cogg/reset function*

as in we can mix use of arrays of (pointers)/srs and shiftregs with names which point to these...

** generic SR classifications to work on:

-routing
-what drives it on: pulses, bits/otherSR, values=speed // values from CV, values from DACs/SRs
-looping/input bits
-output bits
-question of overlap/coggs/SR

or:

-what drives it on: pulses, bits/otherSR, values=speed
-returning bits (eg. LFSR, no bits=pass_through)
-overlap (eg. LFSR in overlap, size of overlap)
-incoming bits - this is routing also and pulses in/ADC, and what is done to them (eg. flip them)
-output bits/DAC

or: shift x bits, length, entry new bits

and ADCpulsesDAC are attached in to this (as NSR, CSR)

** another attempt from notebook

1. basic division speed/pulse ->32 modes
2. output/input ADC/DAC/LFSR/others
3. type of SR-parallel/Turing.etc., logical opp (XOR,OR,AND, leaky)
4. what are incoming bits
5. outgoing bits

** code basis from test2.c

uint32_t *shift_[4], *Gshift_[4][4], coggs[4][4]; // gshift is 4 even though we don't use one

b=0; g=2; // n=0,l=1,c=2,r=3 // so feedback here is from c 
bitn = ((*shift_[b] >> (lfsr_taps[SRlength[b]][0])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][1])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][2])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][3]))) & 1u; // 32 is 31, 29, 25, 24
// need to catch it
if (*shift_[b]==0)     *shift_[b]=0xff;
// copy now to ghost
//we need multiple ghosts for each possible shifter: eg. Gshift_rl, Gshift_rn, Gshift_rc (right ones for left, for n and for c)
*Gshift_[b][0]=*shift_[b]; 
*Gshift_[b][1]=*shift_[b]; 
*Gshift_[b][2]=*shift_[b];
*Gshift_[b][3]=*shift_[b]; // ghosts for l,c,r only but let's keep one spare
// what else it needs to know - for each queued SR we need one cogg=0 for reset as we reset each on reading
cogg[b][0]=0;
cogg[b][1]=0;
cogg[b][2]=0;
cogg[b][3]=0;
  
*shift_[b]=*shift_[b]<<1; // we are shifting left << so bit 31 is out last one

bitr=(*Gshift_[g][b]>>SRlength[b]) & 0x01;
*Gshift_[g][b]=(*Gshift_[g][b]<<1)+bitr; 

*shift_[b]+= bitn;// & bitr;// ^ (!(GPIOC->IDR & 0x0010)); // or goes to 1s, xor is risky, AND works... and clockbit PC4

//also we can make bit access (eg. GPIOC->IDR & 0x0010 - can we access register as pointer TEST??? WORKS!, counters speed etc. all arrays 0,1,2,3

** classify AC SR modes (did we attempt that there?)

in separate file

note that some modes deal with types of pulses out

* general //16/7/2021+

- AC has 64 modes so 64x64x64x64=16 million combinations
- speed CV to use in trigger mode (eg. length of overlap)
- divide into speedCV, trigger/pulse - so that makes 32 modes doubled up (what of SR effecting own/other speeds)

maybe with/without coggs as further option becomes 16 modes

NO freeze: freezing is not so interesting as just locks and gives continuous tone...

*[note for SEG - electronotes wheel thing is passing down of bits so this could also be probability based (based on CV)!]*

/// LOTS TO RESOLVE:

*questions to resolve: routing and feedback, coggs and/or micro-registers, in or out number of bits vs. length of register* 

/////

- *thinking also that coggs are a bit like small shift registers* -
  what could be done with these - rotating/looping SRs handle
  feedthrough of registers TODO! - also that this is more like overlap
  we had in mind - this seems to work

//////

- also odd patterns just realized unless we constrain lengths to odd numbers (which is even lengths) *TEST this - improves but maybe keep odd option//NO!
- reverted to older code 2/9 as if we constrain this favours 101010etc regular outcomes

- at high speeds timing of SR influences other timings

- kind of bug in all lfsr code (28/8/2021) as was passing on bitn
  which was LFSR feedback bit - still was interesting and keep for
  some modes or use that bitn for timing etc...

- also question as CSR is out but speed there determines speed of
  feedback so we should really have different paths:

as we have it is NSR->LSR->CSR->RSR->NSR

eg. NSR->LSR->CSR
            ->RSR->NSR

*NSR->LSR->CSR* // *could be default routing but then we need to see about use of SRlengthc but length is important if we re-circulate???*
*///->RSR->NSR*

NSR->LSR->CSR  ->NSR/or not
   ->RSR->CSR  ->NSR

others: NSR->CSR->LSR ->NSR
                ->RSR ->NSR

need to figure out how to select these from modes - see below

routing can be array of shiftregs

///what does it mean to have multiple routes -> route is only known to incoming SR which updates ghostSR which belongs to itself (so it can have all 4)

so routing table for each incoming SR would be 4 bits 1 1 1 1 N,L,C,R - excluding itself (try version which includes itself and doesn't shift)

*ghost shift registers (GSR) within GSRs - if itself is treated as a ghost revenanting/coming into itself*

//////

- do we always want same flow NSR->LSR->CSR->RSR->backtoNSR (at least
  do we always want feedback to NSR but then if not RSR would be
  redundant)... Q is how to signal different routing across independent modes:

if (routex==1) do this... // or pointers to entries - but we don;t really need pointers

*so we can list routings but how are these selected - by the top mode maybe?*

/////

- see also AC modes.org!
- parallel bits input modes - eg. all x ADC bits are thrown into top or other SR

- speed can go to zero! signal this in array somehows... and speeds should be slower at one end

timing from speed-cv, pulse in, top reg(but no bits in), pulse AND
speedcv (divide, multiply, expect), pulse AND/OR/XOR top (again no
bits), from ghost registers (which can also be themselves clocked by
top register and then we can use bits in or?), timing also from SR->DAC


- question of range of speed - from slow CV (Hz?) to KHz for sigma/delta

- how we prevent running down to zero for SR on length change (trap this?)

variable stopping bits/zeroes

- left hand path/ right hand path: tree of life, kenneth grant and overlays for ...?

- how we deal with overlaps? some test code already but need to think through, could connect to length?

- *use other SR bits to determine length of other SR* then free up length cv for something else? 

also pulse clock or cv advances number/x once eg for cycling ghost sr
or length of ghost sr, or we can have smaller degrees of that advance,
say 1/10 so is not such a big jump

- how clock pulses can be changed for speed - xor with other parts of
  SR, with returning bits (experiment with these timings), with speed bits????

- how to notate SR - black and white, left and right, that a ghost SR
  could decide how to route bits to left or right (but we use right
  for feedback but could still be interesting - general idea of
  routing bits eg ADC to one side, LFSR to other)

- *test with/withouts coggs running - how this works - seems to work so how to deal with this option in modes*

- for overlap: what comes out is only one bit (of course there could be pulses from earlier bits)
  try overlap with multiple << shift (same as or differing from overlap size)
  returning bits

- overlap also in sense that both overlap (XOR etc top and bottom overlapped SRs), what other kinds of overlap?

- how else to use our new multiple shift code?

- what we do with both clock and pulse in bits in CV mode and how we
  norm these bits (NSR clock is normed to TIM1 pwm which we will use
  speedCV/or DAC out as control for) - otherwise we have pulseouts normed to all other pulse/clock ins

[but none of these will advance so maybe sync all to this clock which frees up their own speedCVs]

- experimental modes for LSR, RSR and CSR only advance with cogg=0 from previous (maybe logic op with bit)???

* NSR, LSR, RSR, CSR

** NSR - top register - ADC in, CLKIN only, no pulse outs:

mode 0 is straight LFSR (or with ADC or)

- 1-LFSRnoise/2-ADC in/3-mix of LFSR and ADC //4-comparator? -to-LSR/or/RSR or both (do we decide that here *BUT* RSR is now designated as feedback)

[so that gives us 8 or so modes for each one - or 4 with new coggs setup]

+ comparator function for ADC ins (can we also use this for LFSR -
  ways that we can combine bits from that?) - comp only works when we
  have no speedCV/pulsein only - or we can have 

comp in as one bit only ADC in comped with CV?

- feedback of analogue output - eg. comparator using analogue out

- types of ADC (x bits, simple uncombined bits as in digfiltersim, equivalent bits), length in bits, delayed/stored bits

- pulse in/or speedCV and what CV does when pulse in/vice versa! (eg. number of bits, LFSR length if we have as extra)

- can also be clocked by CSR and/or ghosted noise SR 

- *look at AC SRs and see what can be adapted for ADC as incoming bits and cycling bit or RSR return bit (or combinations of these)*

- can be set of parallel SRs which feed into CSR, or just x bits from ADC go straight into CSR

- ADC with LFSR options: that we OR/XOR each incoming ADC bit with
  LFSR generated bit (from ghost LFSR), cases for parallel ADCs, that
  we weight incoming LFSR bits, that we use LFSR as DAC to
  add/subtract from ADC in, that we bulk XOR or just one bit per x
  incoming ADC bits, comparator of incoming DAC against LFSR/DAC

- number of bits in/out by CV or pulse counter(which wraps around)

- what to do if bits in/out is greater than length (options: put in anyways and lose top/bottom bits - shift if necessary // stop at length)

** LSR/RSR - regular shift register modes borrow from AC - CLKIN and PULSIN, 2 pulse outs/bits or flipflops: 

mode 0: feedthrough only - straight shift through with no return

LSR has entry from NSR and feeds into CSR
RSR has entry from CSR and feeds into NSR (so is the feedback register)

*but now we look into different paths!*

dark/light sides, left and right hand paths, mirrors (moon and sun), tree of life (Kenneth Grant - Nightside of Eden)

Question of how we work with entry of pulse ins: as togglers, pausers also, as extra
bits (but do we always have NSR entering in, maybe AND with extra bits
or other logic ops)

List leaky/decay possibilities...

- *look at AC SRs and see what can be adapted for NSR/CSR as incoming bits and cycling bit or pulse in bit (or combinations of these)*

- how we handle entry and overlap from NSR or CSR (logical ops, length of overlap)

- can also be clocked by bits from the NSR top register - but in this case we can't input bits from NSR as these will just be 1s!
 
- regular AC/SR modes

- just one way shift/delay - in one end, out the other (with/without bit degradation)

- looping SR with/without degradation

- leaking/decaying of bits, other logic feedbacks 

- micro-SRs in SRS - additional loops and feedbacks (that we can have loop in loop but also feedback in RSR to LSR and vice versa)

- regular and ghost LFSRs...

- latchings, holdings

- multiple flipflops of various descriptions for pulses out

- RSR is "clocking/logicopwithclocking" LSR and vice versa - need to test how this will work in all cases

** CSR - output register - CLKIN only, 2 pulse outs/bits or flipflops, DAC out: 

mode 0: basic DAC out

- type of DAC (eg. sigma/delta which is low pass of single stream of bits, x bit DAC)
- which of the bits are used for regular DAC: weighted, unweighted, spacings
- overlays, masks for DAC bits

- how we handle the pulseouts so this can also be extra/doubling up of modes

- *look at AC SRs and see what can be adapted for CSR as incoming bits and cycling bit (or combinations of these)*

- DAC outs from SR

- electronotes just has standard weighting DAC, uniform (bits x X) from consecutive taps, and sets of spaced taps -> wide spacings)

what else for 64 modes divided by speedcv/pulsin = 32 still (in pulsin we have bit length for DAC)

- number of bits in/out by CV or pulse counter(which wraps around)

- what to do if bits in/out is greater than length (options: put in anyways and lose top/bottom bits - shift if necessary // stop at length)

* notes... from elsewhere/sketches

- extra SR for random ops and timings maybe - that we can copy other SR to this also...

- what second bits out can be - different taps, divided/flip_flop, diff tap and flip_flop, logical ops with other bit!

- drooling shift register legged caterpillars

- how to do digital filtering - x spaced bits enter, passed down straight SR (with/without bit degradation, any other fancy stuff)
and X spaced bits are sent to DAC from CSR. return bits (how to select) OR/XOR from output (as bits or via DAC/ADC feedback options) to NSR/top register.

- maximum SR length as 32?
- ghost SRs
- parallel entry of data/ADC, sudden mirroring of SRs?

- leaky, rotting and/or infectuous logic/sticky logic/slow logic others?, UFO stuff 

what other kinds of logic gates there can be (based on CA, ternary etc)?

timing of a slow logic leak? 

trigger->latch and slow leak, disappearance of ones, bit by bit (how we could also display this as side project)

- NLC 8 bit cipher simulation: only makes sense for NSR and CSR where we have many bits in

... strobe is always high on 4094 so bits go into SR and are out, but
option for data on strobe which means all SR only change on 1, CV
combines different bits and primitive XOR for 2nd bit/mix with data in...

basically data goes to out when strobe is high, low -> just shifts 

so strobe is pulse in which can latch (incoming-ADC or noise) bits on to NSR or CSR
(outgoings) - and this is different to speedCv/pulse_speed as SR is still operating...

- how to work with overlaps? 

- overlap XOR LSR and RSR

- sieves - that LSR can be used as a sieve or bitmask for
  RSR/others... - how we deal with sudden events such as this, freeze,
  copy, ghost etc. (on a pulse in?)

- marking bits which always stay frozen - concept of sieves, masks,
  ghosts, revenants (eg. slow drift or decay of bits from one set to
  another, frozen, prevous or ghosted - so bit by bit they shift back,
  question of how long they take to go back?)

question of recording position and lifetime for decay - we erase on
death from the list but list handling is slow (finite sets of arrays
and garbage collect in one interrupt?) or we can just record and keep one bit max per SR

- TM encoding for SR_as_tape operations
 
  walk_ins - what else can be borrowed from language, concepts from UFO
  encounters?

- pulse triggers exchange between ghost and real, what pulses might
  mean - primitive programming language like brainfuck

//interpret set of bits as instruction on pulse in - say an x bit
sequence (but how to work with bits rather than bytes)

instructions shift left or right the opposite SR (can also use bits as
mask to do this - so we interpret one SR as shifting the other on each
bit in)

The Infinite Abacus: Brainfuck's "grand-parent" language

A version with explicit memory addressing rather without stack and a
conditional jump was introduced by Joachim Lambek in 1961 under the
name of the Infinite Abacus, consisting of an infinite number of
cells and two instructions:

    X+ (increment cell X)
    X- else jump T (decrement X if it is positive else jump to T)

- reverse direction of register (what this means?)

- glue one LFSR onto end/beginning of another

** parallel SRs

- feed data into top of parallel LFSRs, data read out from all bit outs: test for 12 bits, 12 parallel streams

** two headed SR



* in progress/ideas/todo

- how we pass through SR bits at different speeds - top one resets cycling/circling counter which wheels through SR
- is [0 bit our output?
- smoothing and other aspects from AC to implement
- re-test function pointers/how to make code more modular?


* TODO/plan

- basic structure of the 4 SR and straightforward tests eg. ADC in,
  pass down SR, DAC out

- proof of concept for digital filter and what ideas come from this

- all basic SR concepts implemented

- brainstorm and tests of all concepts

- basic modes layed out and tested - first speed CV then pulse driven and fancier...

