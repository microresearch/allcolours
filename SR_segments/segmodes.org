** sketch modes

By degrees the idea of cultivation subsided into that of merely
pastoral care. This slowly became merged in a sense of retirement â€”
this again in a consciousness of solitude.

A ourorack module for one bit landscape gardening.

serpent's head, caput draconis (rather than heavens\) - lunar node and link of geomantic figures with dots/dot matrix/bits... (see CCRU also)

A dragon with 5 heads!

** catalogue

catalogue CC in groups of 4:

BASIC:
00 - dactype
01 - prob invert
02 - prob route vs cycle
03 - route vs. [route^cycle]

10 - route type
11 - dacparam
12 - length
13 - depth as route

20 - select routebits_nodepth_typesz 
21 - select routebits_anystrobe_nodepth_typesz
22 - select routebits_depth_typesz
23 - depth for above

30 - select routebits_anystrobe_depth_notypesz
31 - as above. depth
32 - gapped funcbit. depth
33 - gapped funcbit fixed prob [ func [xor] func with cycle] 
//////////

speed/prob
40 - select speed func
41 - rungler
42 - dacspeed3
43 - 

50 - select prob function - vs cycle
51 - probzeroes - probdepth
52 - probcycle - probdepth
53 - cycleoxor - probdepth

60 - select prob functions with no depth vs cycle
61 - vs cyclexor
62 - select altprob
63 - back to full depth with alt

70 - gapped. sel function. dac as depth
71 - dac as length
72 - select alt function
73 - prob function dac depth

strobe
80 - simple fixed strobe with sel bitfunc and depth: routebits_nostrobe_depth_typesz >>7
81 - simple fixed strobe with sel bitfunc and depth: routebits_nostrobe_depth_notypesz >>8
82 - //routebits_nostrobe_nodepth_typesz >>8 and TYPE cv
83 - strobe prob cycle

90 - // select strobe speed function with no depth, bit mode
91 - routes with depth and gapped strobe speed 
92 - routes with depth and gapped strobe speed 
93 - select strobe speed function with depth and gap function // remove??? - try dual speed now

100 - speed func and bit mode selected. dacfrom depth
101 - dacfrom length
102 - strobexor fixed strobe
103 - strobxor var strobe speed

110 - sel prob depth/ sel func2 - these could be improved???
111 - prob mode cv1/2
112 - alt= routebits_nostrobe_nodepth -  bitfunc/prob depth
113 - alt above - bittdepth/prob depth

matrixp//globals in RR 
120 strobe//
121
122
123

130 strobe//
131
132
133

140 nostrobe//
141
142
143

150 nostrobe//
151
152
153

** TODO 

- check that all LL, CC etc have right parameters for each function set!
- look at all probabilities themselves

check code:

XXmain.c
XXcaput000.c 
XXresources.h
XXtables.h - can attend more to dacfrom etc...
XX#include "adcetc.h"
XXdoneagain-macros.h 

XX#include "geogen.h"

// check when we have all in place: esp. for right params, for probabilities

XX#include "geoCC.h
XX#include "geoNN.h"
XX#include "geoLL.h"
XX#include "geoRR.h"

XX#include "exp_port.h" 

arrays: 
XXgeomantic.h
XXnewbits.h

W/T/F: 15, 16, 17

// crash test in RR // full crash tests
// test and check all runglers, test all ouroboric again

** 15/3

- TEST/fix???jumpiness in some modes - speed issues - how to test (pulse code in long functions), how to fix?), dacs tested now so not that

TEST:
TEST- check runglers on RR side: [now R52X, 53X, R60X, R62X, 63X] 
so LL is: 41-43 50,51,52, 60

DONE:
TESTED- N22, N23 changed
TESTED- test zsuccbitsIppA on top inall - last one
TESTEDtest all DACs one by one... // 
FIXED:spdfracend: SR_geo_outer_C11, SR_geo_outer_C12, SR_geo_outer_C20, SR_geo_outer_C21, SR_geo_outer_C22, SR_geo_outer_C23, SR_geo_outer_C30, SR_geo_outer_C31, SR_geo_outer_C32, SR_geo_outer_C33
- check there is no accumulation (? adding say offset again and again)
- check dacfrom array and speedfrom...
- we checked globals and strobe functions - check first 32 now in CCXX, LLXX, NNXX, RRXX:

** 14/3

DONE:
- *TODO: retest mode slur across values with new mode no smoothing, how??? with crash mode - slur is now 256 // ???
- look again at CV smoothing -> where do we have this?  
CV: we smooth // trail without
CVL: no smooth
mode: no smooth

DONE- check all pulse outsXX, ghost clksXX, trigger ins
DONE: fixed
DONEC153: progressive slidings: 
// re-jig NN and RR, where we set types on each
NN-C10 
LL-L00 but also has C10 so we have a problem thereFIXED
CC-C10/C82(str)
RR-C10

** 13/3

DONE:
DONEC153 last tested = new last mode with sliding functions and offset speed
replaced with new probzero and tested//Q. of C11 in L side - out depth? what it could be?
// why is CV slow respond? reduced smoothings to 32
//- smd replace
// where do we place TYPES on each side? L00, C10-> in all others...
// DONEcheck ADCin attach in matrixp - if we don't have ADCin mode then is an issue??? unless we always do adc how???
 
** 12/3

DONE:
- question if we use CV, CVL if we shield these in arrays for matrixp DONE in some cases with remap
TEST strobes on NN
DONE/TEST C151- could have reduced array for matrixp in some functions
////
DONE- *check now RR strobe/route functions (w==3)
DONEless routes in on NN, and RR: looking at in NN, esp strobes to check and matrixp which is all route in// added reduced// matrixp is not on RR
DONE/check strobes for route ins on NN/RR
NO- first 4 strobes on NN/RR with no entry? but further changes
FIXED- do we have toggle as speed?
//what are strobe speed possibilities: 
uint32_t (*speedfromstrobe_depth[16]) - just in SR_geo_inner_str_function2 ok in C93
uint32_t (*speedfromstrobe_nodepth[16]) - well used
// merge these 2 if we dont care about depth
uint32_t (*speedfromstrobe_all[32]) -> used in matrixp

- do we have all func selects on strobes:

//what are all function possibilities for nostrobe??:

depth/types: 80, 
nodepth/types: 82
depth/notypes: 81
nodepth/notypes: 83

merges: 
routebits_nostrobe_typesz:
routebits_nostrobe_depth: used in probs
routebits_nostrobe_nodepth: in probs

- range on NN - q of c21_ and 

N: N0-3, C10,12,13,20, N20-23, C30-33, N40-N53, L50-51, C70-73 C80-153
NN: we miss C11, c21+, C40 C50 C60

C20, C22, 31, 32, 33 to look at!

C20: routebits_nodepth_typesz
C22: routebits_depth_typesz - but where to set depth?
C31: routebits_anystrobe_depth_notypesz - depth
C32: gapped/// depth
C33: xor func??? - replace with C23

so go for: C20, C22, C23, C31, C32 on NN DONE


** 10/11/3

DONE:
- DONEtry different route types eg. noshift=5<<9, zero=3<<9 ), - changed default route for NN and RR to 3<<9/zero
- or less route on RR also...
DONEswop back in c70+?
DONE*we need to set speedfunc in LL, NN, RR but where?//done as N40, and now as c40

** 9/3/2023

TODO: code checks above, play/tweak!

- DONElast reset on RR, LL and NN doesn't make so much sense - have as blank and add another matrixp mode!
DONE/TEST:
DONE- some trigers changed now changed trigger to bit but which is better for speeds // find out
- TESTEDresolve matrixp/layers. revert older code and test what we have in test2.c DONE/TEST
TESTED- C150 only- in matrixp do we have set on strobe function? TEST 
TESTED- remove strobe in all. is always running and we never use it as pulse in! TEST
- TESTED/ADDED some basic strobe functions: STR and TOG adding 


routebits_depth_typesz: 61->63<<6

depth_typez: Zbinrout_stripSTR, Zbinrout_stripTOG, Zbinroutfixed_prob1STR, Zbinroutfixed_prob1STR, NZbinroutfixed_prob1STR, NZbinroutfixed_prob1TOG
nodepth_typez: ZbinroutSTR, ZbinroutTOG
depth_notypez: zTMsimplebitsLSTR, zTMsimplebitsLTOG, zTMsimplebitsSTR, zTMsimplebitsTOG - no space to add
nodepth_notypes: ZjustcycleSTR, ZjustcycleTOG

** 8/3/2023

//- if we know inner only has fixed caller then fix it! done in NN

DONEif L50, L51, L52, L53 should be adapted for NN and then swop out c60range for c70range in NN? again memory Q*
DONE- check defaults // using an empty mode on each side -> where is?
DONE/tested- zcopyGSR_s unused and potential indie versions -> where?
- DONE/yes.keep in.do we need if ==w in succbits // test/where?
DONE: tested/potential adc in mode - adcin as depth and all abstract choices// maybe some more simpler ones esp on NN* -> c13?
DONE- test again all DACs
DONE- first mode on RR/test = prob1 route against cycle-keep as is
DONE- adding to inall for NN: zTMsimplebits and also prob of route in/cycle: Zbinroutfixed_prob1
DONE- - re-test inall and re-test mixes on NN and fixes/gaps for first NN modes
DONEalso abstract depth from dac on RR TODO - where to fill in -c13 in both cases!// both?*
DONE/TESTEDTODO changes to Rrunglers - to test and implement also in LL as some abstractbits need an in thus:
  gate[w].matrix[4]=(gate[dacfromopp[daccount][w]].dac); L60,61,62,63tested

** 7/3/2023

DONEwhere. also we need dac->depth early on // replace 3rd*DONE
DONE-test in full// test re-map mode knob - but will need memory

** 6/3/2023

DONE:
- fixed some use of gate[w].matrix[11] for gapped and probs
- fixed bug in binroutes in macros
- DONEsome alternative binroutes TODO and alts for those
- DONETEST:*new type of binroute. cycle own bits if there is no new bit
DONE-Now in SN for matrixp alts: SR_geo_inner_probdepthdepthSS: probdepth//notypesz

TESTED:
DONE//-TESTesp110-113across all sides FIXED/CHANGED XXDONEcheck how all esp, strobe inners handle specific use of depth in outer ????
DONE-NO-removed!TEST: thinking if abstracts should be in array of routebits_anystrobe_depth_notypeszX and even in routebits_nostrobe_depth_notypesz but sans strobes???*
DONE-TEST:Now in SN for matrixp alts: dep//SR_geo_inner_probdepthdepthSS: probdepth//notypesz // where?

SR_geo_inner_probdepthdepthSN - C150-152

  other:routebits_nodepth_typesz;
  strobe: routebits_nostrobe_depth_typesz;

prob for strobe is against: routebits_nostrobe_depth
prob cvspeed is against: routebits_depth_typesz

** 5/3/2023

DONE:
- recheck where cv hits on mode knobDONE
- DONEwhy RR effects 153: dacfrom for alt function with depth?
FIXED:fixed/checking shared/statics in geogen, not tested all but...
DONEtested seems fine: SR_geo_outer_Cplast 
DONEcheck runglers on LL and RR: 
LL: changed L52 and L53, and later ones so not route self and have route in...
RR: changed ordering but need to check these now: SR_geo_outer_R52XX, SR_geo_outer_R53, SR_geo_outer_R60, SR_geo_outer_R62, SR_geo_outer_R63
DONENN: check self routed runglers: 

** 3/3/2023

DONE:
DONE- test globals again - one by one
DONE- check new corrected route types: mode=C10
DONE- check inner and outer speed/sets within globals on right side...???clean up those again...
DONEaltfunc for R00 to test*

** 2/3/2023

sanityCHECKED:
- macros.h - fixed major mistake in many binroutes - to re-test
- main.c
- caput000 - fixed some duplicates in list of modes

DONE:
TESTED- new tails as [4]
- what gives self similar rthym on CC? -N20 and just loop round all..
- DONEtail now as 5! but where we make all changes): do and test!
- question if skipping C60+ in L and R sets up all of probs fine?
DONE///or have C60 instead of C70
- fixed double strobes in inall, abstracts when in use in strobe funcs
DONE- check each strobe line and pulse in - fixed code in out macro there and changes macros a bit for strobed and non-strobed options...
DONEtest basicsXX, //test with strobe speeds in all cases - strobe modes, matrix modes, fixed C80 for NN too
TESTED- does right side really reset - what could it miss? // resets on 
- DONE:testdo we need more abstract cases for w==3 in RR???, and no route in or
  prob of route in - where to place?: added in C60,61,62,63, 83, 110all TEST!


** 1/3/2023

///////
-DONElotsof fixes on NN runglers - so need to check all!
-DONEchanges in CC and 000 list bit need to test:Lfigure out of adc/abstract cv setting in NN and duplicated CC! - also Q of where in NN we set [3] type and cv[4]?*
-DONE check matrixp array maps - fixed [18] bug for altfuncs
-DONE- recheck all fixed speeds/funcs
-DONE- check all extents, all arraysDONE
-DONErecheck global arrays*
-DONE/tweak: shift all strobe funcs to end of arrays
-DONEcheck ^ for bits in CC-fixed matrixX bugs
-DONEcheck w==0 of substitute functions in CC
-DONEC93 is odd - to check... also if it works for NN//changed
-DONE- check we didn't leave any default values for CV/CVL in CC/NN etc

** 28/2

DONE/TESTED: last RR mode can be CVL set route as we can always set route to 0, so changed resetG and had to add ordercount=0 as was missing
+ checked all global modes, checked and fixed strobed bug there

DONE/TESTED: does RR miss abstracts in first 16 modes - how to find memory to place these (or as versions of NN ones if (w==3)...
//recbin is routebits_depth_typesz -> 38<<6 - tested and nice to keep

DONE/TESTED: binroutes to expand, altbinroutes to finish - see new notes // fixed limits in globals for now count 0-31
// *TESTEDwhere to test altbinroute? Zbinrouteforaltalt which is in: routebits_nodepth_typesz 2<<6 so CC wise is: C20 -> 

DONEremoved binroutebin macro and bugs there - 99.1% now

DONE/TESTED- check resets are working on all sides // DONEcheck reset code


** 27/2/2023 

final tweaks and tests+

- check/annotate how modes use CV(x) and CVL(y) - list of modes and how they repeat across sides...
- check gaps we filled across LL NN and RR for runglers - are they in the right places, are right things set, do they cover everything
- replace order of strobes in function arrays so they are last and re-check length of all arrays
- test static sides and then NN, LL, RR in turns...
- check probs make sense and gapped functions also
- above notes and below - what we didn't have a chance to use: // if we can fit it in


** 24/2/2023

moon node at 19.58!

// all filled in but we need to test and sort, esp for NN and with probs*

- we will hit limit of memory so have to double up - 99.5% now - where else we could save: recbin, shared and cut some functions

also we have now  all as speed18 18 octaves?

genericise: NN strobes: DONE 

NN probs (careful with params) DONE 

///

*probs to still work on with nodepth options in NN and additionals in CC - see below?*

/////// in progress

- define probs NN.

NN:
[probfunc] of [adc/etc] vs [gapped funcbit] [fixedroute] [depthroute] [fixedxor] [gappedxor] [depthxor] [zero]

[for gapped we need to have defined func already]
probfuncs we have: probf_anystrobe_nodepth[16], probf_anystrobe_depth[64], probf_anystrobe_depth_noin[32]

what do we have already?

SR_geo_inner_probadcentry: anystrobe_depth, fixedroute in N03
SR_geo_inner_probadcentryxor: anystrobe_depth, fixedroutexor in UNUSED


SR_geo_inner_probadcentryX: anystrobe_depth, funcbit in N40
SR_geo_inner_probadcentryxorX: anystrobe_depth, funcbitxor in UNUSED

*add depthroute and depthxor - as options*

probzero also: SR_geo_inner_adcprobzero added

*nod options added to above*

////

//SR_geo_inner_probadcburst: anystrobe_forNN_depth, fixedroute in SR_geo_outer_Nadcburst

+ probs of advance, and reset also use anystrobe_depth // also with nod option  - do we use these as are adc only? how?

DONEprobf_anystrobe_nodepth >>8 for all... burst? as we have those all - maybe for early mode


/////

- CC probs to add:

added SR_geo_inner_probdepthnodepth but we need outer to use it!
added SR_geo_inner_probdepthdepthSS ^^^^^

//////////////////////////////////
we need to assign:
[9] probf function
[10][11] probcv // nodeptth
[[3] for regular funcbit - was [17]str
[12] alt funcbit
[4][5] bits there - and not always have alt as dacfrom

in anystrobe we have:

[probfunc] of [gapped funcbit] vs []

probfuncs we have: probf_anystrobe_nodepth[16], probf_anystrobe_depth[64], probf_anystrobe_depth_noin[32]

vs []
routebits_anystrobe_notypesz 64 - unused but could have some of matrixp
routebits_depth_typezs 64
routebits_nodepth_typezs 64

probnodepth: probf_anystrobe_nodepth // routebits_nodepth_typesz - C62
probdepth: probf_anystrobe_depth // routebits_depth_typesz - C63
probdepthx: probf_anystrobe_depth_noin // routebits_depth_typesz - 72, 73
gappedfunction: probf_anystrobe_depth // routebits_depth_typesz - many

2 types TODO
probdepthdepthS: FOR matrixp: probf_anystrobe_depth // routebits_depth_typesz - matrixp

/////
in strobe we have: SR_geo_inner_str_probfunctionalt and SR_geo_inner_str_probfunction which present both option and which we use

SR_geo_inner_str_probfunctionX uses routebits_nostrobe_depth...

probf_nostrobe_depth!

we need to assign:
[9] probf function
[10][11] probcv
[17] str funcbit ([3] for regular funcbit)  
[12] alt funcbit
[4][5] bits there - and not always have alt as dacfrom

CC:

probfunc of [gapped funcbit] vs []

vs. nostrobe:
routebits_anystrobe_notypezs (for matrixp, maybe all probs)
routebits_depth_typezs 64
routebits_nodepth_typesz 64

strobe: 
routebits_nostrobe_nodepth 64
routebits_nostrobe_depth 32 
                                
///////////////
- CC: last matrixp funcs to test!

DONE: reverted >>6 in adcetc as wasnt hitting last mode

DONE: to test - NN matrixp (is just array I think and functions: both done) - question is which way prob should be 

DONEabstract runglers for LL and RR

DONEcheck extents of all probs, speeds]*

- depth==0 becomes binroute|bin in most cases
- TESTEDtail as cut off segment repeats/sides - check? new function SEVER to test: routebits_anystrobe_nodepth_notypesz 28<<7 C21 
- fixed big bug in modes assign

** 23/2/2023

TODO:

- NN entry of [adc/abstract] vs. fixed funcs/generic route funcs...

- how matrixp for NN differs? different matrix of course, what else?
- if we can fit problast and split strobe speed at end of CC into CC functions
- binroutes and speedroutes to check and expand, finish altroutes

- resolve prob options//started on this:

funcarray vs. funcarray
  //          fixed/defined

how many we have of funcarrays:

nostrobe:
merged one: routebits_anystrobe_notypezs (64, depth/no depth) (for matrixp, maybe all probs)
routebits_depth_typezs 64
routebits_nodepth_typesz 64

so we have 3x probs alts///

strobe: 2x alts
routebits_nostrobe_nodepth 64 - all types
routebits_nostrobe_depth 32 - all types

DONE:

- DONEtest each of CC //catalogue

Q:
testing questions: cycle has same frequency (esp in CC as we fix that to speed).... which becomes penetrating... but this is length!

for defaults what is prob funcbit=routebits_nostrobe_depth_typesz;
vs:
routebits_nostrobe_depth_typesz - so the same???

alts: 
routebits_nostrobe_nodepth 64 - all types
routebits_nostrobe_depth 32 - all types


- take cycle out of gapped function and put in:

    bitn=(routebits_depth_typesz[gate[w].matrixX[12]>>extent_routebits_depth_typesz])(gate[w].matrixX[5], gate[w].matrixX[4], w);

//rework NN - adc depth and abstract depth now share [8], how do we signal mix which is one [21]? - how we know we have that >x <y TRIAL

- adc etc. entry and strobe is now question // where are strobes in ADC in // abstracts? // we can ignore...

//to redraft so we just have selected in with abstracts and with dac in as first

reduce adc, adcx2=64 for dacin, dacin mix (where we set?) + selected abstracts=

zosc1bitsfast, sigmadelta, osceqf, osceqxf, zcountbits, zcountbitsI, zprobbits, zprobbitsxorstrobe, zlfsrbits, zllfsrbits, zflipbits, zosceqbitsIf, zosceqbitsIxf, zosc1bitsIf, zlfsrbitsI, zflipbitsI

- fixed first NN init arrays as we don't know extents of functions...
- check latest matrixp ops in test2.c - also fixedvarsDONE... layers seems to work but each leaves its residue
- TEST-strobe matrixp in CC (but speed doesnt affect attachment)


** 22/2/2023

what new arrays we have in newbits from merges:

routebits_anystrobe_notypesz

routebits_nostrobe_nodepth
routebits_nostrobe_depth
routebits_nostrobe_typesz

// better define/check probs so far - of generic func vs. nodepths/depths - options?*

TODO: 

- test all geoCC functions one by one
- finish and test matrixp ops - shift some modes to strobes as makes sense for speeds also there, but nice to have speed changes

DONE:

- 1010101 from SR sets matrixp to CV/CVL chosen fixedvar
- offsets in matrixp - see notes
- layers as sep functions we have but also can be in one - see notes // as bleed/no bleed/triggers bleed
- TESTednew scheme for globals with matrixX as new matrix in inners, and matrix become fixedvalue...DONE/TEST
test: abstractbits_nostrobez
DONEretests: routebits_anystrobe_depth_notypesz: C30 - should really test all bits again as part of CC
- more flexibility with lists of func arrays - how we can change these - array of these to assign, with extents and depths, join some together*
- as in merge/new groups of route functions // find space for extra functions and fill in gaps
- DONEe need to check use of depth in all function arrays, see about combining or simplifying arrays*
- DONE and fixed:test DACs and redo strobe there perhaps...

** 21/2/2023

- define special fixed functions or areas for each side: eg. new split speeds, xor speeds, runglers, what else?
- where we can put Zlast (and cycle) into route arrays!?

MATRIXP: 
//NO but can mask it!- we can have distorting matrices - ie. remap copy of matrixp - mask or move it with triggers and SR holes

TODO:

// globals, finalise runglers and fixed functions on each side...

// extras to fit in/maybe remove others - means testings:*

split speeds, speedXORs, prob of last

Zbinroutsplit, Zcyclesplit, Zbinroutsplitprob, Zbinroutsplitprob1, Zbinroutsplitprob2, Zbinroutsplitxor, Zbinroutsplitxor1//all except cycle with types - depth/no strobe

// new outer in CC: SR_geo_outer_Cplast last one held // can be like indie speed

Zlast, zjustcycle/// - should be option for routes//entry into probs, same as basic cycle which we should add

TODO:
- PROGRESSfix matrixp - latest notes... TESTINGadded reset which will attach changing, possibility of layers

//other notes to explore: 
- copy in layers of fixed arrays of CV and CVL etc - bump on through lists of fixed arrays

[- too few...reduced translations say 3 bits 0-7 eg. layers of speed, bits, probs  eg. nostrobe: 0,1,2 /speed/ 3,4,5 bits 6len, 9,10,11,12/prob 13,14dactype 16 routetype, // others only used in NN, etc]

- route arrays - merge depth and nodepth for final matrixp as we don;t distinguish? or have pre-selected special arrays*



////////////////////////////////////////////////////////////////////////////////////////////////

DONES:

DONE: - new split speed - so speed of cycling of GSR/whatever does not have to be the same as SR speed - Zbinroutsplit, Zcyclesplit, Zbinroutsplitprob, Zbinroutsplitprob1, Zbinroutsplitprob2//all except cycle with types - 

but this is same as prob (with speed) of route in vs. same/last value - not really or is it TRY

- how can we do a function which just stores last value... we store bitn in outv macro! gate[w].lastest -> Zlast// but where we put that function

DONE TODO:or just make inner with that as one option of prob

DONE:dual speed for strobes and test this!

DONE:Revise all spdfracs/spdvienna in probfs as a) these need seperate arrays/values b) they need to toggle on success/1rewrite as P_
spdfracX, spdfrac1X, spdfrac3X, spdfrac4X, spdfrac5X, spdfracdac3X, strobespdfracX, spdviennaX TODO:test all of these: 5->10, 24, 28

- DONEfixes to strobe again - =0 inside speed function and re-test with ??? with a strobe in NN???
- DONE - is just as becomes average...why XOR tail fails? tail route in 0
- doesnt seem so...why/does fast interrupt fail?


** 20/2/2023

- can we fit xorspeeds into CC? where? can lose one prob and throw in, bump C43 to C50*

all about transition from fixed funcs to... generic funcs...


how in matrixp we can say set matrixp[x] to CVL and then be able to set others to DAC etc... and go back and forth*
// tested in test.c if we stick with oldgap then we just change what we have and as we change next last defaults to oldest value
// only way to set is outside of oldgaps -- or we can have layers of oldgaps...*

/////


TODO:

- physical tests all CC modes one by one... and catalogue/check sanity of each
- fill in gaps in NN, LL and RR

//// DONES:

DONEin matrixp we need to change from probcycles everywhere to...*

DONE/testing- do we have route X vs route Y as prob/burst eg. single route 2 in vs double eg. 6 in
as prob funcn of  binroute vs altroute[count] // sans binary Zbinrouteforalt - DONEneed to finish altroutes...*

pull altroute into arrays

- DONEcan add/test new speeds/bursts (also for xorspeeds for NN, LL and RR) ???

- DONEtest tails with strobes - NN strobe // fixed tail

- DONEcan add prob of adc entry array for NN (below): probf_anystrobe_forNN_depth[16]

- DONEcheck adc vs dac out what is cleanest - do we have 4 bits in every 4...YES!

DAC_ 14 is good! for slower waveforms - make default // contemplate reduce adc/dac modes and sort for best...

- DONE/TO TEST*fix strobed: remove GSHIFT =0 and set 0 or 1 in ALL speeds* //but more complex for those which are used on probs - so we need 2x speed and prob func REDO with speed versions mark as S_: zsprobbits, cipherforspeed - !has strobe!
how to test?

which mode can we test speeds on? C43 (not strobes)DONE
90 for strobes

WAS ALREADY DONE:fixing dac strobes - need array not there so can pre-fix... 

//////////////////

how we start to think of modes - in groups eg. 1types/basics // 2route modes // 3speed/rungler // 4prob // 5strobe speed // 6matrixp/globals

as sounding distinct?

** 18/2/2023

///

- DONEremoved fake for dac
- DONEfixed giant strobed bug

///

- quick lower test - issues with globals 

///

CHEckedadc reset funcs we didn't touch???? now in NN*

new funcs: zosc1bitsslow, zosc1bitsIslow //strobe ones for prob, + put counts in probs ORGANISE...// added all

-*DONEdo we have probs which are more of a sudden switch rather than gradual probbits eg. toggle for depth length?

added strobe ones to probf_anystrobe_depth[64] <<6: 29+ countbits also...  test in NN11 - could also be as speeds?

what else can use switches - any kind of prob with a static condition...

to switch train in! --- + possible individual prob array for NN: probf_anystrobe_forNN_depth[16]*

- DONE. can run out but ok re-test loop of inprobadc: N11

TODO: physical tests all CC modes one by one... and catalogue/check sanity of each

** 17/2/2023

-DONE fix CV and CVL - smoothings checked again/reduced

///[how we test - was prob of entry again // where? in L43 zinvprobbits]

- DONE-to test simplify runglers for NN.. can have more in RR(see notes) - speeddac3 is most important, routesel not important to select here, 

** 16/2/2023

DONE-retest all probfs ... DONE/TODO: for comparisons 8 bits depth is better so no glitch*

if we get sole speed from the one we route into we have issues???*

- catalogue and finish/test runglers for NN: we need simpler fixed runglers*

///

- TESTED-DONE- more with tails as we erased some - eg. NN can be fake strobe 8 with tail TEST strobe modes NN*

- DONELLtest new runglers as we implement them: LL in progress

TESTEDtesting allof: routebits_nodepth_typesz, 

** 15/2/2023

default: routebits_nodepth_typesz;

TODO: first do sanity check, then test all CC and catalogue below, fill in LL and NN runglers and test these*

- *IN PROCESS: unreverse logspeedsDONE and invert all CV//DONE and CVL/DONE but then we need to go through and correct all functions for this - lenDONE
- *DONEthus fix inv functions in geogen... - test all!

/////////////

- DONEfilling in matrixp ops

// dacspeed3 or 4 as preferable -> 3x pref but trial with new logspeed up // 3x 4x too with speedfrom, also c41 speed type selection*

TOO risky: how we could pull matrix onto orderings but not so easy as orderings are fixed or we keep one open

DONE/TODO: test longer order arrays to downsample

** 14/2/2023

DONEtake care of routetype now in matrices: gate[w].routetype=gate[w].matrix[16]>>9;

lots of tests below

// MAP: TEST!do we need to hits full matrixp as some are only relevant for say strobes - but how to filter?

eg. we don;t need adc etc in all except adc mode - some kind of mapping
eg for CC strobe we need: 3,4,5,6,9,10,11,12,13,14,15,16,17 try maparray...uint32_t maparrayCC[16]={3, 4, 5, 6, 9, 10, 11, 12, 13, 14, 15, 16, 17, 3, 4, 5};

also sort better strobe and nonstrobe order in functions*

- DONE_TESTadd abstract index as [17] was taken... -> [20] maybe re-test

- DONE_TESTED_can maybe add more orderings to orderings array!

- DONE_TESTEDtry different shifter for DAC_ and maybe add this as modes 

matrixp:
- TEST gaps with CVL pre-attach in matrixp ops
- DONEbut...also copy can be if not_changed then copy fixed:     gate[wh].matrixp[oldgap[wh]]=&gate[wh].matrix[oldgap[wh]];// fixed one
- how we can layer attachments the detach/gap according to overlays?
- DONE/TESTdon't set to null but fill default with fixed:     gate[wh].matrixp[x]=&gate[wh].matrix[x]

strobe matrixp ops 
cvspeed matrixp ops

reset at endx
grids/SR attachings

** 13/2/2023

- DONE-to test all //globalls without depth (list) will need gapped inner fuction with prob...TODO* fixed inners - to re/test*

TODO:

- DONEall TO TESTglobals RR - which ones are fixed if not all... or groups say of bumpers...

- starting on matrixp ops:

--> DONEhow do we reset matrix/matrixp to something sensible if say is all attached, by filling gaps - settle down//reset at end*
ignore: problem is that matrixp is null to begin with, do we need to set every op as matrixp in outers...

eg for speed gate[wh].matrixp[0]=&gate[wh].matrix[0];

fixed/dac/crash in 122/setvar...: strobe is routebits_nostrobe_depth_typesz//extent 7 =32; speed is speedfromstrobe_nodepth[gate[w].matrix[15]>>8]
// crash in routebits, speed as no type, in dac param?

- start to fill all gaps below

+NN: adc/abstracts, some cycles, NN needs all possible inners with adc in!
+RR: abstracts from above
+NN/RR/LL: new runglers - rungle with no route in/route in...
+fixed route functions/abstract/adc ins for NN and RR - tehse are simpler...

- DONE/TESTEDnew Triadex mode - depth//no types - TESTED - can also be solo function for RR, LL, NN maybe and any others... in strobe with CV and co...

** 12/2/2023

ignore- what was logic again of GSHIFT before shifting??? and why did we have odd behaviour with full speed of N and zbinroutebits_noshift in prob of entry or cycle when we use Gshift_/share and not with shift_???
// is more about them being the same BITS!

DONEif/which globals on RR should be inside speed eg. binary should be - new inner for these else just set in outer [19] is now CV for globallls

routebits_nodepth_typesz is default with mode 0= Zbinrout(:

we changed all noshifts to use shift_ and not Gshare_!!

done new tests below, 

DONEtest tails (how?)

routebits_anystrobe_nodepth_notypesz[32]:= 4<<7 C21

we now changed to spdfrom for fake clks on strobe modes - see if works all together? so far ok*

- changed now RETEST question of probs is that altfunc is still from same array! and we have 4x different arrays...

for no_strobe fix against either/or:

//- XXroutebits_depth_typesz[32]
// XXroutebits_nodepth_typesz <<6 [64] = C20

now done only with bitn=(routebits_nodepth_typesz[gate[w].matrix[12]>>6])(gate[w].matrix[5], gate[w].matrix[4], w); // swopped - fix now so is different

list prob options:

SR_geo_inner_probdepth
SR_geo_inner_probdepthx - probs with NOIN!

and for strobe:

//routebits_nostrobe_depth_typesz >>7
//routebits_nostrobe_depth_notypesz >>8

- ideally both - we have 2 options there

** 11/2/2023

- DONEfilling in dacfroms for depth and length - these could also be in strobesDONE

** 10/2/2023

- DONE/fixedhow to test that we do resetc/all - print on reset

- test all functions with depth*- *re-test all routefuncs // all speedfuncs // all probfunctions (well still to test these). and check logic by hand

//those with depth are checked with depth // all inc no depth to test: 

*TESTED:*
routes: 

- XXroutebits_depth_typesz[32]
- XXroutebits_nodepth_typesz <<6 [64] = C20

- XXroutebits_anystrobe_nodepth_notypesz <<7 = C21
- XXroutebits_anystrobe_depth_notypesz <<8 =C30 // patterns can have problems on start

all strobes:
- XXroutebits_nostrobe_depth_typesz
- XXroutebits_nostrobe_depth_notypesz
- XXroutebits_nostrobe_nodepth_typesz
- XXroutebits_nostrobe_nodepth_notypesz

speeds:

- XXspeedfromstrobe_depth and re-check all strobe speeds:

XXspeedfromstrobe_nodepth 16 <<8 C90
XXspeedfromstrobe_depth 16 <<8 C93

probs: 

- XXprobf_anystrobe_depth
- XXprobf_anystrobe_nodepth <<8 C60
- XXprobf_nostrobe_depth  matches above ,,,,

** 9/2/2023

// TODO: fill in gaps broadly*

- memory questions: generalise inners more... we might have to add if for adc in

start to draft matrixp - 16 functions with generic inner///  how these might look:*

// question as copy is only operation which makes sense so we need to mark CHANGED for copy.... and gaps... need general concept of matrixp ops!!*

- attach DAC with CVL - single and hold (how? - so we don't just sweep across attaching, lastplace and place)
- attach with pulse... 

layers of functions:
speeds
bits
probs


rungler1: osc1 or abstract with speed or depth from speedfrom dac
rungler2: route in, clkfrom speedfrom SR

- TESTED/fixed prob tryout // test diverse prob functions... probf_anystrobe_depth[64]: SR_geo_outer_probfunc TESTED

// catalogue first CC modes - no gaps:
00 - dactype
01 - prob invert
02 - prob route vs cycle
03 - route vs. [route^cycle]

10 - route type
11 - dacparam
12 - length
13 - depth as route

20 - select routebits_nodepth_typesz 
21 - select routebits_anystrobe_nodepth_typesz
22 - select routebits_depth_typesz
23 - depth for above

30 - select routebits_anystrobe_depth_notypesz
31 - as above. depth
32 - gapped funcbit. depth
33 - gapped funcbit fixed prob [ func [xor] func with cycle] 

// revisit basics:

WIARD: noise/comp selects new input or loop back/inverted loop back (jumper) //options relating to new input: adc/dac, mix, routein - how to select these options
EN: LFSR SR bit is loaded/not loaded onto recycling SR. loading can be random (based on LFSR and set of probability switches)
TM: invert cycling bit // could also be with route in

TRIADEX: use of different parity switches - do we still have this?
apparently SN21 and SN22 - can maybe go further again with this - 4
bits go into parity from say all SR with diff functions = 4x 32 bits = 4 selectors of 128 bits or we use CV CVL (depth and IN) so is just 2!

// route vs cycle
// route vs inv cycle
// cycle vs inv cycle / TM for NN maybe as fixed data source
// route^[cycle vs inv cycle]

we have in basic first modes:
- prob of inv route in
- route vs cycle
- route vs. [route^cycle]


** 8/2/2023

layers of functions:
speed
bit
prob

- all tests below
- first modes fill in new NN: DONEtest N02, N03 etc,,,

LL follows CC apart from first one and later rungler, RR follows more or less NN but without ADC, some of CC (eg. route vs. cycle)*

- DONE/tested: seperate matrix for abstract ops - replace what was route with 18 and maybe DONE:take care of all theroute and globflags already
// but we also need abstract CV on 19! to addDONE - test all

- took care of globflags but we will need to re-test all - esp binroutorg // all speeds, routes etc.. logic check all functions one by one eg. depth=depth>>8 was missed/other shifts, all extents catalogued*

- added new begin array as some abstracts are poor starters
- mix of abstract and adc doesn't work at all so leave out

DONEclean up all succbits: why does succbits have: gate[x].Gshift_[0] and not share or gate[x].Gshift_[w] ???* - replace with [w]

** 7/2/2023

TODO: tests from below:

- DONEtest gapped strobe function. SR_geo_inner_str_function* TEST! -> SR_geo_outer_strobegap
- DONEtest spdfracdac3 and new version// spdfracdac3/4* > SR_geo_outer_dacspeed
- DONEtest spdvienna2, 3, 4 in new speeds - where are they?
- DONEzcountbitsI added TEST
- DONEtest strobe (no depth) xor with speedmodes (just strobe or strobe_modes, spdfrac or speedmodes) - but how we select each... fixed sel *SR_geo_outer_strobexor

/// possible other xor/or*: 
strobe_nodepth [xor/or] speed_depth
strobe_depth [xor/or] speed_nodepth

- DONETESTspeedmodes can have dac as depth (or cv plus dac etc) - speedfromnostrobe_noIN // calc is in outer but new func in inner... *SR_geo_outer_dacasdepthspeed

/////

- seperate gapped functions for strobe/no strobe speeds (we only gap speed as index): so now we have: str_funcbit etc // done in init draft gapped strobe function

- DONE/TESTed-pull out: spdfracdac3 as special speed case with CV and CVL - retest and rework for +-

4x4 for next 16:

- basic probs - last 4 we pulled out / gapped speed?
- prob functions  / gapped speed?
- runglers/speed eg. spdfracdac3
- speeds 

strobes: 
- basics with just trigger // CV and CVL
- probs and strobe?
- strobe functions
- strobe xor/or speeds at end


** 6/2/2023

- draft strobe (no depth) xor with speedmodes (just strobe or strobe_modes, spdfrac or speedmodes)

- which speedmodes can have dac as depth (or cv plus dac etc) - *speedfromnostrobe_noIN

in=gate[speedfrom[spdcount][w]].dac
if (in==0) tmp=CVL[w];  else tmp=CVL[w]%in;
gate[w].matrix[1]=tmp;

// or other way round...

///

list modifiers for speedfromnostrobe_noIN with in as speedfrom dac: 

1.   if (in==0) tmp=depth;  else tmp=depth%in;


2.   tmp=(in>>1)+(depth>>1);
  if (tmp>4095) tmp=4095;

3.   tmp=(depth)-2048; // adapted for full bits
  tmp+=in;  
  if (tmp<0) tmp=0;
  else if (tmp>4095) tmp=4095;

4,  tmp=in+depth;
  tmp=tmp&4095;

////

- draft prob tryout // test diverse prob functions...

- DONEdifferent versions spdvienna todo - done to test spdvienna2, 3, 4 in new speeds*

- home/ cleaning up newbits: 

- TESTed: changed order and some new ones first 16 of geoCC

- draft RR, LL (as CC), NN first 16...

- re-acquaint prob functions and strobe speed functions: cleaning up here and note succbits all options:

DONE: list succbits and also place in newbits if relevant: no types - added to abstracts *TEST

// succ. no depth: zsuccbits, zsuccbitsI, zsuccbits_noshiftnod, zsuccbitsI_noshiftnod
// succ. depth: zsuccbitspp, zsuccbitsIpp, zsuccbits_noshift, zsuccbitsI_noshift, zsuccbits_noshiftd, zsuccbitsI_noshiftd

prob also

DONE: zcountbitsI added *TESTed

for speeds with strobe - add xor with speed = where was if at all? and how we can do this without replicating or just as inner?*

//DONEneed tests of probfunctionsDONE

** 3/2/2023

- line up runglers - 2x functions or more = 

1. Z: route in one SR/X/ clock from other SR/Y. SR_geo_outer_rung0 in geoCC now
2. X/Y: osc or abstract function speedfrom Z.
3. X/Y: route in XOR osc or abstract function speedfrom Z.

so for example if C is Z - routes in default from L, speedfrom R // depends where other 2 are...

-  new runglers, check rungler routing (see notebook) and options - 

DONEclkfrom other/incoming dataTESTED: *zbinrouteSRbits is rungler depth->route->bits* so can be used on left side as speedfrom: SR_geo_outer_rung0 (inCC now)...

** 2/2/2023

DONE: would be nice to gap funcbit but then we don;t know what is done with depth - now we have depth array in gate[w] trial this... // draft function*//tested
if (!depth_routebits_nostrobe_notypesz[gate[w].matrix[3]>>7]): SR_geo_outer_gappedfunc

// xxfor some functions we need IN as gate[dacfromopp[daccount][w]].dac*

- DONE:check new functions against depth

- TODO in progress: mode by mode of old CC, test each new function arrays, and start to make new draft CC with clearer options/less gaps, no routes

- check rungler logic and test with new abstracts below

- when we decide we eliminate theroute and globflag...

- // DONE:XXXX also we need to use routebits_anystrobe_notypesz - and use this somewhere

// new notebook notes 2/2:

- DONE:check knob slur with crash say on C20!

- DONEcheck new abstract list... one by one - and new abstract list for runglers now...

- in progress: maybe divide depth and no depth as mix is confusing for use of depth* 

- what are abstracts with no depth (and can we use them?): justcycle, flipflop what else?

** 1/2/2023

- DONETESTING - new smooth mode scheme on [2]CC -> and faster slur of modes... trialDONE

////////////////////////////////

- Notes and new tests from notebook on tests with first 32 modes: 

- re-test each mode individually and do speed tests...DONE 
- how fast is slur - how to measure that/ we have code there... test in main // we reduced slur speed by half...
- check all for logic issues?

//simplify all...

- first 16 modes are less modular and more fixed. less/no gaps. simple strobe modes todo

- replace theroute with global route? and then we have depth question // few depth as route functions... but not a gapped theroute for all...// no globflag

for moment keep theroute as fixed and see how goes // ignore bumpbits for now -> new alt versions

- prob is too complex and shouldn't have shared CVs - refine to X vs Y - what functions make sense eg. eg. prob of global route vs. depth route

- new function arrays for route/nodepth and extended abstracts (with no direct route in) - but bumpbits change theroute/fixed as alt ones now

// routebits_nodepth_typesz, routebits_depth_typesz


- DONEcheck for repeats: eg. some NZbinroutfixed_prob1x are the same as wiard bits - prob of route/route inv vs cycle/cycle inv...

- what is repeating? removed all wiard as we have as probs!DONE!

NZzwiardbits: type LFSR__ route/cycle
NZzwiardinvbits: type         route/inv_cycle

zwiardbits: in route/cycle no type
zwiardinvbits: inv // keep now with no shift

zwiardbitsI: in no type same as above?
zwiardbits"I: ^ cycle

Zzwiardinvbits: in, type, inv cycle
zzwiardbits2I: in, type ^ cycle

Nzzwiardbits2I: lfsr, type, ^ cycle

zzwiardinvbitsI: in, type, invcycle
zzwiardbitsI: in, type, cycle

Zzwiardbits: in type, cycle

zwiardinvbitsI: in, no type, inv

///

Zbinroutfixed_prob1: in, type, cycle
NZbinroutfixed_prob1: lfsr, type, route

Zbinroutfixed_prob2: in, type, simple INV of bit 
NZbinroutfixed_prob2: LFSR

Zbinroutfixed_prob3: in, type, inv cycle
NZbinroutfixed_prob3: lfsr

Zbinroutfixed_prob4: in, type, ^cycle
NZbinroutfixed_prob4: lfsr

Zbinroutfixed_prob5: in, type, binroute
NZbinroutfixed_prob5: lfsr

** 31/1/2023

//NO?did it crash? how to crash test - with rand on modes but doesn't crash and is slow...*

we need simpler modes and changes of functions/style across sides*

Note: so far LL, CC and RR are all same apart from first reset... upto 16

NN is always different...

- working on rungler modes - what side these make most sense for (LL as route in, CC also rungler with ADC in - q of route in there or not)...

- FIXEDstarting on prob modes and question is now they both have same route... we can maybe set and reset this in prob - trial

- DONEtest each of probfs we use individually to see if works...DONE for ones we use so far

** 30/1/2023

notebook: DONEnew abstract countup function

- strobe function from below: prob (depth vs. in/LFSR) of route X(global/theroute) vs route Y(another depth) - so we need that function*

older:


/* summarise: // = translate-> LR
00: dactype // length
01: routetype and globalroute
02: prob1 route vs cycle
03: prob4 xor

10: change route
11: change routetype again for new route->UNSURE
12: dacparam // ??
13: length // ??

20: change route function
21: set depth/route
22: prob1 of new set
23: probxor

30: dac-length. depth-cv
31: dac-dacpar. depth-cv // ??
32: dac-depth. dacpar-cv // ??
33: dac-depth. length-cv

 */


** 28/1/2023

DONE/fixed-TODO: retest all speed functions*

-DONE to 18 octaves on RR side: question if we slow down speed of geoRR so is half or quarter - 17, 18 octaves, to test. as seems a bit too fast*

//testing but we need different LOWEST!

DONE:still to fix all default adc so we have output

** 27/1/2023

- NONcheck: do we still use in flag:   if (gate[w].in) gate[w].matrix[5]=gate[dacfrom[daccount][w]].dac;   else gate[w].matrix[5]=LFSR__[w];*

- Q: to invert entry into arrays eg. dac,adctype, all functions as 0 is far right so confusing//in outer or inners TODO // some are inverted*

- DONE:drafting 16 geoC modes/ drafted and testing?

notes:

attend to: geoC - SR_geo_inner_probofdacoutC- retest this, SR_geo_inner_prob3C, 

new prob below...26/1

** 26/1/2023

- do we have prob of route x vs route y* // depth for prob
  so... leaves what? for strobe modes only with prob on cv and cvl as
  x vs. theroute TODO* how that works? do as special inner and depth

- other bit collections like: routebitsnostrobedepthprob ???check out - what used for and update -> we use these against LFSR anyways...//ignore or work through*

- do prob functions move on/have types... maybe make exceptions...
- prob re-workings/rework new functions for prob without depth/lfsr

- DONEdivide up strobe+only/nostrobe functions
DONE:fix NZ and Z - as both the same NZ can now be with LFSR

- compile characters/hints for each side:
NN: not so much about speeds. abstract/adc prob of entry/switch
RR: routes, global, abstracts
LL: routes as primary, speeds
CC: dac, prob, routes, speeds as primary

** 25/1/2023

- added print debug code in geoCC to make it easier to debug with openocd... and gdb // see tech_diary too...

- testing routebits_typesz from newbits but hard to cut down, maybe just farm out strobe ones to split: // routebits/juststrobe/types

TODO:

PROB WORK:
clean up probs. also some non-depth probs now have depth*
checking probs and now we have issue as some are against LFSR__ which we filled in some route functions which had no depth (also some already use LFSR)...*
if we have probs using depth is nice to have nodepth/route only functions // or if depth say for LFSR is fixed does that work? test//*
also if we use CV for depth for prob, then we have free CVL depth for functions*

/// so we need new bits sections for probs...*

///- DONEsort bit functions and narrow down
- check probs and depth questions there: see above! - when we reach prob sections
- draft 16 modes all sides and test
///- DONE: 16v pp tests with basic probs -> check what we have on board here? we have those changes (22/66.5) for 16v/16 octaves...

DONE:how can we check 1voct approx...CHECKED for new 16 opts=/flipflip 

DONE//TODO:and also check prob-kind of OK! - need to make comparison...

- check speeds with no in??? // speednoin?

Notebook notes:

for geoNN:
- do we have abstract modes instead of adc in also? could also have prob of adc or abstract. what is default abstract? what is default adc type, adc parameter?
- no route in, just ADC or abstract types
- prob of adc vs. route // adc vs. adc^route - negotiate all probs

** 24/1/2023

//question of SMD changes///CV range (-8 to +8 16 octaves on hold) of SPEED/CV[w] as that CV is also used by prob. in strobe modes...
//other alternative would be to -5 +5 and leave v/oct aside -> 100k/100k and 33k divider in that case... do for all???

*We can also imagine slippage/attachment of settings in global modes eg. we have array of count daccount speeedcnt etc and we attach as in matrixp to these*

TODO: 

- working on new function arrays - how to cut down number of functions

- new function arrays in newbits, draft first 16 modes for each side and test these...

DONE:maybe pull uses of depth into all non-depth so we don't need: if (nodepth==1)/// note: we still need fix no depths in case of probs...*

FOR GLOBAL rmodes:::
- 16 last global modes*
- global modes all hold last function (eg. it could be abstract function)*


- DONE:reverted to 16 octaves/TO_TEST

** 20/1/2023

// TODO: DONEuse globflag where needed in geogen/exp_port - also where do we set globflag - in globals, set off/xon event*

// DONE/: but would be nice to locally shift on theroute - add these./change to: zbinroutmybumpSSXXX, zbinroutmybumpbitXXX, zbinroutmybumpbittXXX, zbinroutmycvD

// DONEsee above: what do we do with the few no_depth ones we have? convert to internal prob??? just use as length

TODO - draft function list and inner/outers - say for routes with types

- do NOT set route every time - leave as gap or only set when needed->

- find functions which have route AND depth together: 

lots of probs did have, and we can also set using globflagTODO - if we have depth and route then just gap route...

how to write that:

just set a flag if we need to set route at all... (if depth is not used)? 1 means depth is used... // but what of no depth ones...//FIX these...

if (funcr[gate[w].matrix[3]>>7]&0x01) just do depth   // Depth
else do route // route only

thus only flag needed is depth

- start new bits functions//divide up on strobes: allbits, abstract, route, with types, without types

- start CC, LL etc from scratch... copy in...

** 19/1/2023

TODO:

- DONEfinish testing testexp lot

- DONEadd resets for route and type to generic macro resets (if not already there)DONE

- DONEpull typeDONE and routesDONE -> test with setting in geoC

// we still need to resolve DEPTH and CV questions

so what functions now have no depth/AND/no route?

- abstract bits:

zosc1bitsD, sigmadeltaD, cipherDS, osceqD, zprobbitsD,
zprobbitsxorstrobeDS, zprobbitsxortoggleDS, zonebitsDS, zlfsrbitsD,
zllfsrbitsXXX, zflipbitsD, zosceqbitsID, zosc1bitsID, zonebitsIDS, zlfsrbitsID,
zflipbitsID, zpattern4bitsD, zpattern8bitsD, zpattern4bitsID,
zpattern8bitsID, flipflopD, flipflopID, ztogglebitsshDS, ztogglebitsDS // 24

FIXED:NO depth in above: zllfsrbits, ztogglebitsshS, ztogglebitsS // can be probbed// well not the lfsr

- routebits:

// with types

mark route, depth, and strobe: R, D, S, nada XXX(removed)

ZbinroutR, ZbinroutorD, ZzbinrouteINVbitsR, ZzbinroutebitscycleR,
zbinroutebitscyclestrIRS, ZflipflopandrouteR, ZpSRsigmaR, ZviennabitsD,
ZzsuccbitsppD, ZzsuccbitsIppD, ZzwiardbitsD, ZzwiardinvbitsD,
Zbinroutfixed_prob1D, Zbinroutfixed_prob2D, Zbinroutfixed_prob3D,
Zbinroutfixed_prob4D, Zbinroutfixed_prob5D, Zbinrout_probXYD,
Zbinrout_probXY1D, NZbinrout_probXYD, NZbinrout_probXY1D,
NZbinroutfixed_prob1D, NZbinroutfixed_prob2D, NZbinroutfixed_prob3D,
NZbinroutfixed_prob4D, NZzwiardbitsD, NZzwiardinvbitsD, binroutesel3R, NZzbinrouteINVbitsR,
NZzbinroutebitscycleR, NZflipflopandrouteR, zbinroutmycvD,
zbinroutorgapR, zzwiardbits2ID,
zzwiardbitsID, zzwiardinvbitsID, 
zzsingleroutebitsD, zbinroutfixed_prob1R/D, zbinroutfixed_prob1LD // 39

// without types

zsuccbitsprobD, zbinrouteORbitsR, zbinrouteANDbitsR, zbinrouteSRbitsR,
zbinroutebitsI_noshiftR, zbinroutebitscycleI_noshiftR, zSRNbitsD, zSRLbitsD, zSRCbitsD, zSRRbitsD,
zreturnbitsD,zreturnnotbitsD, zTMsimplebitsD, 
zpattern4bitsD, zpattern8bitsD, zpattern4bitsID, zpattern8bitsID,
zcopyGSRD, zcopyGSR_sDS, 
zbinroutfixed_noshift_transitIR, tailbitswithdD, tailbitsIwithdD,
tailbitswithdnosD, tailbitsIwithdnosD, binroutAND0R, binroutAND00R,
binroutaltresetSR, binrout_probXY2D,
binrout_probXY3D // 28

and marked already as nodepth 

no types: zjustcycle, tailbitsInos, tailbitsnos, tailbitsI, zjusttail // justcycle we have as prob already, maybe get rid others...TODO

FIXED:no depth/types: zbinroutmybumpS, zbinroutmybumpbit, zbinroutmybumpbitt // now these are for theroute and we keep them...

- exp_port: all route, which nada, which strobe

// now with types

pSR_recbinR, pSRxorroutesSR, pSRaddroutesSR, pSRprobxortogxDS,
pSRprobxortogxIDS, pSRmatchD, pSRshareR, pSRGswopSR, pSRsigmaRaboveanyways,
pbitLcvsrrouteD, pstreamD, pSRDACroutestrobeSR, pSRLLbumprouteDS,
pSRbumprouteSCCC, pSRN40RS, pSRN36RS, pSRN33cipherRS, pSRN33RS, pSRN13D,
pSRRLLswopDS, pSRRbumproute0SXXX, pprobintprob3D, pprobintprob5_0D,
pprobintprob6_0D, pprobtoggle1RS, pprobtoggleRS, pprobtoggle3RS,
pprobtoggle4RS, pprobtoggleRS, pprobstrobe1RS, pprobstrobe2RS, pprobstrobe3RS,
pSRN15D, pSRN8RS, pSRN7RS, pSRN6RS, pSRN5RS, pSRxorSRD, pbitSRroutedoitD,
pSR_routeSRbits02R, pSR_routeSRbits01R, pSRRaccelghosts0R // 42

// without types

pSR_layer1R, pSR_layer2R, pSR_reflectR, pSR_altbin1R, pSRholdR, pSRholdfromdacR, pSRshrouteR, pbitSRroutelogXXX, pbitSRroutelogxxXXX, pbitSRroutelogxxxXXX, pbitLSRroutexxxlogD, pSRLcvSRmaskrouteD, pSRLcvrouteD,
pSR32XXX, pSRmodR, pSRNwas13RS, pSRN65RS, pSRN62R, pSRN30D, pSRN22XXX, pSRN21XXX, pSRN15XXX, pSRN12R, pSRN11R, pSRN10SR, pSRNwas15XXX // 26 // all tested fine

// thus no depth/types: pSRRbumproute0SXXX - similar as binroute bumps ahead... *can get rid of
// FIXED:no depth/no types: pbitSRroutelogXXX, pbitSRroutelogxxXXX, pbitSRroutelogxxxXXX, pSR32XXX, pSRN22XXX, pSRN21XXX, pSRN15XXX, pSRNwas15XXX ???


newbits.h redo all bitsn for new types: and fill in exp_port as route/abstract/strobe etc...

// note that when we have exp_port functions to test we hit 80% memory...

** 18/1/2023

// start by cleaning up bitsn functions and then work through geoC new modes and solve questions as we go along...

XXwe need to sort following: global flag (gate[w].globflag)/routes, use of IN flag (gate[w].in), depth/no depth, global dacfrom?// also speedfrom dac, setting of route/type (16 and 17). which arrays to use for functions//how these match*

if (gate[w].in) gate[w].matrix[5]=gate[dacfrom[daccount][w]].dac; // example
else gate[w].matrix[5]=LFSR__[w]; // we do need this


#define ROUTETYPE (gate[w].matrix[16]>>9)
#define ROUTE (gate[w].matrix[17]>>8)

- global-> R mode manipulations (what else we have here?) - advantage of global is to match routes across all...
- local/same as depth gapped... 

- Q to ditch global flag (or ditch all global routes) and just set SETROUTE=(binroute[count][w]|binary[w])<<8; // but that just sets the route once, and if count changes...

//if (gate[w].globflag) tmp=binroute[count][w]|binary[w]; else tmp=gate[w].theroute; // was tmp=binroute[count][w]|binary[w];     

- functions:

1.abstract bits (R mode, N?)
2.route bits-all 
3.route bits with types

- notes

1. CVL as route/type
2. CVL as parameter eg. osc
3. CVL as prob of X or Y (against DAC or LFSR__) // for prob we don;t worry about CV functions or these are set to dac
4. CVL outside functions as length, dactype, adctype

// or different struct for each function -> see geogen.h but then we need to fill this for all...
typedef struct bitfunc_ {
uint32_t setroute;
uint32_t depth;
uint32_t in;
uint32_t(*func)(uint32_t depth, uint32_t in, uint32_t w);
} bitfunc;

//uint32_t binrout_probXY1(uint32_t depth, uint32_t in, uint32_t w){   //global

static const bitfunc probXY1={0, 0, 0, binrout_probXY1};

** 17/1/2023

- still not so resolved on local/global/set by depth - need clear policy as in some modes is so/not - or we set ROUTE to this...*

- fixed bug as should be: depth=depth|(1<<w); // adds itself not |w (0,1,2,3) 

- added   gate[w].strobed=1; to exp_port.h in trigger modes

TODO: test new exp_ modes

- fix up all bitsn.h so is now usable

only using types and those with no types, mixed

nostrobe
strobe
nodepth

setroutes - do we need that bit????

/////

- [do we need copy matrix from first modes -> matrixp or do we use gaps CHECK? // only if we use full matrixcopy, otherwise we just set what we like]

- maybe remove non-type route functions if these are doubled by types -> sort out bitsn.h

Questions as not so relevant: bitroutI

new zz types added/to add in: added: zzwiardbits2I, zzwiardbitsI, zzwiardinvbitsI, zbinroutfixedfixed, zzsingleroutebits, zbinroutfixed_prob1R, zbinroutfixed_prob1L 

added no depth: zbinroutfixedmy, zbinroutfixedmyreset, zbinroutmybumpS, zbinroutmybumpbit, zbinroutmybumpbitt, zbinroutmycv(depth)

*to add below*

fixing/adding from exp_port: pSR_recbin, pSRxorroutes, pSRaddroutes,
pSRprobxortogx, pSRprobxortogxI, pSRmatch, pSRshare, pSRGswop,
pSRsigma, pbitLcvsrroute, pstream, pSRDACroutestrobe, pSRLLbumproute,
pSRbumproute, pSRN40, pSRN36, pSRN33cipher, pSRN33, pSRN13,
pSRRLLswop, pSRRbumproute0, pprobintprob3, pprobintprob5_0,
pprobintprob6_0, pprobtoggle1, pprobtoggle2, pprobtoggle3,
pprobtoggle4, pprobtoggle5, pprobstrobe1, pprobstrobe2, pprobstrobe3,
pSRN15, pSRN8, pSRN7, pSRN6, pSRN5, pSRxorSR, pbitSRroutedoit, pSR_routeSRbits02, pSR_routeSRbits01

guess need to test these all again

deprecate: binroutesel0, binroutesel1, binroutesel2, binroutesel3, binroutesel4,

** 16/1/2023

added: zbinroutfixed, zbinroutorg, zbinroutorgap with types!

TODO:

- DONE: IN flag??? as LFSR or as DAC?

- question of missing depths // fill ins as we go along

////

DONEwhen we do or don't set ROUTE as is not relevant for all...DONE in outer_C23

add in last functions left out of arrays:


DONEadding in no-depth matrix ones: zbinrouteORbits, binroutaltreset etc...

////

question if we want to set gate[[w].theroute to ((binroute[count][w]|binary[w])<<8) ????*

////

- to resolve: depth question (IN we set as default with flag)

test depth in each inner...

make final lists of functions in groups or leave as are...

all_bits
abstract only
routebits all

routes with type only

////
- areas such as route, speeds, probs, types and how these can overlap...

1 - basic settings, global routes and prob
2 - 
3 - route/types/routefunctions
4

1 - gaps in routes/speeds/probs
2
3
4

1 - strobes???
2
3
4

1 - matrixp
2
3
4

- struct example:

typedef struct bitfunc_ {
uint32_t shifter;
uint32_t (*routebits[64])(uint32_t depth, uint32_t in, uint32_t wh);
uint32_t useofdepth[64];
} bitfunc;

- how this can fit with inner functions and we init it... 

eg. from worm: static const wormer sp0256er={0, 0.3125f, sp0256_get_sample, sp0256_newsay, 0, 0};

static const bitfunc router={6, routebitsd, useddepthsd};

// what we do with depth if we don't use it... as length, as prob...

DONE- do probs with theroute (or do we have this - we have if we set gate[w].globflag -> 0 is theroute) + prob of theroute vs. global ( Zbinroutfixed_prob5)!

also we have as: NZbinroutfixed_prob4, 

//// also some use IN - how do we set this... what uses IN and how?

use of IN:

could be LFSR: zsuccbitspp, zsuccbitsprob, zsuccbits_noshift, zsuccbitsIpp, zsuccbitsI_noshift, zwiardbits, zwiardinvbits, zTMsimplebits, zwiardbitsI, zwiardinvbitsI,

binrout_probXY, binrout_probXY1, binrout_probXY2, binrout_probXY3, binroutfixed_prob1R, binroutfixed_prob1L, binroutfixed_prob1, binroutfixed_prob2, binroutfixed_prob3, binroutfixed_prob4, binroutfixed_prob5, binroutfixed_prob5_nosh, binroutfixed_prob1_nosh, binroutfixed_prob2_nosh, binroutfixed_prob3_nosh, binroutfixed_prob4_nosh, cipher, pcipher, zwiardbits2I, 

// solve by setting as LFSR or as dac? // but which one... another flag? could be////

as param: zosc2bitsI, zpattern4bits, zpattern8bits, zpattern4bitsI, zpattern8bitsI, - these are more abstract ones...

////

[- do we need to remove new depthroutes from arrays with depth as now they have no depth, or we just always fill that just in case]

/////

arrange possible first 16 modes: new idea of simple global routes only...// or for first 8 at least

classics// all global route: 

00 as we have
01 change length// or other prob eg. of inversion=prob2
02 fixed vs. cycle prob - as function: Zbinroutfixed_prob1 - uses type
03 fixed vs. [fixed XOR cycle prob] - as function: Zbinroutfixed_prob4 - uses type - without Z is no types

length/dactype/dacparam/route/routetype/function/arrays of functions

again question of slippage of arrays - so many bit arrays and DEPTH uses/ also IN? *ideally we don't want to worry about which array/depth/in*

- q of bitfromsdr - as we only ever use func 31 to set glob*

** 13/1/2023

- some functions can use depth as route
- DONEso far those which set theroute we change as in: ZzbinrouteINVbits (first test conversion)// 

DONE: make array of these changed ones: routebitsnodepthmatrix

TESTED: changed type/change func/change route -> C01/route and C02/type

** 11/1/2023

- implement below: SETROUTETYPE and SETROUTE

IGNORE[[// but question now if we need for ROUTE as we have theroute which is only ever set by depth (so as long as we don;t always set it is ok)
[eg. as we wrote: *that maybe we should NOT set gate[w].theroute=depth everywhere as it can also be used for gaps - or should just be set in OUTER/INNERS?*]

so question is really where we set theroute - as if is gapped then sets to any depth?

options:
-route as theroute (set by depth in which functions)?
-route as depth (not setting/setting theroute)...

does new matrix help?]]

Yes, redo as we want to simply pull both into matrix

..........................///////////////////////////..........................

FIRST:
DONE// fill in matrix and matrixp arrays everywhere for new lengths 

// change and note which geogens now do this

// for type? is only binroutesel2, binroutesel3 CONVERTED

// for route? 25 in total - how do we decide when to set or not the matrix for this one? // as we dont know if we are in these unless we make/or do we have these as an array?

check that? routebitsfixeddepth? but has some not here -> difference is if they set theroute or not from depth?

ZzbinrouteINVbits, Zzbinroutebitscycle, Zbinrout, binrout, binroutI, binroutAND0,
binroutAND00, binroutesel1, binroutesel1S, zbinrouteINVbits,
zbinroutebits_noshift_transit, zbinroutebits_noshift,
zbinroutebitscycle, zbinroutebitscyclestr, zbinroutebitscycle_noshift,
zbinroutebitscyclestr_noshift, zbinrouteANDbits, zbinrouteSRbits,
zbinroutebitsI_noshift, zbinroutebitscycleI_noshift,
zbinroutebitscyclestrI, ZzbinroutebitscyclestrI, flipflopandroute,
routevalue

/////////////////////////////////////

// describe outer functions in geoC which set appropriate CV -> SR_geo_outer_C20 has SETROUTETYPE

To notes: macros we have are now:

#define ROUTETYPE (gate[w].matrix[16]>>9)
#define ROUTE (gate[w].matrix[17]>>8)
#define SPEEDFUNC (gate[w].matrix[0]>>7)

#define SETROUTETYPE (gate[w].matrix[16])
#define SETROUTE (gate[w].matrix[17])

- look again at final matrixp abstractions - in geoC but not sure of these???

** 6/1/2023

//schiphol

working through below - question is where we set SETROUTETYPE and SETROUTE to CV or DAC (in geoC outers) and what this means for dropping depth from some functions...

eg. in binroutesels

DONE//TODO/now in progress/test:

- pull type and route out from depth settinginto matrix/matrixp -> trialed in one instance in geogen.h and geoC.h

  uint32_t matrix[18]; -> 16 as routetype CV, 17 as theroute...

replace -     gate[w].theroute=depth //>>8; with     gate[w].theroute=gate[w].matrix[17]>>8; in geogen... gate[w].theroute=ROUTE;

which was in geoC but could now be in geogen: gate[w].routetype=gate[w].matrix[16]>>9; gate[w].routetype=ROUTETYPE;

we need in geoC eg. gate[w].matrix[17]=CVL[w];

or macro

#define ROUTETYPE (gate[w].matrix[16]>>9)
#define ROUTE (gate[w].matrix[17]>>8)

uint32_t tmpp=depth>>9; // 3 bits
gate[w].routetype=tmpp;

also needs to be replaced in geogen...

  uint32_t tmpp=ROUTETYPE; // 3 bits
  gate[w].routetype=tmpp;


gate[w].routetype and gate[w].theroute - but what about local and global routes...

so we replace these - can also be small macros (as can be for other matrix ops if we like)

we can also have other defines eg in geoC:

// speedfromnostrobe[gate[w].matrix[0]>>7])(gate[w].matrix[1], gate[w].matrix[2], w)){ // speedfunc

#define SPEEDFUNC (gate[w].matrix[0]>>7)

but we have these already// maybe makes it easier - placed in macros

//
*16 simple modes - are these all global route modes?*
16 gapped modes
16 strobed
16 matrixp

** 23/12/2022

TODO: draft first 16 modes for geoC and see how these work across all 4x SRs...

add in dacfrom->dacparam (also indicates potential matrixp operations as we can have select which parameter gets dacfrom attachment) - how to distinguish CV-style params and selector(eg.speedmode) params*

// from below//altering with notes...

fixed route means global route// all as types from 4+

1. binroute fixed [dac/adc type]//reset
2. length 
3. dacparam
4. depth as route only. type stays the same...

5. depth as type/type is now set via: gate[w].routetype=CVL>>9; ///

6. fixed vs. cycle fixed prob
7. fixed vs. [fixed XOR cycle] fixed prob
8. gapped depthroute vs cycle
9.                   vs. [depth XOR cycle prob]

10. select routebitsfortypes, gapped depth and type // depth can be route or param??? see new NZ functions! where do we set theroute?

see below: - that maybe we should NOT set gate[w].theroute=depth everywhere as it can also be used for gaps - or should just be set in OUTER/INNERS?

NZ eg.
static inline uint32_t NZbinrout_probXY(uint32_t depth, uint32_t in, uint32_t w){  
  uint32_t bitn=0, bitrr, tmp, x, tmpp;
  //  tmp=binroute[count][w]|binary[w];
  tmp=gate[w].theroute;
  if (depth<LFSR__[w]) tmp=tmp^15;
  tmpp=in>>9; // or in can be route // 3 bits
  gate[w].routetype=tmpp;
  ROUTETYPE_;
  return bitn;
}


11. depth cv
12. prob routed vs cycle - gapped as above
13. prob vs        XOR - gapped as above

14. gaps: combines of above... gapped prob setting and change route/type/function - but which prob??? cycle or XOR // can we gap this choice///lastfunction... or do as real probfs
15. dacfrom->dacparam and one of above?
16. ???

- decide on architecture - if we have slidings of inners, if we have all matrixp or just last 16 modes? 16/16/16/16

NOTE: If we have sliding inner modes or even speed/bit modes then we need equal size function arrays (so all 64 with repeats)*

DONE: in geogen.c:::
// uint32_t (*routebitsfortypesALL[34])(uint32_t depth, uint32_t in, uint32_t wh)={Zbinrout, Zbinroutor, ZzbinrouteINVbits, Zzbinroutebitscycle, zbinroutebitscyclestrI, Zflipflopandroute, ZpSRsigma,  Zviennabits, Zzsuccbitspp, ZzsuccbitsIpp, Zzwiardbits, Zzwiardinvbits, Zbinroutfixed_prob1, Zbinroutfixed_prob2, Zbinroutfixed_prob3, Zbinroutfixed_prob4,  Zbinroutfixed_prob5, Zbinrout_probXY, Zbinrout_probXY1, NZbinrout_probXY, NZbinrout_probXY1, NZbinroutfixed_prob1, NZbinroutfixed_prob2, NZbinroutfixed_prob3, NZbinroutfixed_prob4, NZzwiardbits, NZzwiardinvbits, binroutesel2, binroutesel3, Zzsuccbits, ZzsuccbitsI, NZzbinrouteINVbits, NZzbinroutebitscycle, NZflipflopandroute};

// converted these from:
//      tmpp=in>>9;
//      gate[w].routetype=tmpp;
 
// to
//tmpp=gate[w].routetype;





** 21/12/2022

- fix resets in each - so locally we reset the matrix/p, local stuff and local binary.. in geoR we will draft full reset on last mode - or is maybe already...

globalls[0] is that resett! - called by SR_geomantic_innerRglob and SR_geomantic_innerRglobselandset -> geoR: do as last mode. all held but this... or do as matrixp with RESETG macro*

count=0; daccount=0; spdcount=0; binroutetypecount=0; 

** 20/12/2022

DONEonly RESET on change in first mode

any reset in any mode will reset GLOBAL counts... so returns all to simple*
again question of global or only reset is on right side - global is global...*

need somehow right mode which keeps own function and just resets - so is all gapped - or can globals on right be all gapped-see 21/12 above

- re-tests:

tested SR_geo_outer_C01matrixpp with full matrix and seems function... 

matrixp - why CVL setting doesn't hold over from main init?

DONEre-test mode 4 dac_ and test fixed 16

DONEC53 to fix, TEST!

DONEouterC01matrixp - TEST cleaned up... - was problem of not copyong matrixp in init - fixed by moving init earlier...

test SR_geo_outer_route* -> DONE:draft list of inners: eg. void (*SRinnersC[64])(uint32_t w)={SR_geo_inner_fixedC}; and *test! - where?DONE

- DONEadded in setandcopy for matrix stuff: to test: fine

///

- TODO: dac/dacfrom -> dacparam as basic mode in geoC// also for depth/adc in geoN*

- Q of extents, of prob and interpol if we slide modes... - trial, also for interpol and prob so is generic/even no inner or?*

** 19/12/2022

- see tests below and new geoC test code!

- question of sliding is when we have fixed 1<<6 etc... as that causes problems...

** 16/12/2022

- see end of geoC for possible slippages!* but we need to test things first

TODO: new 16 first modes in geoC... how we ensure there is always IN matrix[5] as LFSR or other

that in matrix we can not gap changing values (as in attach), so is only really good for fixed values (matrixp could solve this???) 

or what we really need as changing is: INs, sometimes depth

- draft matrixp works and changes? to inner and outer/arrays of... -> at end of geoC.h:  SR_geo_outer_C01matrixp

DONE:draft list of inners: eg. void (*SRinnersC[64])(uint32_t w)={SR_geo_inner_fixedC}; and *test!

list of outers we already have in 000

lists of routefunctions etc...* - trial this out! below in tests

eg. uint32_t (**routetest[64])(uint32_t depth, uint32_t in, uint32_t wh)={routebitsd}; // all need to be same length
// to test calling:
uint32_t bitn=(*routetest[0][gate[w].matrix[3]>>6])(gate[w].matrix[4], gate[w].matrix[5], w); // >>6 as there are 64 // tested only with compiler

TO TEST/studio:

- DAC rework. code in 000 // SR_geo_outer_testDAC RESULTS: mode 16 has issues/TO FIX, case 4 as with all strobes we register strobe=1 too late for macro of outv!- FIXED/TEST!

TODO: also increased left shift - TO TEST! 19/12, test 2 also as now inverted...

- global/local flag - how to test - by setting in a simple case (do test code) // SR_geo_outer_testglobal TODO // test set from outer inner geoC route SR_geomantic_outerRglobroutetestDONE

- in geoC test last 71+ prob modes SR_geo_outer_C71 DONE_OK

- TEST: we have logical ops: binroutorg, bitrouteorgap: SR_geo_outer_testORDONE_OK

- TEST - prob of CV vs. global route - do we have that? set routes 0 now as prob5 and prob5_nosh: SR_geo_outer_testprob5DONE_OK

- test changes to runglers in geoC: SR_geo_outer_C52 and SR_geo_outer_C53 // what were changes? - C53 doesn't work - S3 inner problem*

-  SR_geo_inner_probcycle(uint32_t w){  // TESTY SR_geo_outer_testprobcycleDONE

- tests for abstracted route list SR_geo_inner_noprobTEST>rouetanytest OK

- trial matrixp draft: SR_geo_outer_C01matrixp // not working as maybe need to fill all slots!?*

** 15/12/2022

TODO:


- list routes/any functions which use depth and IN! eg. probXYs

- DONE: DAC_ rework and *TEST:test code setups - could also try to use otherpar in some instances *eg. to mix/offset*

- NOTE: or DAC:gate[w].matrix[6]=31<<7; //length as 31 now - // also we could have CVL for both length and otherpar (or invert one against the other)

- DONE: global/local flag to code/test TO TEST!

- *see what patterns are in inner and outer modes!* -> towards dislocations

OUTER: outer // if changed [
1. sets matrix[x] to values (fixed or ...) - could be replaced by matrixp ]

2. sets inner function... also could be in matrixp //  but matrixp is just pointers to providers/values

eg. gate[w].inner=innerfuncs[index] -> how we get to that index as extra step - see above

// if changed
// copy matrixp

// gate[w].inner=innerfuncs[matrix>>7]; // 5 bits

INNER is more complex:

// interp/set dac
// if speedfrom
// deal with trigger or not
// GSHIFT_
// length
// probf/bitn - depends here....
// BITN_AND_OUTV_; 
// new_data(val,w);

- *is there any potential for dislocation across SRs and what this could be??*

SR leaks over portion of another - did we have this (as a global?)

DONE:

- fix shared gshifts to non-shared DONE
- DAC we need to write test codes- test CVL as otherpar for each of DACtypes and fixed length(short and longest to see how compares) - write test code... DONE TO TEST

** 14/12/2022

*- that we can make lists/arrays of routebits functions arrays (though they would either need same length or to be in structure with length indicated)*
*- also we can make arrays of inner and outer functions (we have outers in 000 as:  void (*SRgeo_outer[4][64])(uint32_t w)= ...)*

These lead towards dislocations.

*First we need to draft dislocations of: matrixp and matrix -> how to start with this?*

*for matrixp we can copy in different arrays and shift these - shift matrixp along, make gaps, asign things (how?), overlay with SRs to set/unset*

*also for globflag below we can cycle through SRs to set/unset, use strobe to bump on etc...*

////////////////////////////////////////////////////////

Q of flag in each SR - use global, local???*

if (gate[wh].globflag) tmp=binroute[count][wh]|binary[wh]; 
else tmp=gate[wh].theroute

set this where... is nice to keep flexibility of function to say pass dac to depth/route... but if we have flag we don't know if we use depth/cv!

somehow inner mode needs to handle this...

but this is just for when we have globals! otherwise leave gaps... - how to handle flag locally and globally...// with resetx to global=1*

////////////////////////////////////////////

DONE check/TODO: which use IN - to fix all probs for gaps in geoC // which of probfsins use IN: spdfrac2 %in,3 in+depth,4 add too ,spdfracdac3 dac%in+depth, zosc2bitsI=on/off, compbits in>depth, spdvienna - recurse/depth/in

added in geoC.c and tables.h:   gate[w].matrix[11]=gate[dacfromopp[daccount][w]].dac; //

*added in functions and tidying - but no crash check so far - length of arrays???*

** 13/12/2022

question of types, route-global/depth and route/bit functions: sel0 and sel2 have fixed routes, otherwise routebitsfortypes use depth all...

whether to fix depth and route gaps: depth=gate[wh].theroute; for gapped routes eg. CV[4]=gate[wh].theroute<<8; but only when we know it is about a route - *larger question*

TODO:
- geoC: draft new basics, strobe and matrixp modes

Draft all of these basic with TYPE set!

[older: 1. binroute fixed (change length/dac/adc)
2. depth as route only
3. fixed vs. cycle prob
4. fixed vs. [fixed XOR cycle prob]
]

fixed route means global route// all as types from 4+

1. binroute fixed [dac/adc type]//reset
2. length or/and dacparam 
3. Q. as not all types use dacparam but needs to make sense together... - so do as length too or seperate these in DAC_ TO_TESTDONE
4. depth as route only. type IN gapped    
4. depth as type/type is now set as IN:   gate[w].theroute=depth; fixed route global or local?
 
now using TYPE as IN:

6. fixed vs. cycle fixed prob
7. fixed vs. [fixed XOR cycle] fixed prob
8. gapped depthroute vs cycle
9.                   vs. [depth XOR cycle prob]

10. select routebitsfortypes, gapped depth and type // depth can be route or param??? see new NZ functions to collect
11. depth cv
12. prob routed vs cycle - gapped as above
13. prob vs        XOR - gapped as above

14. combines of above... gapped prob setting and change route/type/function - but which prob??? cycle or XOR // can we gap this choice///lastfunction... or do as real probfs
15.
16.

// routebitsfortypes array and the binrouteselX are only ones which use types... so there is a split there

/////

- TODO and check from below
- fillin L,N, R towards full tests
- recheck routes and route types

OTHERS: 

*re-check dac modes as some silent even with strobe why? - was it feedback but re-check anyways*

- re-check modes in geoC.h. test changes to runglers.... implement SR_geo_inner_probcycle(uint32_t w){  // TESTY - using probfsins - ported in from speeds -> basic gapped cv binroute against justcycle!
  // what cv we need: probfs: 9type,10comp... 3,4,5 is gapped... - *WHERE to place?*

C: check unused innersL: SR_geo_inner_probcycleC, inner_split1C, inner_split2C, SR_geo_inner_prob_strobeC (TODO), SR_geo_inner_prob3C (nostrobe, prob is strobe), SR_geomantic_inner_split3C (TODO)

what others are unused?

/// DONES

DONE:  gate[w].fake is now using trigger for dacs geoc and in strobe we just set to 1! in geo.c and we just need there as we don't set dac elsewhere or do we?
gate[w].fake=gate[w].trigger;
gate[w].fake=1;

DONE:fix reset for each side

DONE: added SR_geo_inner_proballC with mix of 64 strobe and non-strobe/mixed probs!

DONE: added routebitsfortypesfixeddepth for types with depth passed in! depth/route=gate[w].theroute

DONE: fixed reset for CV values and matrixp

////////////////////////////////////////////

** 9/12/2022

- check what we have as fixed route 1<<7 in bit/route func arrays references... DONE

DONEalso ADC/geoN should have route in/no route in opts/probs as major
TODO/as basic modes: check what we have in geoN for this option - switch route in/no route in... as one mode/no/yesDONE as N01, WE_HAVEas strobe/toggle, as prob (both are probs), different kinds of prob

** 8/12/2022

- segmenting is in the gaps, and in slippage of inner and outer modes...

TODO:
- in geoC test last 70etc prob modes

- DONEstrobe=1 added in necessary geogens and *test these* - tested just with strobe speed but should work!

- TEST: we have logical ops: how does that work eg. route 8OR1=8+1 (and if both 8 then just 8 so adds route, AND = neither, also new gapped theroute, also expand those

- TEST - prob of CV vs. global route - do we have that? set routes 0 now as prob5 and prob5_nosh

- from 5/12 TODO:

DONEand there is also localroute which is just like depth - but maybe re-work this also as gate[w].theroute

** 5/12/2022

- how to handle global/local/cv route -> to merge local and cv route? // was that myroute?

from below: local is?:  tmp=myroute[w][gate[w].route] | binary[w]; /// but check this and we also need to set this!! gate[w].route in binroutmy

- DONEwe don't use it much! - remove local routes -> new one: gate[w].theroute

///////

- is binroutetype ever global? > yes, there is binroutetypes which is all 0, no need - DONE // removed global binroutetypes

set geogens with binroutetype to:   tmpp=gate[w].routetype; DONE - so we have no global types, just cv/gapped

tmpp=gate[w].routetype; is local one

** 1/12/2022

global
local
cv

- route is global so we can match them up (but cv vs local ruins that)

route: local/cv does that make sense or should just be gapped... pull out? how? as in type we set local route

** 30/11/2022 

- 16 or 8 simplest modes: type of binroute, route itself, prob of route or/xor etc (see below)

- how to recur on or deconstruct/segment these simplest modes -> holes in modes

- try: global XOR/OR local OR/XOR CV DONE

- how to simplify? so that arrays more or less match up!

** 17/11/2022

- in some geogens we have: tmpp=gate[w].routetype; [binroutesel4, binroutesel4S]

but we need to set this for gapping: gate[w].routetype=tmpp; -> check this=DONE

options: always set when we set from CV, so is local/gapped or global ... fill in some extras here - will have to check through these...

always this conflict between cv, local and global...

eg. for:

- type of route/shift -> now local is set by CV
- binroute = locally set, global, CV led... (check if cv sets local too?)

local is?:  tmp=myroute[w][gate[w].route]|binary[w]; /// but check this and we also need to set this!! gate[w].route in binroutmy DONE?

global is: count

** 14/11/2022

basic first modes // to check against geoC:

1. binroute fixed (change length/dac/adc)
2. depth as route only
3. fixed vs. cycle prob
4. fixed vs. [fixed XOR cycle prob]

1/5. depth gapped for 3.4. depth as route vs...
2/6.
  
** 10/11/2022

problem is always if we don't use CV eg. nodepth for say binroute, how to fix that always if we do/don't use CV. unless we always divide up

gap can be previous, not always ahead

** 9/11/2022

- new notes for NLCR assigns:

- DONE->check how much ADC replication will cost memory? in geoNN we replicate geoC functions but with adc inserted.... 48% +5% so fine...

** 8/11/2022

TODO:

// basic setup for modes

1-set param eg. N-ADCtype, C-DACtype, LR-binroutetype 
2-basic routes
3
4

1st of sets opf 4 sets major parameter for next 4!

- draft strobes: strobetype->CV[w] usage ->

speedfromstrobe (some use depth - usedstrobe if they do ==1), speedfromstrobenodepth [16]both

expand generic prob of bitx vs cycle...

probability:
- 1cv bitmodetype3-gapped
- 2cv altmodetype
- 3probcv against IN/4
- 4probtype ->

** 7/11/2022 - for speedmodes

speedfroms: check which use CV and IN -> done, should fix rungler modes for these...

- fixed some in geoC

- added more generic prob function for cycle - to match with outer and
  test this? // isolated test also for rungler/new probcycle for
  speedCV/IN divide (if we don't use IN)

** 6/11/2022

- fixed some bugs in innerNOS

DONE//-TODO: genericise speedends into func - so just one array... w==2 has no end... and we can double up lots of geoC into other modes

simpler begin arrays: 1st 16 to re-check...

0-DACtype selected // adctype // routetype // binroutefunc
1-fixed route/change length
2-fixed route/prob of route or cycle
3-fixed route/prob of route XOR cycle


** 4/11/2022

worried about FLASH use as we need to generic/double up modes - most of geoC are quite generic except: for ADC we need all functions again, for speedends also...

- or how we can genericise those? means extra ifs, or we wrap adc ones somehow... // insert macro but is still an if!

for L we have pretty much same as C maybe with more prob of entries, for R we need abstracts and globals

JUST realised that 4,5,14 of DAC_ modes use strobe which causes problems for strobe speeds and other strobes... to remove- kept as gate[w].fake which could be used as trigger/.. also from prob!

TODO: DONEspeedmodes and fill in rest of modes, 

what speedfroms we have in geomantic.h:

speedfromnostrobe[34]
speedfromnostrobenoend[34]X geoC

speedfromforxor[5] - 
speedfromcvforxor[24]

speedfromstrobe[16] - for strobes
speedfromstrobenodepth[10]

DONEre-test slur say with speed

- more length from dac also - as a very basic mode too (but where to insert?)

void SR_geo_outer_C00(uint32_t w){  // set dactype, spdfrac, fixed route // RESET - no need for changed
  if (gate[w].changed==0) { 
  gate[w].matrix[0]=0<<7; // spdfrac
  gate[w].matrix[1]=CV[w];//??? speed
  gate[w].matrix[6]=CVL[w];//
  gate[w].inner=SR_geo_inner_fixed;
}
}

*// also think about probability across choice of inners/outers but would lose cv?*

- do we leave gaps in last geoC routes for speedmodes... eg. 30, 31, 32, 33 with gaps for speedmode but use CV[w] of course? GAPS _DONE*
- speedfrom dac, different speedfrom modes, prob - what we have for next sets of modes???
- question of gap when we have fixed values?? I guess we don't need to see if fits as all 12 bits fit

- what routes do we have - in bitsn, in geoC=X so far:

bitsn:

routebitsd[64] X
routebitsnod[32] - no depth X
routebitsnostrobe[64] - for strobe speeds XTODO
routebitsfortypes[32] - IN as type X
routebitsfixeddepth[32] - we can pass fixed depth X
routebitsnostrobedepth[64] - for strobe, with depth UNUSED - checkIN 0 maybe use instead of routebitsnostrobe
routebitsnostrobedepthprob[32] - prob vs IN! Xinprobs TODO


** 3/11/2022

DONE//TODO: test first set of 16 geoC functions when we have right size for arrays and checked these - *other geos will need to have arrays all checked

DONEget arrays to right size in bitsn -> if necessary add from exp modes...DONE but we still need more abstract modes, not worried for geoC

** 2/11/2022

- in geoC check which func arrays have which size and make sure all are correct size 64/32/16 only and >>6 >>7 >>8 -> *TODO: adjust size of arrays where necessary - see bitsn.h

** 1/11/2022

- started expanding geoC -> doubled up some arrays for safety but also change access

** 28/10/2022

*all modes at 64 or 32 and adjust accordingly and fix binsd array accesses - geomantic and bitsn

definition of array and size is only important when we start to set things and leave gaps...

- *toport.h in reserve to check: splitspeeds!

globsels in geoLR - finish and test



** 27/10/2022

- DONE: added reduced 12 bit LFSR__ so can point to this in fixedvars...
- endspeed we don't mix and match in modes
- *DONE-if strobe and other speeds are on same CV/matrix or we expand on this so we can flip back... - now we have [15] for strobe function

fixedroute/fixedtype
depthroute/fixedtype
fixedroute/flextype
depthroute/flextype -> 2x CV? so is just last IN ...

->other types of binroute

- +redo sels for no strobe option...+

- +rework etc exp_port+


** 26/10/2022

- probability in regular bitmodes is now vs. in and we pass LFSR to matrix[5] <(LFSR_[wh]&4095)// remember - but then we need to handle these - different sets... make exampleDONE in geoC

// redo geoC for new arrays of routesDONE, and clean these up! TODO: also adjust size of arrays where necessary

TODO:

- bring down bitops to 64 where needed and try that // routes now, abstract ones for N, L and R only...

-  DONEsorting etc bit modes also and could use prob for some/all of the strobes there,

- DONEre-test etc modes 


// sel0 etc. do have strobe option so maybe replace there for no_strobesDONE

/////

-speed
-bits:
  abstract ones: check all use depth, strobe abstracts?
  routes: no depth.fixed -> prob
          strobes/no strobes
          prob - use [5]/in and/or always have in reserve as LFSR 
-prob: 

question still of unused depth - we can have length anyways, of 2x used strobes, of 2x probs to prevent

** 25/10/2022

- simpler binroutes now with types... tested simples, fill out and see which ones use depthDONE
so we can manipulate type in binroute segments of modes!

/////

- Q of local/global routetypes...??? to pass in IN

routetypes: local/global 0-7  // 4 bits with local/global flag? does flag make sense? no...

uint32_t tmpp=gate[w].routetype;
or:
uint32_t tmpp=binroutetypes[binroutetypecount][w];
or can be depth also... but then we would fix route

does local route go into matrix?

routes // 3 options: 
tmp=binroute[count][wh]|binary[wh];
tmp=myroute[w][gate[w].route]|binary[w];
depth=depth>>8; // 12 bits to 4 bits 

each has one of  8: BINROUTE_, BINROUTESR_; BINROUTEalt_; BINROUTEZERO_; BINROUTESHARE_; BINROUTENOG_; BINROUTEtrig_; BINROUTEnoalt_; 

binroute function!

also note Gshare which is binrouteshare...

simplified routes (19): binroutor, binroutAND0, binroutfixed_prob1, zbinroutebitscycle, zsuccbits, zsuccbitsI, zreturnbits, zreturnnotbits, zwiardbits, zwiardinvbits, binroutfixed_prob1R, binroutfixed_prob1L, binroutfixed_prob2, binroutfixed_prob3, binroutfixed_prob4, viennabits, flipflopandroute, binrout_probXY, binrout_probXY1

// binroutemy are all local routes...


** 24/10/2022

matrix: 0speedfrom/index, 1speedcv1, 2speedcv2, 3bit/index, 4bitcv1, 5bitcv2, 6lencv, 7adc, 8adccv, 9prob/index, 10probcv1, 11probvcv2, 12altfuncindex, 13dactype, 14dacpar

speed: func/strobefuncs
bitn: abstract or routes: generic types, fixed routings//other routings, + more esoteric (like twin routes)
prob:

(adc, dac, length)

//////

- *BINROUTE area* with selected binroutetypes and simpler range of binroute ops...

DONE-TODO: compare different binroute types (binroutesel3 = bitfromsd/79, test new bitprobsDONE


- DONE: probability of route X or route Y, but is also odd to have prob twice - in bitn and in prob modes... but they can use differing CVs

- that bitn can be max 64 -> 6 bits = in inner we have eg. bitn^=(*bitfromsd[gate[w].matrix[3]>>6])(gate[w].matrix[4], gate[w].matrix[5], w);

- how we handle binroute types - binroute area... which types make a big difference and how we can deal with selected type - not just in sel functions???

- how we handle depth in bitns - break down arrays of functions into depth/no depth/ no strobe etc. // also handling of strobe

- that we should have made generic fixed/depth as route so we could just pass to route a depth which can be local, global:

eg. depth=binroute[count][wh]|binary[wh]<<8; // but this doesn't work for some modes which have fixed route and use depth also! and we would have to assign this to a pointer... if we want to attach it.,,
// we have list of these...

- matrix of gaps can also be from SR!?

- 4x4x4 modes =64

** 15/10/2022

plan out possible modes:

eg. in geoC we have:

simple speed // no ends (as dac out should not end)
speed from strobe
4 probability modes inc one with speed from mode - added now prob of dac out

in geoN we have different probs for adc entry/freeze etc.

what we have from geomantic.h?* from below and what we have ported into geoX.h?

what types of inner/outer we have from geo:

inners: strobe, nostrobe, xorwithstrobe, orwithstrobe, probf function, 2x rungler-XORfunctions, splitspeeds, otherprob, probforadc, globalsels, speed xor

outers (except just match above): matrixp ops - attach/detach, set gaps/fixedmatrix

** 14/10/2022

- DONE:more tail ops - inversion and OR.XORs what else?

- DONE:tested probfs

- DONE more probf for 16 or 32 probfs?

DONE: question of strobes/toggles in probf if we use those for strobe based speed modes what happens? have probfsins for no strobe - also all of these need to use depth

DONE:trial some of speeds as probs! +probs can also be speeds - they are already+ >> pull speeds out to probf

so now we have 3 sets of probf (and won't use probf):

// maybe have parallel probf sans. strobe, zeroes, ones and only depth/cv based!!!
uint32_t (*probfsins[32])(uint32_t depth, uint32_t in, uint32_t wh)={zinvprobbits, zprobbits, zsprobbits, zbinroutebits_noshift, zbinroutebits_noshift_transit, zbinroutebitsI_noshift, zownprobbits, zownGprobbits, spdfrac, spdfrac2, spdfrac3, spdfrac4, spdfracdac3, zTMsimplebits, osceq, zosc1bits, zosc1bitsI, zENbits, zENbitsI,  zENsbits, zENsbitsI, zENsroutedbits, zcompbits, zosc1bits, sigmadelta, spdvienna, zbinrouteSRbits, zwiardinvbits, zjusttailwithdepth, zsuccbitsI_noshift, zsuccbits_noshift, zSRNbits}; // all use depth // updated with speed

// based on strobe speeds - no depths
uint32_t (*probfstrobes[10])(uint32_t depth, uint32_t in, uint32_t wh)={strobe, ztogglebits, ztogglebitssh, stroberoute, strobezsuccbits_noshift, strobezsuccbitsI_noshift, strzbinroutfixed_noshift_transit, strzbinroutfixed_noshift_transitI, strzbinroutfixed_noshift, strzbinroutfixedI_noshift};

// with depths
uint32_t (*probfstrobesdepth[6])(uint32_t depth, uint32_t in, uint32_t wh)={strobespdfrac, zstrobeBURST, clksrG, clksr, zprobbitsxorstrobe, zprobbitsxortoggle}; 


** 12-13/10/2022

- DONE in geoC.h - thinking of meta-level of prob to use x or y param (eg. use DAC or CV or) *-> further matrix ops??*

- DONE in geoC.h: example of how we deal with strobe free up!? as prob - but still could be odd, live with it...

- from 10/8: *geomantic*:
  gate[w].matrix[10]=(gate[dacfrom[daccount][w]].dac+CVL[w])&4095; //
  detach this too // or rather one new form of re-attachment - we can
  also use value functions here!! // another layer of attach*

DONE: ADC//upto 32 ops and implement reset/other

// add and other ops - only issue is if depth and in are both the same dac = how to avoid this? different dacs for adc -> eg. = incoming gate[dacIN[daccount][w]].dac

** 11/10/2022

- new geoC.h and geoN.h started to sketch modes

DONEextra matrix for dacparDONE, 

//start to make sense of all functions and depth

speed cv1, cv2
bitfrom cv1, cv2
length
prob

??****

how we deal with no adc entry...??

question of delay line to resolve

major question of functions without depth - how we handle that - check all speeds have depth, but what of other funcs?*

eg. some globals don't need depth - then what do we use depth for? or we always keep as length or???/

strobe/no depth/depth - as options - strobe we handle... to keep seperate? or we signal in global eg. gate[x].depth as 1/0


- strobe speed drops depth??? how to handle strobes is now main question? if we handle them in special area?>>>? yes*

- how we handle different types of binroute - also as an area?

*binroute area? - divide areas into binroute, abstract functions... ???*

what types of inner/outer we have from geo:

inners: strobe, nostrobe, xorwithstrobe, orwithstrobe, probf function, 2x rungler-XORfunctions, splitspeeds, otherprob, probforadc, globalsels, speed xor

outers (except just match above): matrixp ops - attach/detach, set gaps/fixedmatrix

matrixp still needs to be properly implemented with gaps etc...

how to divide up speeds?

/// which ones are route based? speedfromnew

zbinroutebits_noshift, zbinroutebits_noshift_transit,
zbinroutebitscycle_noshift, zbinroutebitscyclestr_noshift,
zbinroutebitsI_noshift, zbinroutebitscycleI_noshift, 

zENsroutedbits, -inroute
zbinrouteSRbits, -depth as route

binroutfixed_prob1_nosh, binroutfixed_prob2_nosh,
binroutfixed_prob3_nosh, binroutfixed_prob4_nosh

DONES:

// DONE; to test... how to make global for NLR dacs... - that we have
tables of dactypes or... but that would be very long 5 bits for each -
or global inc of dactype - TEST! as they can be out of sync/means we
need to set in all modes - we didn't do this did we? maybe not so necessary

// DONEcleaned up all older, and new_geo ported into geomantic.h  

// DONEadded dactype and dacpar to matrices, cleaning up modes...

** 7/10/2022

- lowest modes set adc/dactype/dacpar  - plan how we deal with holes and matrices: Modes should decide whether to make use of matrix or not!

(eg. also fixing dacpar to another dac)!

** 6/10/2022

dactype/dacpar and methods for setting this - should be global/local - how key settings should be arranged...

most important for dactype is output of course but others also matter - just where we place these...

adc we have functions for - just need to pull out     if (w==0){ // real ADC - TESTY - how we will handle adc across all - as geoN.h specific modes...

////

define types of inner and outer?

** 4/10/2022

*TODO:*

- fixed dual routes filled out and functions to manipulate these

binroutetypes??? where do we change and set this? global or local?

we have binroutetypecount which is global (and has a global function to change that), we have local for itself

but only few functions use different binroutetypes ???? how to resolve this???


- assign ADC and DAC functions?


- define all outer and inner modes//for each N<L<C<R - see above and below for extras
- details
- CHANGED business - do we always need that, slurs/blurs of modes... // where is the speed of slur (in mode changes: modecnt>128 !!!


-- previous notes////////DONE

DONEother forms of new AND routes...

DONE:to test AND - re-check macros...//no AND in macros as we need a variable there

AND with standard routing doesn;t make sense - trial with 3 as OSC/DONE

** 26/9/2022

- don't shift the AND version so it can slowly pulse - TO TEST! in geogen//DONE

** 23/9/2022

- added macros for binrouteAND and one new function in geogen - so can more gating of one SR by another...

DONE as binroutAND0 but then would need one route in as entry and 2nd as AND as two AND routes in don't make sense... so we have first as IN, and later

added androutes->we could also have fixed dual routes for this: local and globally defined...* first and second single routes/where do we have single routes

** 22/9/2022

- 16 geomantic groups of major ext/int modes on each side - how they could reflect geomantic properties?

- in lisbon code is for grouped modes all set by modeR

- how to have pulsing code on DAC which is like on for x runs and then
  off with x determined by DAC, CV/DAC, CV? - or is same as OR/XOR
  with very slow running other SR - how to test this? -> is 2 routes in (one as OR) - is just usual multiple routes in but needs to be AND (can be OR for inversion) - where to implement?DONE

** 20/9/2022

- lisbon code base for OCT 5 performance:

there we had groups of:

void (*funcgroups[4][128])(uint8_t w)=
{
    {adc2, adc0, adc0, SRminor_vienna, SRrunggenericbitsadc, SRrunghead0N, adcLrung0, adcLrung1, adcLrung2,   adcrung0, adcLbinprob, noSRadc2s, noSRadc2s, adcLabstractLD, stream4_unshare, stream}, //128
  //    {adc2, adc0, adc2, adc0,  adc2,   adc0, adc2, adc0,adc2,  adc0,adc2, adc0, adc2, adc0, adc2, adc0},
  
  {SRX0, SRX0, SR_layer1, SRminor_vienna, SRrunggenericbitsgenopp, SRrunghead0L, SRrung0,   SRrung1,   SRrung2, SRrung3,  adcLbinprob, SRshroute, noSRcopy, adcLabstractLD, stream4_unshare, stream},  // 128

  {newdac2, dac0, dac0, SRminor_vienna, SRrunggenericbits, SRrungout, dacLrung0, dacLrung0, dacNLRin, dacNLRinlogic, adcLbinprob, dac2, noSRdac2s, dacNLRprobin,   stream4_unshare, stream}, 
  
  {SRX0, SRX0, SR5_feedback, SRminor_vienna, SRrunggenericbitsgen, SRrungbody0, SRRrung0, SRRrung1, SRRrung2, SRRrung3,     adcLbinprob, SRX0,     SRX0, adcLabstractLD, stream4_unshare, stream} //64 
}; // 13 so far -- to add more for lisbon - select at random from 50 - how to do from cards...

*which seemed to work well and could be used as model for internal/external modes*

** 9/9/2022

- start to define new file - new_geomantic.c , starting with speeds, adding and fixing some geogens...

test/port some backwards into geomantic

from before- fill out all ADC, DAC settings, speedsX, 

probs: // new prob ones: probcvladcselcvm, probdacadcsel, probtrigadcsel -> more work on these...

// do we have probability of entry of adc or not, also prob of moving adc along? to add these here, and also more generic adcs: internal adcprobs are in geogen.h
 

bits functions and lists 

// *TODO: check lengths of all arrays we access...*
// how we handle dac...? do this at end, first generic funcs filled in
// DONEspeedfromforxor is not implemented - how did we want to do this / dual speedfroms... see here:

TODO--> xor/or of CV-led speedfuncs with non-cv led (eg. fixed routes, strobes/toggles (ones makes no sense))... in new functions:
redone as fixed route: zbinroutfixed_noshift, zbinroutfixed_noshift_transit, zbinroutfixedcycle_noshift, zbinroutfixedI_noshift, zbinroutfixedcycleI_noshift

// *changing types of binroute/which count for binroute...*

** 7/9/2022

- address DAC etc - so question here of new functions and where DAC is addressed

- different ways of addressing matrices eg. stack, copies of matrices of existing values (TODO) - bump through these - list these
- different ways of interpreting matrcies [inner can be a gap and stay - as in we don't need to always define inner functions - maybe note last inners]

** 6/9/2022

//fill out all speeds/functions but shouldnt access beyond what we have but still eg. speedfromstrobe is fixed by outer -> what that means?


- filling in old gaps // how to test gaps again - as gaps only make sense across different fillings and modes

// or mobile CV attachment - trial - variation of setvarz

- where are we up to? // last in caput000 was testing strobes... S0 but we don't use that....

** 4/9/2022

- added new gaps code to test mobile gaps...

** 1/9/2022

- how to test gaps with setgap, setfixed

** 31/8/2022

- now back to idea of more mobile strobe with filled in CV as prob - see SR_geomantic_outer_test

- DONE i think///probs as speed - more granular or do we do this already?* - TODO: add more prob modes in general - but there are many
- if we go from very fixed to unfixed then it stays fixed - so maybe less fixed, only first ones. also RESETR
- SR as mesh for matrix, mobile gap/holes - what is a gap. how unfixing/fixing works... see above and is it most elegant, question of 3d array as necessary or not...

- generic outer wrapper [TODO: with inline inners/macros] - trial this

void SR_geomantic_outer_test(uint32_t w){  // set up so we can test different functions eg. now try different speedfuncs
  if (gate[w].changed==0) { // 1=change 0= no change

    if (unused[gate[w].matrix[0]]) {
    gate[w].matrix[9]=3<<7; // probbits as we can now use CV
    gate[w].matrix[10]=CV[w];
    gate[w].matrix[12]=8<<7; // altfuncindex // we need this!
  }

  // set matrix

    gate[w].inner=SR_geomantic_innernoadcp; // prob one
    }
}  

** 30/8/2022

*TODO: plan finishings:*

- fill out all ADC, DAC settings, speeds, probs, bits functions and lists 

- if (changed) to implement! 
- check all below and geomantic.h//caput000
- all types of binroute, types of slur, globals, gaps, tails, can gaps move
- draft all inner/outer sections for N,L,R,C
- strobey etc.
- checks

- TODO from geomantic.h

/// test setting of dactype and dacpar for modeC

- *??? resolved speedfrom questions/new speedfroms (as CV speeds/all always use CV, except strobes/toggles and ones don't use it) - section where we select only strobes - inc or/xor*

strobe also leaves gaps for other settings...

- *all types of binroute, types of slur, globals, gaps, tails*

- TODO more adc modes, rests from extra.h, re-check all LRCN

DONE:strobe section also needs to avoid bitfroms strobe..

/// 

layers: fixed/gaps, strobe only (some unfixed// parallel), unfixed, matrix/stack/esoterica

** 29/8/2022

notes from notebook:

- does strobe function area make sense as these also carry over (unless we define speedfrom in every case) - but it does free up CV which is important...
// so question is of a fixed speedfrom// not so open

or 4 layers across CVM dial: fixed, dislocated, matrix copies, stack [but how also these can revert, recurse and dislocate across themselves, that the fixed can still open gaps or...?]

- outer processes a matrix of values which inner (chosen by outer or just hangs on) processes....

gaps and slurs...

** 16/8/2022

FIXEDcrashing: DONE: SR_geomantic_outerRglobselandset: test dac as global router param - latest globals! - then we can select and don't need cv// new globalR outer on moving CVs*

can dac ever go over 4095? fixed

- draft ext/int modes - some will be same for N, L, C, R - mark S for strobe and NLCR if needed/or ANY maybe
- for strobe speeds we need bits/modes without strobe (so we need sure lists of these)...
- slur, gaps tests  // from earlier: //other forms of slur eg. only set these on strobe or pull speed into this one... but would need to match inner // catalogue and implement slurs 
- fill out ADC

//by the by:

//TODO-->better way of marking strobe functions... S//

DONEstrobe as deciding (what/example) - strobe can be or or xor with some speedfroms, adc or not adc- now as new inner for strobe

DONEwe put prob in adc but question of prob for bitn/adc is if we use strobe in bitn!FIXED with bit and speed from no strobe

TODO:add different binroutes?proto is there 

would be nice to have say a bit which can be used eg. bit from SR bumps on routes, but where do we get this bit from and that bit needs params*
DONE:or we just use incoming bit://binroute in//depthroutein//local route in where and when we need it*

bit is: gate[dacfrom[daccount][w]].shift_ // or .Gshift_[w]

where we set dactype and dacpar - most important for modeC but we can also change globally, otherpar ->>>> if it is used and gets stuck is a bit problematic...

//

lengthchanging modes->lengthfrom dac simply ???

** 15/8/2022

1st mode-reset/basic bits
2nd - no reset.basic
->16 modes

*arch: sets of outers calling inners, can we mix different models (eg. matrixp copies?), 16 strobe modes with lots of ops???, mobile gaps*

DONEfilling in structural gaps: we added new local binroute but could also be different types of binroute // local binroute is ONLY routing so NOT a different type except in one case

// functions can also determine length (as DACs=bits->values), prob of adc entry or not, internal adc prob modes -> timing, more of strobe on bits and timings, local/global routes, binary, types of binroute 


Geogens - run through each set: speed, adc, bits, prob, tail

DONE: and add globals (bits)...IN PROGRESS // *can have more sets of routes etc...* TESTING and globsel globset seem to work - 

/////

what we still need to extract and to test... adc (so many), dacsettings

how this intermediate work effects structure/architecture: eg. strobes, global modes eg///

sets of now:

in/externalN: adc ins
in/externalL: regular
in/externalR: globals - still as functions, dotail here?
in/externalC: dac outs

** 13/8/2022

// can't do >>7 in adcetc for CVs (as we might use dacs also...)

** 12/8/2022

DONE// shift the >>7 to inner so CV attachment is more consistent but best to have several bit arrays // all arrays should have 32 elements  // divide these up

for manual - hints such as HF in (last mode of AC) into CLKins 

outer modes can have different ways of dealing with modes but needs to have some consistency. eg. a group which deal with gaps...

///

16 basic modes with gaps. can the gaps move? still one step away from final arch

basic modes:

- pass on/resetr
- TMs/prob
- runglers

outer defines a mode but are they different for L, R, C, N - means 4x64 outer modes with some repeats

what basic modes did we outline in the past? // what were groups of modes?

eg.

void (*funcgroups[4][128])(uint8_t w)=
{
    {adc2, adc0, adc0, SRminor_vienna, SRrunggenericbitsadc, SRrunghead0N, adcLrung0, adcLrung1, adcLrung2,   adcrung0, adcLbinprob, noSRadc2s, noSRadc2s, adcLabstractLD, stream4_unshare, stream}, //128
  //    {adc2, adc0, adc2, adc0,  adc2,   adc0, adc2, adc0,adc2,  adc0,adc2, adc0, adc2, adc0, adc2, adc0},
  
  {SRX0, SRX0, SR_layer1, SRminor_vienna, SRrunggenericbitsgenopp, SRrunghead0L, SRrung0,   SRrung1,   SRrung2, SRrung3,  adcLbinprob, SRshroute, noSRcopy, adcLabstractLD, stream4_unshare, stream},  // 128

  {newdac2, dac0, dac0, SRminor_vienna, SRrunggenericbits, SRrungout, dacLrung0, dacLrung0, dacNLRin, dacNLRinlogic, adcLbinprob, dac2, noSRdac2s, dacNLRprobin,   stream4_unshare, stream}, 
  
  {SRX0, SRX0, SR5_feedback, SRminor_vienna, SRrunggenericbitsgen, SRrungbody0, SRRrung0, SRRrung1, SRRrung2, SRRrung3,     adcLbinprob, SRX0,     SRX0, adcLabstractLD, stream4_unshare, stream} //64 
}; 


but q. such as what is DAC, what is ADC (seperate outers for these?) - leave these unset except for say first few modes: RESET/SET all to base!

too many: ALL to set spdmode, bitmode, length, adc, dac, cvsources, inner mdoes

** 11/8/2022

*think more on feedbacks - of SR bits onto all aspects eg.choice of ext/int*

*use in outer modes esp. TAIL:  &gate[0].dac, &gate[1].dac, &gate[2].dac, &gate[3].dac, &CV[x], &CVL[x], &ADCin, &Gshift_[0], &Gshift_[1], &Gshift_[2], &Gshift_[3], &clksr_[x], &param[x], &Gshift_[8] // TAIL!*

create areas of modes and detachments: what the possibilities are...

- *TODO: re-think Cv attachment:*
-                attach and detach - add, subtract but how? add/sub from an array
                 *return to pointers but need double up - pointer and value - we have example of this: SR_geomantic_outer1attach but is more complex - figure out*

- options attach say DAC and stays there, when we enter new mode &CV // or last value stays there when we enter new mode

///

- DONE: test new spdfracs: 2,3,4, 

adding new rungler and splits - seems to work well - split so binr is full speed and osc/fliflop at other spds

//

DONE: checked speed cv (C) with 1v source so confirm:

logspeed[] is 15 octaves: slowest speed measured with speedtest now is 1Hz -> 16Khz

*We will have 100k cv in, 22k feedback, 66.5k -10knob - for testing on modeC we have R65 as 66.5k, R71 as 22K* // see sheet/list

** 10/8/2022

*geomantic: gate[w].matrix[10]=(gate[dacfrom[daccount][w]].dac+CVL[w])&4095; // detach this too // or rather one new form of re-attachment - we can also use value functions here!! // another layer of attach*
///but is temporary attachment

attachment can be a list, or fixed array of 2 and bumps one off...

foreseeable issues: if we are left with a probmode but no CV - then is fixed or always have one in reserve just in case eg. dac... // *how we can use hanging probs to our advantage?*

- DONEtesting/fixing speedfromnew functions - some fixed/others unused (bitsnot, zpulsebits) but realise we need both strobe and general flag for free CV speed CV[x] TODO// 
for functions which don't use depth

- TODO:so now we need to set strobed in functions again/take care of strobey and strobe/trigger pulse in

- DONE:test transition params -> fixed/unfixed scheme - test mid-transition//working


- if we keep to 16/16/16-strobe/16meta scheme
- intersperse fixed and free modes...

- further on - *if we can attach DAC/mix with CV // add and subtract live*

** 9/8/2022

// 9/8/2022 - DONEalso prototype //how to resolve dialing across setting all inbetween variables - TEST: if (mode[w]==oldmode[w] // will depend on timings - we already have changed
//other forms of slur eg. only set these on strobe or pull speed into this one... but would need to match inner
// well inner would need to be called from here and we would call a null inner!
// explore these possibilities

- also as *slurrings!* slurred by external speed, delay of "modes assignment" // how to build layers of speed feedback

other ways - bump by CVM (move forwards - but again where do we stop?), by strobe, strobe can also do settings

- *blank modes which dont fill all gaps but allow others to fill these*


** 8/8/2022

- *test and catalogue geogens... and new exp_port.h - focus a bit more on strobes and toggles... also need to fill in missing ghost modes*

// have test outer function - try different arrays of functions for:
DONE-speed: fix fake strobe for tests... but we need strobe and interpoll arrays - proof of concept and deal with/test later

-bits
-prob
-adc
+ port/test

** 7/8/2022

- added inner function setting into outer function (if need be) - but does that mean we need to seperate adc w==0 versions of both (and what of dac settings)?

DONE:clean up modes.h internals and strip down geomantic.h to focus on new one

first 16 basic outers/"modes":
fixed:
- basic binroute/pass in
- classic TM and other SR - prob modes
- runglers
[which ones still resetr, and/or set all params/cvs with no gaps]

then expand out, also some modes which just maintain CVs, don't change modes // what defines a mode? speedfunc/bitfunc/probfunc

*-- how it starts to slip away?*

DONE: added set of internal function in outer but then we need 2 sets of outers for adc/noadc - do we also make distinction for dac

** 6/8/2022

- 64 modes on mode knob: from fixed/fixed to fixed/unfixed, to
  flexible to recursions and ops on local/global routes and counts, www order etc.
  (how much we reset of these in earlier modes)

divide up 16x4
- 16: level 1: set base functions/matrix. RESETR? - mix of CV/DAC etc onto CVs?
- 16: level 2: CVs change base functions: speed/prob/bit/adc/dac - mix of CV/DAC etc onto CVs?
- 16: level 3: resursion eg. DAC/SR changes base functions. how? or local/global recursions/influences and changes 
- 16: level 4: meta-level of recursion. work through/recur onto geomantics. 

where we deal with tail? start to sketch this... but do we need so many seperate functions???

DONE: how then we select inner index? also as a kind of attachment -- or inner is selected by outer?// called there??? so it lurks

- ADDED - meta-outer/meta-inner functions - lists of these according to mode // do we need these or is too much meta? // that we can just use mode[www] to select

meta means we can manipulate eg. walk through geo modes,,,

** 5/8/2022

- framework and how modes are selected

DONE: add prob bit, one cv and alt function

DONE- factor adc out so we have different internals for w==0, and maybe start to make lists of these

1 - how we select int/ext - feedback and recursion here...
or/on that relation... 

index into selection [or interior recursion: int in int/ext in ext/ext in int/int in ext

2- prob and single bit/s also as value-> bits

** 4/8/2022

*DONEagain if prob/strobe/toggle for a bit should be abstracted out in new scheme - also flipflop as faked strobe which could be OR/XORed with real one somehow - not if is a 1*

*can we call inner geo from inner geo?*

TODO: from/for ADC from N: parallels, drafts (slidings), multiple ins, TM in TM, adcflip, other TMs

////////////////////////////

look also at older catalogues esp for adc and abstracts

uint32_t adclist[32]={0,1,2,3,4,5,6,7,8,22,23,25,26,27,30,68,71,72,73,74,75,76,77,78,79,80,81,82,1010,22,23,25};

// longer sel with strobes and cv but we can only access this from detached CV/speed and length
// we have CV (speed) and CVL (length) - one is param, other is sel so
// so length or speed can be from DAC only or is detached
uint8_t seladc[63]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,75,76,21,81,82,77,78,79,80,22,23,24,25,26,27,28,29,30,31,101,64,65,66,67,68,71,72,73,74, 0,1,2,3,4,5,6,7,25,26,27,29,30}; //6 bits
// padded out to 64 with favoured ones - not used so far! - also many new modes since then

// have longer list of 64 with no strobes/no otherpar

// check where we use these and expand them!

uint8_t parammodes[16]={17,18,19,20, 21,22,29,33, 34,35,37,38, 39,66,67,68}; // preferred modes with param[w] as param

uint8_t modes16[16]={0,1,2,3,4,6,101,32,82,75,81,28,29,30,79,80}; // choose again maybe temp list TODO

uint8_t dacmodes[16]={25,26,27,71,72,73,74,75,  77,78,79,80,86,88,91,105};

uint8_t strobemodes[16]={8,9,10,11, 12,13,14,15, 16,24,28,31, 87,96,98,99};

////////////////////////////

// could outer modes also change/shift on inner modes???

- added splits and GSHIFTNOS_ for inner geomantics, could also be different OUTS: what these are? vxor

*what stack and recur could be??? for inner and for outer?*

*add in interpol and any/what details?*
 
to handle adc prob as new inner or as other generic function?DONEas inner ... - but only relevant for top one (maybe only call there)
       
*ADC work: eg. adcpad, hold etc.*

- finish rest of ports, full arch and plan!

** 3/8/2022

//TODO: finish ports NLRC extracts and start to catalogue:

// that catalogues can also be kind of matrices, with holes and exceptions... used by different interpreters eg. speedfromnostrobe, speedfromabstract, speedfromroutes

Inner/interpreter: of what any OUTER can offer... ]- basic, splitspeeds, stack/recur
Outer/meta: for INNER...                          ]- basics, stack/recur

again aganst value->bit // adc 
             bit->value //  dac // outer // why?

// trial INNER - but for now is just another matrix op/array/could also be stack so we need to do more inside it! it does allow us to leave elements remaining...
// we could have stack with index an mark unchanging as what? - as top bit of 32 bits

- now porting in from experiment.h via extract_exp.h - we also need to port/work through some ADCs (as ADC_, we have ported all functions)

eg. adcpad, hold etc *we also need probs for adc in! should we have abstracted out prob or...* // *adc in or....what? as cycle is in next round?*

gshift/recurs:  gate[w].shift_=gate[w].shift_<<(abstractbitstreamslong[gsfr](par0[w], w)); // shift or not

*question of dacbus, and SRghost, SRghostlatch*

*recheck:   tmp=binroute[count][wh]|binary[wh] is in ported examples/replace // also different varieties of binroute?*

toggles also we add back in...

*NEW PLAN:*
- port/expand/order-classify functions into lists
- fill in model, what int and ext functions can be 
- details

//  bitn=adconebitsreset(CVL[w],w);

** 2/8/2022

- new inner and outer scheme but dotail->basictail leaks/overwrites SRlengthFIXED

** 1/8/2022

*ramble:*

old detachlen ideas comeback....

to rethink:

internal/external // eg. ordering is external

each SR is a value/set of bits with parameters->[eg. speed and length, route] with incoming bits and outputs (bits->values, bits->pulses)

with ADC in for all, with 3x CVs for each, 1x clock in, and some pulse ins LR

a process with infinite set of possible interactions

interpreters:
// bits->value DAC -> params
// value->bits ADC -> SR/itself...other

arbitrary value->bits: route is a value -> bits, route can be bits->bits

bitfunc[value]->bits etc... arbitrary but a conversion

//fspeed, flength, fadc, fbit, fdac,  fnew, fout, gs, out // fnew is parameter function // fout outside
//1       2        3     4     5     6     7     8   9

fnew becomes TAIL
flength, fout, gs and out seperate out...

length is cv, foutX, gs is index from func, out is ...

leaves speed, adc, bit, dac // 4 functions/layers

QUESTIONS: specificity of modes/routes (N as ADC), use of CVM(internal ext, major.minor.), lack of CV/controls eg. for TAIL . which TAIL function, TAIL speed is set by what?

eg.
spd CV
length CVL
adcsel/dacsel and value - x4 we need / 2x
bitsel - DAC or... old CVL

notes: length is more essential as a changing parameter, speed as fixed... // if we can free up CVM...

speed: function. value/s
bit: function. value/s
length: value
adc/dac: function. value (as length)

CV, CVM, CVL... 

speed: value
bit/adc/dac: value/length = length: value held or otherwise...

// set and hold - how we hold - when we change modes we record oldcvs!

4 different INTERPRETERS: what they could be?

table and index: all CVs, values accessible (as CVlist but that is divided and also repeats):

{&nulll, &gate[0].dac, &gate[1].dac, &gate[2].dac, &gate[3].dac, //5

&CV[0], &CVL[0], &CVM[0], x4 //12.17

&ADCin, &Gshift_[0], &Gshift_[1], &Gshift_[2], &Gshift_[3], //5.22

&clksr_[0], &param[0], x4 //8.30

&Gshift_[8], 31

&gate[0].oldcv, &gate[0].oldcvl, &gate[0].oldcvm} x4 12/43 43 TOTAL CVs

binroutetypes - what are other globals? LIST: count/binroute, daccount/dacfrom, binary[x]  

4x generic functions: adc, dac, bit, spd: adcsel, dacsel, gensel, speedsel

adcN, dacC 
CLRN: gen, speed // select and attach... how

CV, CVL, CVM?, 

bit->value
value->bit

// if modechanged pop new mode (on trigger or other sign?)

- *we need a plan to finish!*

- simple architecture is still missing, all depends on CVM internal/external

interior and meta functions - all interior by way of reduced matrix (or not)

META: a set of interpreters and recursions (are say changes to global routes and binary also thus - but could also be interior?)

INTERIOR: bit and other functions from geogen.h and ports

how we select and influence meta functions (only by reducing modeR)

or refine to matrix and expand from there - new functions...

//////REALISED:
- that we can't use PUSH for CV-led changes (as will push all as we turn knob/cv!) - we *can* use pulses or some timing scheme...

// re-write push/pop as series of matrices with direct refs:

*speedfuncindex, CV1, CV2(unusedmostly), bitfuncindex, CV1, CV2(unusedmostly), lengthindex(into CVlist) - these are in stack...*
[gshift and out are set by function index so we need to keep track of this]

{2, &CV[0], &nulll, 2, &CVL[0], &nulll, &CVL[0]} // values and pointers, or even just names of function pointers so we don't lookup ...
// spd             ,bit               , len      

or:
{&spdfrac, &CV[0], &nulll, &binroutfixed, &CVL[0], &nulll, &CVL[0]} // and adcindex

what of dac though // add this

// still need to resolve CVM on all sides - how to match modeR functions interior and exterior...

basics:
- matrix/control as in above stack or otherwise // generic and base functions to port/list...
- tail as a parameter (runs seperate to modeR but how to control it?)

TAIL runs at speed X

** 30/7/2022

-PUSH issues above/// all of stack as single structure with push pop and peek - same index (but is that a good thing?) // we didn't finish that

** 29/7/2022

*descending depths of functions - generic stack depth of generic functions*

- break down to functions/generic-macro functions: processors, generators(routes).. probability is a processor-> takes a value and returns a bit 
and meta-functions on modeR CVM recursion...

bit->value (dac): can be timed with various sample/holds we have in DAC_ function.

what other bit->value functions there are? checked geogen: routevalue (SR value from route) so is more value from value

value->bit (adc/probability): spread out in space (multiple bits into own or other SRs, SRs as contiguous)  or in time (as for adc timed entry

- order/port functions

- modeR functions which deal with matrix/own functions - defer CVM to select own function but these cannot include CVM as a parameter...

*notes that our geogen.h adc functions share counters and bits if used by different SRs*

*CVM as question still - how we co-ordinate mixed uses - it cannot be inside and outside or?*
///// *notion of inside and outside could be revealing - also ref to geomancy // internal/external*

// also if local cvm changes local mode and modeR changes global mode
what happens to cvm? or cvm is always a local parameter but has no CV (good for selecting generic options only)

then deal with details (including also oldcvm, oldcv, holding of speeds/length etc.)

*param as tail! to replace in cvlist // where we execute the tail -- is tail also a stack?*

so we have: *speedfuncindex, CV1, CV2(unusedmostly), bitfuncindex, CV1, CV2(unusedmostly), lengthindex(into CVlist) - these are in stack...*
[gshift and out are set by function index so we need to keep track of this]

how we deal with adc???, length is index into CVlist, adc is adcindex for each one...
how we deal with gshifts and outs (if out changes much)... 
gshifts can be important for staggerings - gshift as limited cases set by function (which comes after or we maintain an index when we change modes)

*remind of timed entry/exit into stack (as a modeR function). recur on stack ops/ SR moves stack up or down or provides timing*

** 28/7/2022

*tail maybe as param SR! YES*

- new simplifications and new model with stack in geomantic.h WORKING in part

how we can move forward with that model...

1.move outside, gshift, think about length ops (how?), [newfunc and par?]
2.attach function on entry into new function counter (stack of these - how we can code stack?)

** 27/7/2022

// *how we can start to think (and list these kind of recursions or ideas) - of overlays of dacs/cvs - bus or mix rather than fixed and how an SR can perform this mix ITSELF dacbus mode/function*

OR NOT - as we can do base modes in matrices and have more flexibility???

but question was that we had to slow down main.c speed for full geomantic // *how can we speed up???*

- Tending to return to base modes (edited) with some use of latest generics:

if so:

- +basic trial...WORKING (without modeNetc)+

- clean up and cut down
- keep recursions and add new stack ideas

- port in generic ops from matrices.. what else? lastspeed, holds
- matrix as function???
- port in new functions: prob within ADC, what else?
- stack and previous functions/timings
- question of memory - 64 modes each side

what was layout we have of 8/8/8/8CVspeed 8/8DACspeed 8/8 strobe or just last 8 strobe...?

** 26/7/2022

*BINROUTEalt...: non-destructive*

TODO: test latest new codes eg.  loopback par (cvmod), bitsmod, TESToutside modes such as delay (add delayoutDONE), - not so exciting as no param (see delay_line_shared) but doesn't crash

- extracting function bodies with emacs macro - but leaves ints DONE
- added loopback -> par so cv selects cv -> cvmod

*0- decide on model: how easy can we write and decode matrices?* code to encode//decode matrices...

we have python script but how do we decide on endless range of oldCV, CVs etc...
how do we signal which functions take dual cv 

all adcs take IN, some comps, some spd: spd takes IN as modifier for cv or otherwise speed

///////

1- port extracted functions into geogen and notate matrices as we do this

adc, dac, bits/routes/probs, special, changingSRetc-outsides, gshifts, finaldacs/outs, values

more generic selection functions - more adc/dac/routes etc. and each one has generic selection

*more probs*

2- *do we cover all basic SR models? including runglers, probs?*

2.5- start to organise matrices... // list and document modes

3- move on to recursion and major modes // how we organise CVM inside and outside

4- resolve speed, strobe, and all pulses and general issues

5- clean up and test


** 25/7/2022

*recursion/disarticulated*

// re-work eg. vienna_minor for geomantic modes -> as speed and bitmodesDONE, 
try more advanced and also implement outside function/null TODO

DONEwe need to add in gshift functions and final dac/out ones too - so 2 more funcs but no extra cvs i think

- added in extra OUTSIDE function for a bitn/or modifying function outside the speed/implement and TEST!

- OUTSIDEs should be paired with INSIDE bit functions and with gshifts/out functions

- for C,L,N, CVM is INSIDE the mode as a local or global parameter
- for R CVM is outside as a mode determiner - eg. major mode, shift of matrix, type of geomantic mode ...

models for former sets of modes// eg. in experiment.h:

void base(uint8_t w){ // basic template // null
  HEAD;
  if (speedf_[w]!=LOWEST){
  CVOPEN;
  if(gate[w].last_time<gate[w].int_time)      {
    GSHIFT_;
    BINROUTE_; 
    BITN_AND_OUTV_;
    ENDER;
  }
  }
}

** 21/7/2022 

*matrix mode which +can encapsulate former modes+ also all the adc/dac types we had there*

//should be able to use adc/dac -> static inline int ADC_(uint32_t reg, uint32_t length, uint32_t type, uint32_t strobe, uint32_t regg, uint32_t otherpar, uint32_t *SR){
//question of 2nd reg -> from dacfrom

but former modes would need different geomantic/not doable - ways in which these could be ported???

// focus on basics/most generic -> need to take stock of what we have


*a study in recursion*

recursion is a process

SRx determines route SRy to give value to determine route SRz to  ... value from route...

//return a value from bits (this is what dacs do)... process a value... generate a value (eg. from a route)//

types of recursion... nesting, counted//

to identify points of recursion, recurse and return up the stack...
change its own mode and return to original mode...

*[mode] determines [new mode] - timed/triggered? return to [mode] - within modeR - and that timing can be from SRx*

////

disarticulation means no major modes // itself not itself/others 

** 20/7/2022

*Qs:*
- use of CVM and modeR side/major modes...

- q of gens which use CV/value or not? all use depth but not in which
  is cvbitcomp: gensel uses in and a few others, also for spd but not
  many at all... so how can we generate matrices if functions use it or not... or function dictates values/??

- how we can port functions to geogens/geomanticxx if they use speed
  in different ways (eg. functions which run at full speed, different
  types of gshift, multiple speeds (if necessary)

- that we have so many older functions which maybe can't directly port into one geomanticxx function, how to combine models?

what can be taken from one model to the other...

** 19/7/2022 after break

how we can break down more into tasks and not all so general

  eg. python code to generate matrices: but question of which functions use which values, possible generic functions and
  new recursions, functions for order of SRs 0123, porting of functions, stack functions, 5th tail, how
  we can interfere and disarticulate matrices, new geomantic function sketches eg. for split speeds...

  and then using insights from these start to resolve structure eg. if
  we have more general geomantic functions and not just the
  geomanticxx

resolve structure: 

*how we can slide modes across each mode - more simple mixed with complex - comes down to if we use CVM as a simple parameter or as selector!*

*and/or somehow individual strange loops and recursions with CVM and dacs as a selector also*

- how
- functions which play with matrices but then we need to restore matrices, entry of SR into matrices...
- mode0 as basic reset and just most basic route in... - resets itself or is just modeR
- order and how we change order of ops (in modeR? again modeR question)
- if we can split across different major modes (if there are 4 major modes?) = 4x16param
- major modes including geomantic or not - or all is in geomantic - what modeR does (global bumps, mods etc. check)
- idea of attach/detach but not sure how this works?
- stack prototypes: how we can simplify matrix, 
- freeze on entry. entry and exit of functions as key - how this could change geomanticxx 
- what needs to be done concretely???
- how can we enter into the matrix/grid of parameters...
- *how we could generate matrices which use CVM (we do funcs by hand but we need to know which use CVs, multiple CVs)

- other/older TODOs/sketches:
ew routeprobs to use//can also have adcprobs with depth -> prob of cycle, prob of hold last value etc... TRIAL in new geogen/adc - in progress

MATRICES:

func matrix: eg. 1,1,0,60,0,0 // gate[0].func[x][y] (we copy in from funcNN say)

X:6 fspeed, flength, fadc, fbit, fdac, fnew

Y:64? lists of functions depend on X but say max 64// 6 bits

CV matrix: eg. 5,0,6,0,6,0,0,0,0 // gate[0].cv[x][y]

X:9 (index) cvspeed, cvspeedmod, cvlength, cvdac, cvadc, cvadcIN,  cvbit, cvbitcomp, cvnew

Y:19   {&nulll, &gate[0].dac, &gate[1].dac, &gate[2].dac, &gate[3].dac, &CV[0], &CVL[0], &CVM[0], &ADCin, &Gshift_[0], &Gshift_[1], &Gshift_[2], &Gshift_[3], &clksr_[0], &param[0], &gate[0].par, &gate[0].oldcv, &gate[0].oldcvl, &gate[0].oldcvm} 

/// *CVlist[w][gate[w].cv[gate[w].cvcnt][cvspeed] - each has its own count

stack of matrices=15 numbers (15x6/or/8 bits) vs. SR which is 32 bits 

15x64x4=4k

but if we change the matrices we need to copy back in (function 0 as a reset)! // *journey on from function 0*
// fixed matrices, variable matrices

** 7/7/2022

do we have major modes with geomantic as one of these. what are the approaches:

1-vienna/all is bits?
2-more advanced bitmodes - all is bits
3-classics/basic functions/modes 
4-geomantic/advanced

- fixed [matrix] modes vs flexible matrix modes // funcs which use cv
  to select or oldcv -> we have these already as generic funcs but
  what about feedback of dac on to these (as a new function)

*attach a function/cv, leave it there - new model...*

functions which do the attaching/detaching... // attached... 

1spdfunc
2lengthfunc
3adcfunc
4parfunc
5bitfunc

- how to increment complexity, still haven't really defined stack

sr as stack, parameters as stack, matrix as stack (simplified)... - copy into and generate local matrices

how we can overlay SR on to matrix stack???

** 6/7/2022

we need to fix clksr and gclksr spdfuncs//fixed

- draft: scheme to hold speedfunc and values (for how long, how to hold, hold on exit/entry)

*???* DONE to some extent - to TEST speedselcvm is 11 - but that cannot use a held value for sel as is fixed as cvm/lastcv ->oldcvm etc.

// so we set speedfunc in a function then hold it when we leave...
// implies was set by a CV rather than matrix...

eg. gate[0].func[x][0] is speedfunc - x can be area we reserve for overwriting or...

or can we have old values in cv array/copy in = but for funcs too - but if generic func uses CVL, CVM or... gate[x].oldcv oldcvl, oldcvm TRIAL!!

///try/sketch...

how do we hold eg. if we use CVL and oldCVL at same time - old one is the one when we entered the function which uses oldCVL
DONE as saving as oldcv on a change in local cvcnt or in function/which????

DONE:cvcount becomes part of gate[x] so each one has one and is untied from funcs - *funcs could also have own count?*

*more flexible way of handling - see below, how there can be room for variation, also how an advance through modeR/matrices becomes more complex in terms of recursion*

or we have geomantic for holdings/..

[- vienna mode on x,y fades across new modes, stack/fade/heap]

KEYS:
- tail as 5th mode or modeR
- ghosts/GSR/ghost for someone else
- disarticulation - what this means - that parts become flexible/open - how this can work with our matrices that certain params are on hold or are open to influences

what part of matrix needs to be open - how to make substitutes?

- stack in time
- detach/attach of params
- routes to frozen params???? - if we use X for process Y then freeze old X as param Z ???

eg. if we use CVM then freeze old CVM as another param... 

*freeze on entry. entry and exit of functions as key*

- switch/bump/jump - on trigger, on bit 1/0, on x bits as say a value (eg 4 bits as 0b1111)
- probability
- all is bits
- routes
- 4 layers

** 5/7/2022

STILL thinking on general architecture//fill in more adcs//more geogen functions/how much to integrate with older code?

what are possible architectures to sketch?

// there are routes/there are functions/adc/dac...

- single geomantic with all matrices manipulated by modeR
- more geo functions as above with matrices and modes manipulated by modeR
- mix with older functions as above

- *maybe 4 layers somehow for 4 possible routes in and their logics*

- strobe and speed on which modeN/L/R/C?  // where to place/assign?

- recursive - hold CVx on stack when we enter recursion?

- new idea of timed stacks of functions which can recur.... SR is a stack...

//////

- added extra function for modifying SR/things and generating params eg. so can also modify SR a la cvbits

- if we want function to generate a param (we have only own gshift) - but that function needs params...
eg. binroute generates route for a binroute... [can that be circular?] // in another geomanticx ?

- how to think about disarticulation - if we dis-articulate ourselves
  (means also all modeR can't use CVM is we go for that scheme)...

N is disarticulated by [L,R,C] which is disarticulated by [x,x,x]

- stack model with timing... do X for time Y (new param)... 

double for R: itself determined by matrix and determining other matrices/slippage...

question of matrices AND function(other geomantic functions)...

also if we always have CVM for adc in modeN???

-  how to generate more matrices...

- override of dacfrom is in matrices?????

** 4/7/2022

- finished wrapping DAC - TESTED

** 1/7/2022

TODO below.

- DONEseperate out function and CV matrix//DONE

- how we have matrix select by CVM when/if matrix has cvm within it - seperate matrix sets???

- permute matrices so is always CV,M,L???

** 30/6/2022

- maybe 4 layers somehow for 4 possible routes in and their logics

- do we just have one geomanticx function?

DONE:decide on speeds so we can make divider changes on hardware -> 15 octaves now in resources.h

*twisted, dis-articulating algorithmic, worming, segmented body without organs/modes*

- how that works with CVM and major modes... articulations?

- SR shifts modes on, cv moves on

meta-modes manipulate geomanticx modes - move on count... sets of geomanticx modes...

- *how we will use stack? matrices is also some kind of stack - a stack of unattached values? - which can be SRs or GSRs -- push/pop. a state. a place to return to*
- *place or point in matrix*

how we fix something on to the stack?

** 29/6/2022

*// organism without modes, a body without organs, ultimate recursions///* - changes to counts, global local and interior modes/layers

each sr as a layer.mode

arch: CVM/modes, all around geomantic or.... layers, tails, small changes in matrices

matrix indicators of range/what can change....

layerings: stacks of values for each SR

open questions: range of speeds in - what we really need is speedx, offset and constraint but that is 3x cv/dac etc and function has IN
or we use dacfrom/spdfrom??? spdfrac3 now... 

fill in from all functions now - also more about concepts, divide into abstract, routing etc. functions, also more length/value functions... (such as?)

//// skewing of counts, that mode0 in groups (if we have groups - still need decide how geomantic and matrices are used) resets all counts, length etc...

countbits dac mode doesn;t work - retest // works in test2.c but -> DONE: reverted to large array

*we need to fix on total architecture and then fill in gaps - major modes with use of CVM always or...*

*how to permute smaller changes in matrices - eg. change of dac/etc*

// do we have major/counter mode on R or just change counters there... // but then what of use of CVM ???


*if we decide to CVM then we need to use it ALWAYS - in all modes but do we use modeR seperately as groupsel:*

eg.
modeN: type of ADC or bits
modeL: free/bits or...
modeC: type of DAC
modeR: free/unused/???

TODO:

- more modes/functions in geogen and port over special/experimental modes into geomantic if possible// more adc and other modes - see notes

- sync and manipulation of cnts, recursion and cv entry into cnts, local and global..


- mode as parameter in geomantic -> CVM, but we need different functions for this... other forms of geoxxx
- how we can use python to generate matrices// max array
- how we can manipulate matrices (as X,Y) - recursion onto?
- how much can be converted to geo.h terms, special functions to convert

add in special functions, more adcs

holdovers/stacks/lingerings, pushes and pops on to a stack

recursion:

how to encapsulate recursion, it is arbitrary, how to leave x running and recur, how recursion doesn't reset function which defines it

** 28/6/2022

- SR_geomanticx with new notation for modes/groups/cv which can be better dealt with, maybe even use python to generate

- *new model seems ok, how we can implement recursions and also leave some params open to cv, etc...*

// *also modify so we can use mode knob now as parameter for non-continuity*

// so there will be different geomanticx functions //

** 27/6/2022

geogen.h - what else we have so far?

- *we decide on major/grouped modes - base some on geomantic.h*

To resolve:

- is R tail or do we have extra tail?
- what special modes we have (from all modes?)
- what discrete parameters we have?
- how far can we go with geomantic mode?
- overlays of runglers and notation/rungler in geomantic.h // plus how we can easier notate matrices?
- try global manipulation modes
- new order of operations eg. 0,0,1,2,3 - how we modify this and is global - what are global constraints?
- new use of held speed: LASTSPEED macro and lastspd to hold.../how we deal with speed in general? 

TODO:
DONEingeo1/ rungler with probability - break down rungler into basics -> added binroutfixed_prob functions so we can describe runglers in geo...h

TESTED/DONE2/ mix of routed in dacs - what mixes do we have already? - all with adc, so we need to mix 2 dacs - own and other/daccfrom using param - as new dac mode...
as dac case 24: we need to TEST - need solid framework from geomantic.h

3/ new speed mode where strobe/dac sets speed of CV in - eg. CVspeed so CV in is more discontinuous

as special modes... on top of geomantic? how?

4/ circulation of top of rungler routes - again do in geo as altroutes...... subroutes which we can enter or???

fill in:

N L C R
{0,0,8,1}
{0,8,2,0}
{2,0,1,0}
{2,0,1,0}
{0,0,8,2}
{0,1,2,0}

- how we can shift rungler towards more generic code -> geomantic.h - just define sets of matrices and test these...

rungler is defined by: bitrouting, spdrouting/offset, bitfunction/adc

     bitroute // spdroute // function
0 1 N - none  // 8        // bits/osc 
1 2 L - as above
2 4 C - 1    //  2        // prob in/cycle
3 8 R - 4    // none/cv   // prob in/cycle

*TODO: new routeprobs to use//can also have adcprobs with depth -> prob of cycle, prob of hold last value etc...*

** 18/6/2022

- fixed major bug/overflow access into speedlog in modeN.h/runglers... check for more of these...DONE and fixed across multiple files...

** 17/6/2022

- we try to cram in functions into groups but running out of FLASH space so:
-- -Os and other Makefile/gcc optimisations, cutting countbts and logspeedd arrays...

with all crammed in randomly crashes sometimes -> reverted back to limited first set of grouped functions

// tried with just exp modes and one of those is crashing...

//Qs/reflections: we need to know where strobe is really in use as speed so can't be so generic
use of length for other params can be glitchy

- test functions???

** 16/6/2022

///JEKYLL/HYDE

- how can we mix major and minor modes (eg. vienna mode on top, rungler on side) - do they make sense like this?

[4 major modes/2 bits leaves 4 bits]

somehow we want to run parallel modes - as remnants, remains, layers, revenants, leftovers, palimpsest

SR as itself a layering - 16/32 layers

*secret of the tail? also here: - if we include Rmodes in generic then they can de-select themselves - so we cannot have this recursion, or is run as extra function/tail...*

----[but vienna mode is not so challenging]

- 16 geomantic figures

- record speed as distance/count between last 2 triggers (in struct) DONE: but how do we test this...

- geomantic.h is a mess:

recursion cannot include control

we just need generic speed, length, route[if needed]/binroutetype /adc/dac other types set globally

routing table is too complex - we need always a route in of either
speed, length or bits (eg. if modeC is just a generator the others are
redundant, but the others can be generators with no route in?)

*either we have as completely generic - dacbus/any can be dac/out - or we assign functions and constrain routes?*

constrained by: synced routing tables (in geo.h we have tables partly in the cv arrays which is a problem)

speedroute
lengthroute
binroute

should we have properties of each SR in struct: eg. index into functions?
so each SR has:
ADCtype index, DACtype
functions index

length is held or value (eg. CVL, DAC) so need to express more simply

what to do with all the mode functions we have...? re-wrap?

** 15/6/2022

- if we include Rmodes in generic then they can de-select themselves - so we cannot have this recursion, or is run as extra function/tail...
// but we need CVL and sometimes CV to select... how we can put these on hold - version where all is per SR TODO

// *how to implement right hand major modes in generic mode itself? or are these outside?*

- *TODO: binroutesel from a counter ?? but do we need to do select for all binroutes - or just put as functions...*

- realizing that latest scheme is now more like groups - groups of functions for each SR

matrices of functions, of CV/DAC allocations

- investigate recursion: promoting absolute generics for recursion
- how a generic function could look in the real world

what recursions new geomantic allows...? eg. selected SR bumps along matrices. matrix is an index of indexes/functions/cv?

** 14/6/2022

*- new abstraction to fill in/// how we could translate geomantic figures to that scheme*

minor vienna is just merge of binroute from CV and binroute from SR 

adding extra param for abstraction so we can deal with adcin! copied IN!

// *work on porting functions... matrices and histories of SRs and functions/foldbacks and in work on tails...*

DONE: geomantic.h - transfer all from exp to here...

clksr: re-test but wondering if should be inside our speed or just runs at full speed... TEST move clksr // DONE

** 13/6/2022

// question of new generic/geomantic modes as final for all ...

speed:
length:
bit:

adc/dac - if these use CV/otherDAC? how we free up selection if they
use CV also? or just ignore this, or we just have divisions/wrap them
but is a lot of work

for example there are: adcbitstreams, dacbitstreams which use depth as param which can be CV, CVL or dacfromx (not dacfrom in dacbitstream cases) 
dacbitstreams uses defdac... which is fixed as 3 - maybe change to ref - 

CV, CVL, DAC/SR


** 7/6/2022

how we could write matrices:

MATRIX of: speedfunc, lengthfunc, bitfunc // binroutetypes // whichdac, whichadc[none] //// routes-> speedfrom, binroute, dacfrom

but first we need to define what those functions are and whether it is hardcoded what they use (as in depth variable)?

- 16 cards = main modes x4 - fire/air/water/earth

- overlay DAC values???

- resolve split of DAC/CV for abstractbits etc.. - 2 different functions or???

*also how we resolve use of multiple CV eg. for adc modes which use CV - is there an indicator? eg. CVfree, CVLfree - set/reset by funcs*

// draft for cvfree, cvlfree??? we need to resolve use of CV, CVL and DACs...
// but how to use this: if cv is free use cv, if not is cvl free, use ...

// then we would need to select from say groups of modes which use certain params

we have: routed DAC, mix of DACs, bitmix of SRs, CV, CVL

CV: speed, if strobe for example then we have it free
CVL: length, if length is from elsewhere we have it free, or we just detach it

- *if both are free how do we make sure we use them?* and do we always need to do this?
- or does set up of matrices always not allow/allow this?

adc can use param[w] from clk or use cv/dac as param? is that built in or???
dac use can be tempered with cv or with held_over cv if we use it elsewhere...

should this be accounted for in set of geomantic functions/abstractions???

////

- test if spd and route can share same binroute (multiple)

adc/dac major Rmodes

** 6/6/2022

*PLAN: new generic scheme gives us 64 modes which don't need take account of speeds, length etc. as these are all in matrices set by 16 global modeRs*

*TODO: test, implement, genericise chosen modes/document and add pulse/trigger other points, decide on speed as: and wrap with new tail functions and stacks!*

// 5th tail to resolve and work into Rmodes (or generic modes)

*dacbitstreams we also have to use somewhere*

// how does binary thing work??? we take 4 bit mask from x bits of chosen SR and use this:     tmp=binroute[count][w]|binary[w];
// *so implement in speeddac functions as this* spd as bitfrom multiple dacs??? - we have that already

- adapt modes we have to generic speed:   if (speedfroms[speedfunc[spdfunccnt][w]](w)){ // speedfunc in abstraction

- test general globals abstraction we have now with adc which can be on LRCN any. indicate with non-null mode in matrix

- what those matrices look like?

- can also be locally set,,,,

x,y of globals need to match up (eg. in their use of CV) so we can only shift them in groups...
what needs to match and what doesn't

*questions: of dac in speedmodes always, of cv for use by dacmodes as param, all abstractbitstreams use depth*

** 4/6/2022

- 16 global modes on modeR
- *binary type thing from binroute extended also to speed???* generic speed/function - *speedbinary*

- possibly no subdivision of modes as to cv/dac speed but this is set in generic/tables...

- 16x 4 sets of modes so matches geomancy figures


** 3/6/2022

- make lists/extract for gen.h and longer adc lists...

- comment/extract and organise modes from:

experiment.h
bit.h
probability.h
modeC, N, L, R - what are repeats?
where else?

** 2/6/2022

*leave and don;t reset counts and routemask/binary*

*// do we want masks for other counts - new model eg. we have tmp=binroute[count][w]|binary - but we need size of mask/count?*

- also to try to integrate long encoded list of modes...

- as one of new global Rmodes, probability of shifting these counts /// also use CV/CVL to shift these

- could global spdcount/from also include strobe option // spdfrom dac/spdfrom bit as 2 distinct types

- add generators into adctypes

- more emphasis on Rmodes - can set type of binroute, final Rmode 63 resets all counts and types to 0, own modes can also set/reset these

count/route
daccount - which dac as param
spdcount - which dac as spd
tailcount - what is tail function?
adctypecount
dactypecount 

*and add binroutetypecount! redo generic/abstract models following this*

DONE: low pass before speed so runs at full speed and is fixed - newdac2 - but not so promising // decimation???

basis again...
1- if we have length/or/speed from SRX we don't necessarily need a route from SRX - exclusive OR

spdfrom X
routefrom x [xor] - tables or some op -> between speedfrom multiple routes (bits) or dac from one (or mix of dacs even/bus), how to generalise that

eg. bit is routefrom/or/spdfrom 

2- not to fixate on 4 routes. 
TM prob model of recursion/circulation - *TODO: prob of recursion on itself, prob across all SR*
Rungler has different routings

3- order can also change eg. 0012, to determine from a table... - but table must be longer than 3 so we always have, table is like an SR?
TESTED 14/6/2022 but maybe just complicates matters


- what is the length of that table? and it must have all routes in it.. how to generate this? compress table, operations on table

4-basicSR - it has length and speed [from sr], it can input[route,ADC,gen], it can cycle/types of binroute 

is type of binroute just part of input...
in our case basic SRs and basic GSRs?


** 1/6/2022

- param[w] is always from clock and handled in adcetc

- q of range of speeds and how that influences dacspeed feedback

- back to all minor modes with dacspeed on modeR - 16 global modes for: count(route), daccount, spdcount and tailcount // bump, recurse onto, CVonto
- also add in adctype and dactype with cleaned/tested lists of types

adclist was:

[check any params to pass in from modeN]

checking: 

add: 114, 90, 91, 93, 94, 106cv, 95, 99

// note these are lists for ADC_ - we have adc bit functions which are in: adcbitstreams:
uint32_t (*adcbitstreams[16])(uint32_t depth)={adcxbits, adcpadbits, adc12bits, adc8bits, adc4bits, adconebits, adceqbits, adcenergybits, adc12compbits, adc8compbits, adc4compbits, adccompbits, adc12onecompbits, adc8onecompbits, adc4onecompbits, adconecompbits};

there is also list of dacbitstreams[16]

uint32_t adclist[32]={0,1,2,3,4,5,6,7,8,22,23,25,26,27,30,68,71,72,73,74,75,76,77,78,79,80,81,82,1010,22,23,25};

uint8_t seladc[63]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,75,76,21,81,82,77,78,79,80,22,23,24,25,26,27,28,29,30,31,101,64,65,66,67,68,71,72,73,74, 0,1,2,3,4,5,6,7,25,26,27,29,30}; //6 bits

uint8_t parammodes[16]={17,18,19,20, 21,22,29,33, 34,35,37,38, 39,66,67,68}; // preferred modes with param[w] as param

uint8_t modes16[16]={0,1,2,3,4,6,101,32,82,75,81,28,29,30,79,80}; // choose again maybe temp list TODO

uint8_t dacmodes[16]={25,26,27,71,72,73,74,75,  77,78,79,80,86,88,91,105};

uint8_t strobemodes[16]={8,9,10,11, 12,13,14,15, 16,24,28,31, 87,96,98,99};

dacs was only 16 but now: we have 10 more

- DONEadded in dotail[tailcount])(); for tail - but should this be in www==4???

- or is tail the RSR itself????

- DONEfixedbitrunglers

** 31/5/2022

40,109 paths in firstpaths from paths.py

*how to integrate paths, stacks and new abstractions*

think more on holds of dac/adc types and length etc... so more of stack approach...

** 30/5/2022

- paths.py calculates all paths with constraints: there are around 40,000 combinations. each route is 4 bits, 4x4=16, so 80k storage

otherwise is 16x16x16x16 combo

what could be extra constraints? added in paths.py and in readpaths.py 31/5

- DONE: added more recursion options for major_vienna
added strobed in gate[w] struct for use with normed clocks, take care itself of bit

*TODO: how and where we implement 5th/8th tail SR?*

recurs-not-on-itself through recursion on not-on-itself

majors:
1-vienna/redux/recursion
2-sliding groups
3-modes+Rsideglobal mods
4-???bitmodes all... more generator style, all is bits and functions operating on bits

** 29/5/2022

major modes:

EXPLORING/IN PROGRESS...
1-vienna re-work: 4 bits route/speed, 1 bit strobe/prob (when strobe use CV/prob only), 1 or 2 bits recursion 

recursion: speedfrom (CV/none, self, other, other tempered with CV), in strobe recurse onto route temper with ownroute

2-runglers/classics

3-geomantic/with all is bits/stacks and recursion

4-classic TM modes/or/all is bits

notebook/notes:

- we can always do speedfrom by strobe bits manually
- TAIL: stack of modes (do we have this on exit/change), stack of
  values at speed (circulate), overlay whole caput d. on itself and
  feedback, recursion of previous stack (what it could have been).

*TODO: strobey is set by function itself*

** 27/5/2022

- still think on major/minor modes: 4x16 or 8x8 
1-vienna (with interpoll or not and R as tail -> see above)
2-runglers as matched/groups - expand options for these alongside some TM/typical SR/classics - slidings
3-mixed selection of modes
4-prob modes/classic TM etc
5-all is bits
6-mix of experimental new modes and traditional
others? dacbus model?

- wierdness with dac on srrrung0 (dac3) - bits run but no dac out, to do with delay in dacmode 30 -removed and runs well

DONE: generic rungler:

2 heads: generator, speedfrom body 
body: data from 1 head, speedfrom other
tails: routes from any above (we have)

generic: generator/or/data from one/speedfrom other (table) - not from itself...

eg.

0 - data from: 1,1 2,2 3,3
    speedfrom: 2,3 1,3 1,2

bitmode rungler: spd is binroute bits

** 26/5/2022

// how rungler can be more independent - not matched double and other. how double could be in itself

- fixed errors in runglers but sounds ok/maybe is just no movement: error in tmp being uint and in wrong spd entry - we left as is just fixed in rungler.h
- fixed crash in SR5_feedback

- Q of detach length in ADC/modeN as length is most important for SR incoming!

BINROUTE_, BINROUTEalt_, BINROUTEZERO_, BINROUTENOG_, BINROUTESR_, BINROUTESHARE_, none

0none1binroute_/2binroutesr_/3binroutealt/4zeroes/5shared/6nos, [7trigger, 8toggle]

basics to try against global changes:

N: 

- more on listening today: extract mode list from python, new caput
  main stripped file, new modes files (eg. collect runglers), how
  python can permute code, new TODO file, permute routes in python

-> cleaning code, python work, listening/coding, new files

- clean up adc/dac and gen.h (lists)

double/ghost: 
- how to do it fast= no speed calcs, simple route in, SR only/no GSR,
  how it can incorporate GSR (but GSR is a ghost for another),
  exchange with ghost, ghost controlled by another, maybe for tail
  only, other SRs or GSRs in layers... (what past layers we have recorded?)

runglers: see rungler.h

** 25/5/2022

// think on new models/new TODO

- tail/ghost modes
- global modes
- make more pairs

** takeaways/new: grouped modes and geomantics, tails and ghosts but how
to enter, record and SR of modes to work through, rungler collection,
binary for spdroute/spdcount, binroute/count and daccount, movement and timed change of modes is important

- added headc macro for modec speed/no freeze in basis.h
- adconebitsx for sigma/delta works ok - int32 version doesn't work so leave out from adcetc.h

- *sliding grouped modes notes:* 

0 0
 0
 0
 0 across modes / active/passive of past modes/overlay ???

we can also slide/offset into extra modes, matrix can also be subject
to SR, SR-like shift through group-modes, memory of movement back and
forth, recursion, sets of geomantic cards somehow fits here, can we fit templates/lists into the grid?

still we need to shift 600 modes inn

16 figures // 16 modules - each as predictive/python generated codeset

*TODO:*
// runglers without interpoll and with other options // what is routing there? also with different adc/gen options in head (not just osc) - see below
// clean up speeds and mess of:   if (w==2 || speedf_[w]!=2.0f){ // makes no sense
// clean up generators vs also adcin, dacouts - clean up interpols
// new global route/spdcount, daccount functions
// binary thing below
// take interpoll out of generic speedfroms into gen.h
// tail and new ghost modes - how that could work? how fast we make tail as needs run at full speed or run somehow as double
// modes which manipulate other SRs: how? swop SRs/opposing
// what are SRs which process bits? delays, delta: Srsigma, all SRs in most cases...
// extra sets of routes, spd, dacfrom

#define DACFROM (gate[dacfrom[daccount][w]].dac)
#define SRFROM (gate[dacfrom[daccount][w]].Gshift_[w])

use these macros always so we can do similar binary thing

in main.c divider of 21 gives us 1Hz to 16KHz max at 15 octaves
14 octs: 2HZ // 1.9 hz really // adjust divider accordingly

DONE: as would be nice to have global routes from SR but at present we just use arrays... - how to bridge this gap:*
OR in on 16th zero/count: done as SR_globalbin

eg.

tmp=binroute[count][w]|binary[w]; // and binary is 16 bits in 4 pieces...			
TODO: but would have to change all binroutes...


- place PULSIN_XOR in out macros - so clean that up
- deal with strobey and clean up - again in macros
- len and speed taken out and placed in macros
- global routes in modeR also as strobe and other speeds...
- for speedmodes we pull out interpol to make it cleaner

** 24/5/2022

modeR manipulations: for spdcount(speedfrom), count(binroute), daccount(dacfrom) - also used for lengthfrom

speedfrom
dacfrom
binroutefrom
lengthfrom

so that's 3 x 4 bits - we have 2x CV only

but modeR also needs to do its thing - everybody has dual functions! to provide, to get/route and/or to have a function

R- set of global routes eg. cut all routes on strobe, sync routes, bump routes etc. // what do we have already in modeR.h:

void SRRstroberoute(uint8_t w){ // zero global/cut all routes on trigger
void SRRglobalbump0(uint8_t w){ // bump dacroute and binroute
void SRRglobaldac0(uint8_t w){ // dac as global route table or could be SR as route bits but we need to fix that

we need: sync counts/routes, count/route from which dac/sr?, CV/CVL

there are 4 bits of routes x 4 // 65536 possibles so we can't have an array for these

gate[speedfrom[spdcount][w]].dac

////////////////////

DONE- if we treat all as bits then some CV should go into SRs as a mask - function for this 

////////////////////

// what if each routed in bit has different binroute options: again q of each route as a layer but needs ghost of its straightforward layer
// ie. if we have a chain of routes then all they do is route, we need split for each
// could this be the 00 0 of the active/passive geomantics

// so there is always ghost straight routed layer ... // *a residue*
// *but how do we put this to use...*

// start from scratch with basic modes and tail, modes for each side to complete and test

N: head/fire - in/adc/gens                    0 0 // 2 is passive
L: neck/air  - through/prob/placement          0 // active
R: body/water - out/dac                        0  *we need to zero counts in some modes... except global ones here*
C: feet/earth - feedback/dacinfluence/5th tail 0  *No freeze*

passive as routein, active as input/generator

tail as generator/processor eg. as integrator (SRsigma), as delay...
tail as what would have been/basic feedback

we can always have bit speeds and slow speeds from strobe.

importance of routes // function vs routes, fixed and generic eg. self-routing

*question is if we have free routing then adc can be dissolved/ not routed in... so better with coordinated*

speedfrom: bit/value
bitfrom: route/bit/gen-value
lengthfrom: CVL/DAC

route: 4 bits, type of binroute: 2 bits, of prob: x bits = x bits

basic modes: basic SR types, from permutations below:

spd as from major mode... but for strobe modes we have extra CV!

[LEN,   ROUTE]
1 ['DACx', 'genCV']
2 ['DACx', 'CV']
3 ['CV', 'fixed']
4 ['fixed', 'CV']
5 ['genCV', 'fixed']
6 ['CV', 'DACx']
7 ['genCV', 'DACx']
8 ['fixed', 'genCV']

// what about different binroutes in above... CV for length/route is only 4 bits also so we can use x bits for prob/binroute type

bit modes, prob modes, special modes, modes for each side...

individual routes, multiple routes, volatile/changing routes...

*again rungler model:*

x y
\ / 
 z
 |
zz tail R

x: genX, spdfrom z + offset // optional route in from zz
y: genX, spdfrom z + own offset // optional route in from zz
z: route in from x, spd from y + own offset // optional route in from zz- OUT?, it cycles
zz: tail. process of z and feedback to x, y or z.

translate into own setup:

x: N - spdfromC+CV offset, gen-CVL(param?), route in or not from R? (1 bit)  
y: L - spdfromC+CV offset, gen-CVL(param?), route in or not from R? (1 bit)  
z: C - spdfromL+CV offset, route in from x, route in or not from R? (1 bit)  
zz: R - tail/processor: CVL

+ extra tail

how we have routing in version here?

xy s LR, z is N (uses ADC as mod fo spd), C is daclrung0 - just choose route in from these and dacout/type

SR\Rrung0: L/R speed from N, OSC
SR\Rrungs: some same/just changes in speed - add new speed mod thing:

DONE:try with CV as -+ offset

make table for routings/speedfrom here...

q of generators with cv for select and cv for param

0 on binroute with no other route in?

///////////////////////////////////////////////////////

DONE:// last new modes: route from SR [4 bits]: route in can be 4 bits from one SR (shifting)// hold from GSR and shift on strobe

fixed SR for route bits: gate[dacfrom[count][w]].Gshift_[w]
CV chooses SR for route bits (only 4 SRs so 2 bits, or we route in/xor a 4 bit route)
CV chooses SR for route bits for SR for route bits

permuted modes/basic modes

// last notebook notes/trondheim:

- list of recursions/to list
- define as prob modes, bit modes, global/Rmodes, own route modes, special modes
- what are geomantic modes?

// extraction: extract from experiment.h, modeN.h, modeC.h, modeL.h, modeR.h, bit.h, probability.h, prob.h to extracted // DONE

// permutations: segpermute.py further work with types of binroute

// re-check for order: how many octaves defined...

14: slowest speed: resistors: feedback , -10v
15:
16:

// processors for bits in gen.h - for tail?
// how do different binroutes effect ringing speed sound...

*binroutes:*

0none1binroute_/2binroutesr_/3binroutealt/4zeroes/5shared/6nos, 7trigger, 8toggle//orOR

+ Gshiftswithin: no shift, shift on trigger [and choices/prob/toggle of these] - for binroute only

so becomes: 5+ 6nos, 7trigger, 8toggle - 3 bits and save prob for extra mode // prob of gshift

// check TODOs here...// below

** 19/5/2022

TODO:
- start to list/extract modes and categorise from files...

individual routes/one route in only // global or local
multiple routes                    // 

list types of binroute: 

1no binroute/2binroute_/3binroutesr_/4binroutealt/5zeroes 

+ shifts/no shift sharedgshift, shift on trigger [and choices/prob/toggle of these]

permute cases for each option: length, speed, bit/route... 

** 17/5/2022

*5th tail - so RSR has different function: tail as in TOAD also can be process like integration/delta*

*co-ordination of routes and DACs, eg. bitfrom/speedfrom same one???*
*SR as bitspeed/as DACspeed differentiate*
///

- done:how we could have layers rather than routes: routein is xor sieve and we can choose routes (q of route 0, now as tail)

void SR5_feedback(uint8_t w){ - is only model we have for 5th tail but it's speed is set by CVL which would mean always detaching it

- *still question of how to detach process for 5th tail* so all is not
  doing so much, how to signal that detach and move on - we can do on change of
  mode but then will just go through intermediate modes

- fixed for mode: type of gshift, type of binroute, type of interpoll - lots of permutations

+but what are types of gshift: no gshift, gshift and no <<sr, gshiftcopy only on strobe... no+

permutations of: 1spdfrom
                 2lengthfrom
		 3bitfrom/routefrom
		 4probfrom 

from: CV, CVL, DAC1-4, ADC, CLKSR/strobe, generators, 

also as spdfrom can be with modifiers eg. DAC%CV is a bit more complex (do that in functions)

layers:

-fixed type of interpol
-spdfrom->spdfrom functions
-lengthfrom
+-fixed type of gshift: what are they?+
-bitfrom - types of binroute are in functions
-probfrom
-dacs? 

///

4 slots-> pointers/or/generators_processors (generator can also just return value from pointer)

but spdfrom is a bit/function, length is value, route/bin is bit

*model for the above*

** 16/5/2022

still like idea from before:
*xx*
- *like idea of past modes still running/layered and changing params but how: or SR as selecting, running through modes, holding modes, operations ON modes*
- *params can also be shifted along, lag and delay as in SR but for values, or bit on/off selectors*

*a chain of modes cycling*

// *how we can leave running and detach (5th tail) so extra tail runs! as an extra mode which leaves off, departs*

back to basics/new file: entry of a bit at time x from y into SR of length z following logic zz // multiple entry/layers...

investigate different models// concept and sound (eg. ringing of slow into fast..)

1-4 layers always

1 basis/fixed for mode is type of gshift:
                          type of speed: bits(from), cv, strobe, dacspeed with modifiers
                               of binroute: no binroute/binroute_/binroutesr_/justcycle/binroutealt/zeroes and others (with shifts/no shifts etc) and choices/prob/toggle of these
                              [of logic]

TODO: trial now:::

- DONE;length from dac/lengthfrom also: speedfrom, routefrom, lengthfrom, logicfrom  - we also had SR->length in modeN

- DONEtrial faster one bit audio (no float) - but how fast can it be?

- how to downsample - run at full speed but drop samples? for dac? FIR filters... read up

// say we need run at 24x for 8khz would be 8x24=200oddKHz - what is fastest... nowhere close

- DONE extract headings to classify functions (python): extract.py matches our void prototype functions...

** 14/5/2022

- note that we can always have clock in as pulsin for lowest and route from independent ones... patching possible...

** 13/5/2022

TODO/notebook notes:


- DONE:alt binroute: //eg. we keep cycling in until we finish one length and there is a reset
void SR_altbin1(uint8_t w){ // 

- do we want to test one bit 4x over-sample into NSR, then feedback would be into LSR only...

- +sim.c shows that regular binroute messes samples through (as gshift copy will shift) when we go from slow to faster...+

- +maybe new GSHIFT_ with selective updates - can also be mask - eg. update last bit only+

+re-test for shiftsr/hold: is also same situation as no shift of gshift+

slower than route in: delaybuffer, slip/miss samples
faster than route in: hold/no <<gshift, cycle, shared cycle also, insert zero

** 12/5/2022

- added another binroute type as insert zero if we don't have a new bit DONE
- can also just follow last one... DONE

again how to advance here..

** 11/5/2022

basic choices:

- speedfrom: cv, binroute_etc, gens, dacs, follow route in resets
- no/interpoll/type of dacout 
- bitfrom:
- no binroute/binroute_/binroutesr_/justcycle/binroutealt and others (with shifts/no shifts etc) and choices/prob/toggle of these
- from adc/dac/gens etc.
- clckin, pulsin

*phasey sigma/delta fix?*



** 10/5/2022 - now back to 15octave speeds

- *fix up logspeed/slower and stops across all???*

- *resolve 5th tail*
- *how we can begin to finish*

- trial dacspeed with slowest speeds, what was reset/integrator in bitdspDONE, set own cycle length/cycle even if moves on

*noticing that if we use dacspeed then is double interpol - interpol at source, interpol on new speed*

*no new modes/finish abstract ones*

// from most basic upwards -> complex

- speed fromx, feed through, no gsr in/just sr -> generators/processors//complex insertions

- speed/gsr/bitn in/dacout/recurse

** 9/5/2022

- new CV calculations:

So now we have 16 octaves which are to be covered by knob (full range 3.3v)

-10vknob is x3 feedback

- 16 in 1024 = 64 per oct = 640 max = 2.0v max

10v->2v = 1/5th

*100k cv in, 20k feedback, 60k -10knob - so we just change 2 resistors*

*but maybe return to 14 or 15 octs*

// for 15 octs would be: 68 = 680 max = 2.19v
10v->2.19=4.56 22k feedback

14 octs above

// how slow is slowest now/test? - slowest is now 2 secs/2secs = 0.25 Hz -> 20 KHzaprrox 16KHz = 16 octaves...

changed r65 (66.5k not 60k), r71 on proto board - tested/seems ok but need 1v source defined...

- start maybe again with reduced modes and macros with new modes - to cover all options below// again grid of options

- again how to wrap up: what is new/options:

+1.new gshift/old gshift //for mix of we always need to reset/ add into what macro? into GSHIFTS_ -DONE+
// from plain sr through gshift to special gshift
2.all dacs interpol/no interpol
3.frozen or not - is that an option? or just keep with lowest frozen and slow speeds - or no freeze on NSR/out
4.use of clk/pulsin-xor
5.clean up so less macros and is a bit more general - also between interpol/direct dac access
6.detachment of CVs - take out of adcetc///
8.clkbit, other params
9.hold or toggle of pulsin/any processor of values...
10.is we use speedmodes then strobey is more complex

- *new abstractions to be checked out*

- *test speed modes: SR_selspeed*

** 6/5/2022

- grid and use null functions like SRzero, SRone to stop/start options -> more towards moods/modes

- DONE: try alt gshift which keeps intact gsr (cycle through but we need to signal reset) - also if dacs have nointerpol or not
[as gsr as we have it can be destructive if we change lengths]

** 5/5/2022

- *slower speeds to test without stoppings* TESTINGS
- draft new architectures

- mode which is delayed functions of last modes (modes as parameters/crosses/bits of yes/no), CVs which are delays of last CVs
- hold/freeze CV at one point in delay, vars updated on trigger

-difference between SR and delay line, stack of modes/of values/CV/CVL

 O O shift/no shift
  O  speedfrom x/y
  O  binroute/cycle
  O  logic/prob/in

- *5th tail: initiate a stream and keep this running and move on*

           | | 
tail switch V
            |

- *thinking on new arch: that modes initiate streams, channel and modify these rather than one stream per SR, so can be shared streams also*
// but how many streams run simultaneously, also seems go against main idea...

// I initiate and route streams to others 
as in CLRN are not identified with streams but control them, with their clocks for example...

lots of options: x controls and modes stream y, but z can change it for itself, or all streams can modify it, in turn...


** 4/5/2022

head fire C 1=one dot/active. 0=2 dots/passive. 
neck air L
body water R
feet earth N

each figure has active/passive lines for 4 layers - in the 4 elements

*if we can translate 16 figures straight from binary into modes?, or translate figures or... a language to translate - 4 bits interpreter*

//recursion/inversion/or not/// .. probability of recursion

*formalise 5th tail*

*more consistent - pulsin in closing macro, clkins etc..., detach CVs for later/length/speed, draft this as cleaner set of modes 
*- we can keep main, draftspeed and only change modes*

// speed up compile

** 3/5/2022

*xx*
- *like idea of past modes still running/layered and changing params but how: or SR as selecting, running through modes, holding modes, operations ON modes*
- *params can also be shifted along, lag and delay as in SR but for values, or bit on/off selectors*

*a chain of modes cycling*

// notes from notebook and new:

- also division of types between generators (create), routers, speedfrom/routefrom, and global changers/experimental
(as works well with just SRothers on RL and CN as simple! 

eg.
  {adc0}, 
  {SRothers}, // SRX0 is basic route/xor
  {dac0}, 
  {SRothers}

- check/re-check simple types from rung:
1.generators+speedfromX
2.binroute/from and cycle/speedfromX
3.binroute/outDAC (we have)
4.5th tail feedback within a binroute ///

- 16 cards x 4 = 4 x 16 geomantic figures/ 16 SR functions x4 - detach, strobe, dacspeed, normal / figures as models
eg. for split speeds, always 4 layers...
- copy/gshift
- speed of X
- route
- prob/in logic

or * * - gs/no gs
    *  - ?
    *  - bin/cycle
    *  - ?

*also how 4 layers combine -- 4 ** * * * - 4 cards, 4 layers of head, etc... earth etc...

- *chain of for each SR// how???*

1-if [x] bitfrom[y] 
2-if [if [x] bitfrom[y]] bitfrom[y]
3-if [if [if [x] bitfrom[y]] bitfrom[y]] bitfrom[y]
4-if [if [if [if [x] bitfrom[y]] bitfrom[y]] bitfrom[y]] bitfrom[y]

- code layers, depth, descent

- re-check latest processors. values->bits = adc, bits->values = dac, values IS SR made up of bits, but what values other than SR do we operate on!

- inversions/inverted recursion - eg. speedfrom itself fails but does it fail if inverted?

- *SRs which operate on/stuff/change other SRs directly and not just GSRS, do we have these eg. shift on SR if bitx, insert into sr, splice...*

- simple modes/complex modes/detached modes/speed modes/global modes

** 2/5/2022

- speedfrom x [vs] speedfrom[from[x]]
eg. speed from DAC or speed from [chosen by DAC]

speed as value/speed as trigger and translators between? (added value to bits processor)
xfrom x vs xfrom[from[x]] eg. prob from DAC vs prob from choice from DAC

- *how to combine generators/processors (for bits or for values): sets of combos but how to combine and we need more*

** 29/4/2022

- split of spdroutes | binroutes

speed from SR | speedmodeX
route from SR | binmodeX

** 28/4/2022

files:
//org: Xmode, 1apr, thisone, acSRmodes, seg2.org, bits_and_prob, temp, temp2

//.h/c: modeX.h, experiment.h, probability.h, prob.h, newmodes.c, abstraction.h

*can anyone be DAC - but if more than one what do we do? mix? -dacbus?*

*question of 5th tail - if we always have this*

// from below: speedfrom [ADCs/gens=strobe/prob/clksr/DACs/binroute->which route?]------->      gsrcopy // <<SR // <<GSR // binroute/dac

DONEsmaller gen selection eg speedsfrom...

// bitfrom,,,,

- note: param[x] is count between interrupts, clksr_ is SR shifting on strobe bits -> re-worked to test...DONE
*- so we can use clksr as a 5th tail on each - an SR driven by clk but we can copy contents in there (when/how?)*

- DONEbits bump values - bits-> values

- *check bitdsp: recursive boolean networks(int), delta(int), delay(int32), maskedOR(int32)*

// maskedOR:

(MASK AND (A OR B)) OR (NOTMASK AND A)

back to basics/classicSR:
1- speedfromX / or / CV clock speed
2- prob of new entry/vs/cycle - new entry can be route in
3- prob of inversion/vs/cycle - or/xor pulsebit/clkbits

fixed routing (rungler) vs. open routing/dictated routing (last segment of modeR) - see below how we deal with independent modes

maybe simplest thing is just to try some sets of modes out...


** 27/4/2022

- Q, if we replace binroute with generic abstract access... then what do potentially independent modes do?

// so we have: binroute, multi routes in, dacs/SRs dictate parameters, we can patch pulseouts in some cases, they can pull in adc, give dac out
// *binroute is kind of fixed to a routing operational mode!*
// do we need to guarantee that one Sr contributes?

L,C,R we have pulses out... so N is odd one out// 6 pulse outs...

- for slower speeds trigger always needs to coincide or we latch - reset when we use - testing in SRghostlatch

- *also QQQQ we dont use clksr_[w] so much* - try in gen.h to shift out...TESTED?DONE

- that we devolve to each SR as a single function - so not having
  chain of bitstreams as decisions/speed but spdfrom binroute,
  probfrom binroute and manipulation of routes is more important

*again clash of route in->bits and route in->spd/decide...*

*then each needs 2-3 routes in+*

DONE- generic sigma delta - we have for adc and dac in adcetc.h but could also be for other values: SRsigmadelta

DONE - holder function - hold bits for /depth/ time: static inline uint32_t SRproc_h(uint32_t depth, uint8_t bit, uint8_t wh){  
*AS new genre of processors - how these would function*

- *way to express lists of functions/operations/flow - again what is most generic pseudo SR...*

x/y grid of parameters and functions

BITS/STREAM -//- VALUE/CV/DAC

recursion needs some input

N L R
\ | /
  C - 3 bitstreams + strobe + CV/CVL/ADC which can select and control bitstreams 

CV becomes bitstream 
bitstream selects CV source/influences it... *[how to abstract bit choice of DACs, CVL, CV, SR raw, past SR, tails... more pointers?]*

- RSR defines 4 major routes _or_ modes ?

- how to archive and overview all our files... new approaches/evolution...?


** 26/4/2022

*primary question of recursion - heads and tails and how these are connected, what recurs, feedsback on what and how Rmode can change this*
*recursion of geomancy - 4x4 = 16 options, 4 major modes???*
*also recursion by way of jacks, and param[w] not to forget*

- *also forgot about lengthsel functions like adcLSRlengthsel0 in modeN.h*

// added binrouteINVbits in gen.h 26/4/2022

- CV/CVL as bits -vs- CV as param to generate bits? ????

- sequential bits bump up spdroute/binroute - other choices
- bits choose binroute bits -> incoming -> bits choose...

.. 1 bits -> speed
.  2         route    x4 SRs
.  3         prob
.  4         logic/pulse  -> recurse all onto 4x SRs - 4 heads - what that means.... [N-speed, L-route etc]

[bits] selects [bits] for [eg. speed] eg. bit as speed bit selects source (which is other bits)

** 25/4/2022

*4x4x4x4* permutationals caput draconis....

*TODO: /// all generic spdmode modes - these need speed/length being copied over for necessary modes*

- take stock! compare abstractions in new file
- no major modes on R - but how we can achieve eg. vienna-like modes (6/12 bits)
- switch by CV between CVspeed and strobe speed.

- catalogue all: where we get speed from?

strobe, CV, adc, CVL, dac/which?, bitsfrom/which?

** 22/4/2022

- shared bits completed... can also be with other generators embedded

//generators in generators//

** 21/4/2022

- q of stacks of params - but maybe too complex (feedback loops of SR->params)
- working through new abstractions in experiment.h
- potentials of shared bit and rungs in rungs
- maybe get rid of unmoving SR or????
- that we can also have interpol for non-frac speed eg. strobe modesDONE

rungler:

---->0  0<---spds
\  dat\/ spd/
 \    ()   /
  \-- ()--/
      ()
- 2 side SRs and 2 central

** 20/4/2022

- working in experiment.h: abstracting out spdmodes, spdfrom but we
  can't route own bits to speed (of course). no recursion, dies out
  (unless we use clock - added this to binroutebits)

- strategies:

-- too many parameters,,, fix some/mix and match
-- print and cut up functions/python re-workings/further into generic functions
-- *dissect whole diagram TODO!*

speedfrom [ADCs/gens=prob/clk/DACs/binroute->which route?]------->      gsrcopy // <<SR // <<GSR // binroute/dac
infrom [ADCs/gens/DACs/binroute->which route?]
IN/prob? [ADCs/gens/DACs/binroute->which route?]
logic [ADCs/gens/DACs/binroute->which route?]

-- most generic option eg. vienna code ... but how to get recursion in/chasing/chaining, also null route mode is there

recursion and chains:

routes--> spdfrom \-\----> recur onto routes
          bitfroms \-\
          probfrom \-\
          logicfrom \-\ and from is to route in...    

how to be all of? - supplier of bits to determine X, route in as in bitsfrom, and this way in ???

cannot recur on itself or 4 selves..

LRNC are defined by route (and adc,dac out but these can be changed) and doesn't matter who has adc in as all is determined by routes

all have route from 3 which has route from ... or is a gen, or adc

*sync routes, sync speed (on trigger)*

binroute/spdroute / detach / layers of params 

as in mode can set binroute/spdroute and stick with this *trial?*

thinking that layers of params like a stack can be an SR which we pile up... how to remove layers?

- no identity - identity is only from route (pulsins are only identifiers of LR) and physical layout

so key is what provides this identity: one master, 3 slaves, as own chosen identity might be at odds with others

towards something like major/minor modes or modeR chooses from a grid of modes...

abstract out interpol and strobeDONE

*to keep null route in binroutes or route always from 5th/extra tail?! - see gen.h*

** 19/4/2022

- see experiment.h// large notebook notes

- thinking about trigger and how it works in CVspeed modes - if we
  should keep trigger/pulsein over until we process - ie. if was
  trigger or pulse in the interval? - but for long intervals chances
  are there will be a trigger - maybe notion of trigger window?

- *TODO: fix up generators a bit so they make more use of depth and work well*

- other routing N-L N-C L-R R-N: 8, 1, 1, 2

- slice/splice remix and mix of speeds

** 18/4/2022

*TODO: final multispeed modes, modeC still needs non interpol dac and mix outs, an end to modes*

*// some more generic solution???*

- one bit audio doesn't work with unipolar signal (0-2048) as we set
  the middle/zero? 114 is new adcmode, and should also be generator
  but questions bi vs uni entry... same problem with comparator //???

- fixed binroute^=logop in modeN.h

binroute as function on top of binroute cancells itself xor

variations of delay line sharing - what of these modes which only make sense for 1+ Srs to run...

*Q. gate[x].dac and easier access - owndac -> other mode mood scheme*

notebook:
- how too share access to bits in function (master?)
- only copy in when the receiver has made one circulation
[stories for each: ]
when you have circulated, i will copy in. when i have acknowledged that you have circulated you can copy in
what does it mean - when you have circulated...
or bits are shifted into longer register and we keep track of our own index...

- DONE:delay which isn't a slowing down. bit delay line

- rethink/reduce to well-documented and tested sets of functions:
-- basic prob/routes
-- classic SR and excursions
-- ADC/DAC
-- fancier permutations of each characteristic. eg. multiple speeds...

- also functions which convert/use DAC 32 bits values...???

** 15/4/2022

// how we can share a value - who updates it? eg. sample and hold ->? heldsample
// unless is outside the generator and always runs, then we need to always run adc and just sample that...
// or mix and match adcs...

// new signal processors: sample_and_hold, what else?

4094 implemented: outs are each bit, CVs from groups of bits and the QS/serial out (see 4094) below..., clock edges

we have 10vpp so 5vpp has problems with full range comp... also comp and unipolar signals

*fix comp at 2000 and think about signals - comp without depth?*

new: added defdac=3 global, proper 8 bit cipher mode: (we have some as SRN33,34 in modeL.h)

///question eg. with say consecutive ADC values of speeds (should we bring adc in at fastest and just sample from this??)

DONE: chance of prob decay (flip) as it advances down SR... - older bits...- initial chance of decay/flip

/////

*how to start to make sense*

TRIM//back to basics/strip down with details and variations on latest sets of modes:

speedfrom?
from?
inlogic?

to answer for each classic SR:

eg.
TM/WIARD/EN: speedfrom(clock), from=loop/invert loop, inlogic=prob: CVcompNOISE/SR=comp

and what this means for each SR side. eg.

speedfrom: clock/speedCV/DAC(which?), bits
from: ADC, loop, pulsin/clkin, invertedloop, inverted_all
inlogic XvsY: probCV, probDAC [probFROM], strobe, toggle [LOOPvsFROM]

RUNG:

generic rungler: 
SR1: speedfrom clock/dac2, datafrom 3(route or dacNSR)XORloopback // route from C=3
SR2: speedfrom 1, osc/abstract
SR3: speedfrom 1, osc/abstract

functions/philosophies: 

-types of input (ADC abstract) and output (DAC), processing

-generic - also relates to recursion - eg. incoming SR dictates functionality of SR (or a param such as length)

-replicating functions such as digital filter, 8 bit cipher/4094 SR

-didactic: how do we use all the bits we have, and the parameters

(speed and length or more untied params - they are just parameters) -
new model (ie. how useful is length?)

...but SR "has" length and speed/clock as basics (unless we just think of bitstreams)

look again at 4094: 

The HEF4094B is an 8-bit serial-in/serial or parallel-out shift
register with a storage register and 3-state outputs. Both the shift
and storage register have separate clocks. The device features a
serial input (D) and two serial outputs (QS1 and QS2) to enable
cascading. Data is shifted on the LOW-to-HIGH transitions of the CP
input. Data is available at QS1 on the LOW-to-HIGH transitions of the
CP input to allow cascading when clock edges are fast. The same data
is available at QS2 on the next HIGH-to-LOW transition of the CP input
to allow cascading when clock edges are slow.  The data in the shift
register is transferred to the storage register when the STR input is
HIGH.

-patterns (classic SR)
-more about one bit audio/rotting sounds
-input, feedthrough and feedback - ADC/DAC and also abstract functions/SRs
-bit *recursion* onto itself - deciding itself (SR state/function as SR) - how an SR is defined and encoded
-SRs as functions which feed into each other and dictate each other - more as a patch

influences/ideas:

- CCRU/hexagrams
- i ching/geomancy/african binary codes...
- rotting sounds

** 14/4/2022

To resolve: binroute and logics, clkin, pulsin, CV extent, what we get from newmodes.c and if we can discard: list of missing modes to discard or port

basic routings - for new functions, for new routes
basic clk, intmodes, speedmodes
basic SR structures eg. Tm etc.

all the modes we have created
generic modes and how we can create from these///

or follow abstraction route?


see also temp.org, temp2.org, bits_and_prob.org

work through step by step and also new experiment.h - conclusions from abstraction

Q of restraints/simplicity which can then be stacked up and CONTROLLED!

////////////

multiple speeds of:

- copy gshift
- shift own SR
- advance incoming GSRs
- main dac and route in with no shifts


- routing depends a lot on modes...

- abstract works. change gate[w].dac throughout or???

- so we need more logical ops for binroute in! that is not always XOR as standard - but how to vary this (global, local)

logopx(uint32_t bita, uint32_t bitaa, uint32_t type) -- 2 bits

TAKE CARE OF:
- basic SR structures and routings with changing logop
- using new abstractions//functional routings
- new abstract modes and lists // cover basics and extend
- masks

Q of binroute still, of logic ops across all, major and minor, grouped modes etc....

[one idea for grouped modes was to have R as selector of grouped modes and each other mode as moving off to other modes...]

split between functional routings, grouped routes and prob routes and traditional feedback routing and if we can mix the two...

if say L has function such as prob - for pooling of parameters - then ... ways of thinking about modes...

take stock of what we have...

** 13/4/2022

- notebook: recheck generator as speed????
- clkin should be more or less consistent eg. NC, as pulse in XOR, LR ???
- Q of mdoes, sets of modes, major minor...


** 12/4/2022

- norm clk only in clkspd (and essential clk modes) and make use of clk always: as pulsein
  (esp. in C and N), as toggle and non-essential decision, advance GSRs and other elements

more of clk: clk can deliver from gen or cycle in - also toggle

clk
toggle

*to treat as a parameter we need to use - even if is fixed as 0*

- 2s complement and others for noSRadc DONE and some fixes there...

- how we can think about routing/functions... for example, N-incoming, LR-params for entry of N into C/outgoing...

but that is split with "normal" routing of N-L-C-R-N...

** 11/4/2022

- see experiment.h

** 9/4/2022

- *question really of too many bits/params - and strategies for coping with these - eg. each mode as part of the param space (eg. dictating speed)...*

- possibility of a shared gshift, and of dissociated outputs (inputs also into bus?)

- are we done with modeN/incoming?
- start catalogue all - esp L/R and do we have enough from the DAC
- check all files...

// more working out in expr. modes. how much is down to CV, pulses and clocks in and less fancy modes...

** 8/4/2022

- options not to advance the Gshift so there is no cycling in - global option. this and binroute in?
[also has a lot to do with length and incomings]

SR can even be totally static or just fulfill a function /// try some basics with this, new experiment.h file

as below, what elements can be used from delta sigma

//////

DONE/: test/simulate our sigma delta in test.c -DONE - just that we can't sample so fast (16x 20K=320kHz)

notebook notes:

- SR characteristics: independent, they don't dictate to others
------ each has a function, an input, an output?
------ speed

each SR has a route, feedback through decision, altering next but also a FUNCTION!

a patch programming with SR to next, but next determines its own route...

clarify possibility wheel ... wheels in wheels

N-probability of entry from [adc-which?^R] vs cycling
L-fromN
C-fromL
R-fromC

** 7/4/2022

*is there a way to do integration, delta-sigma across seperate SRs -> integratorandcomp we do already (N-entry), flipflop(return to N, so R) with C as out?*
*

DONE:strobemodes to look into for conv to binroute bits: adcbumproute0DONE, adcstrobe1_0DONE, 95DONE ???

but we need to use BINROUTENOS_ for no strobey! checkDONE

*also in adcins more use of strobe with route in for feedback - so not always adc or anything in but more feedback*

can have routes in, speedroutes in, IN?routesin, probroutesin, etc...// but this can be/is abstracted by generators which include route in

either/or from stream in: runornot, stream/bit/whatever in or cycle -> so is a prob

we can use binroute to replace prob and also as strobe for adcinsDONE/// or other strobe modes

params: detach speed/strobe, detach length = max 2 params (with adc as param), dac as param

TODO:
- new model with speedstream, fromstream, instream as functions... other models to look at

N-speedstream, entry
L-from?stream
C-instream?
R

// but how fast do we run speedstream - just test it?

////

//DONE:eg. stream->selectTM, WIARD, EN - stream can also be probability 1 or 0 yes/no 

DONEalso as routingmodeHOW?prob becomes a looping SR of decisions enacting on itself - also slipping of prob running at a different speed

//run prob_wheel at speed x, use it at speed y

different types of prob wheel - is just a stream wheel. wheels in wheels...

can wheels be spread across SR? // need to think more about these wheels - that any generator can enter them - SR is itself a wheel

recursion of generators:

- generator x decides if we extract from generator y (but if we have that in one it lacks speed)...

- x decides if we cycle/enter new gen y which then decides if we... -> and back to x

no route but binrouted ones as decisions for... what? eg. entry of adcbit or cycle... [entry into wheel or from wheel is the same thing // entry_or_cycle]


///

- make new selections for adc and dacs
- draft possible lists functions for mode selections

** 6/4/2022

INstream/DECISIONstream [IN?]

bitstreams all for: speed/FROM?/IN?/WHERE? 

and how we can route those?
... but there are also analogue streams - eg. CV, DAC (which have
different convertors to bitstreams)

split: bitstreams\\\///probability/CVanalogue/DAc

*what a new model for this could look like?*


*would also be nice to have dacs routing in to RSR side - dacmodes input - just as modes we have in adc/dacmodes list*

binroute-count // route in
spdfrom-spdcount // speed from dac
gate[dacfrom[daccount][0]].dac // dac as param or mix in/src

*still Q. of how we deal with/binroute_or_not - set in modeR? - also xor in binroute and addin to gshift options*

binroute:
N- yes/no/how?
L-yes
C-yes
R-yes/no - no for generators/or 2 sets options with without binroute

Rfinds route in via N - so binroute is critical there for uses of DACetc

notebook notes/other:

- DONElist adc modes which use strobe (does strobey still make sense or becomes overcomplex with modes of modes)

*make new selections for adc and dacs// also strobemodes list*

[do any generators use strobe?no]

DONE- use abstract bitstream to IN? eg. if (bitstream) binroute or cycle... DONE: adcLabstractQIN

DONE:abstract generators are not independent so multiple calls across them change them which could be interesting:
draft also independent versions, 

DONE: length=depth and if we add in gshift/addin or just shift out, binroute or not...

DONE: say NLR can be generators into XOR (full mode) on CSR - DAC - can also be mix of logics and prob there...

*also for CSR more modes todo: mixes, using bitstreams to shift between incoming streams etc*

- DONE4 bits in as [binroute/adc/dac/abstract]? - now maybe a successive route in 4  bits...


- DONE...general options for shifting as bits: copy_to_gshift, addin_on_gshift, shift ourselves/double shift, pulsins, other pulsout options, add in bitn - say 6 bits

5th tail in progress

- *extended modes - that can have say modeR to select new sets of modes for others...(then what does their mode knob do?)*

- *thinking how we can have more flexible routes - so we can route cv and/or dac or other streams into functions...* from outside/5th tail or?>?

so we stream in to 5th SR/tail - choose speed and sources from Rmode
and use this in other SR modes - we still need to think on how to sync
across modes

*5th head=tail*

contradiction of severed recursion

eg. we want to use feedback but take it out of the loop, so it isn't feeding back...
so 5th SR would be like RSR but not feeding backin (a copy and not) - SEVERED
- at different speed but where we can get this speed from? opposing speeds?

- we can only simulate potential feedback and use this - how thus could be used in writings as concept...

** 5/4/2022

- maybe no major/minor as we need RSR

- ways of grouping favoured sets of modes (also like RSR syncing modes), splice in modes, extra modes etc.

RSR modes/character: 

- feedback/probability
- independent DAC functions/generators (abstract, some in)
- other functions (more of RSR etc. eg. global routings)

do we have generic, detached probability modes?

*TODO: RSR sync mode (sketched in)*

RSR: that can GSHIFT itself as a 0 always to prevent binroutes into others (but does this effect anything)
check for gate[3].Gshift_[3]

DONEgeneric ADC/DAC generators->function array, abstract gens, 

generic IN?DONE in probability, WHERE? we can't split per SR as we need the bits for logic... just have one bit routed in

out which uses SR (which?) as sieve for multiple bits

/// odd one. route in is determined by bottom 4 bits of another SR (do
we have this?) - we have SRSRroute in model.h - but would be nice to
select which SR we use for this

*still thinking on how to split SRs so we can say mix multiple bitstreams* - think in parallel...

can have 4 parallel generators XOR in say on CSR with prob (we have already)... route all in...

tested new abstract generators 0-16DONE

** 4/4/2022 

*IN/DECISION [IN?]*

extramodes.c: ignore as formed newmodes.c ->

newmodes.c: most of these are in modeL.h

temp.org, temp2.org, bits_and_prob.org

//////////////////////////////

Qs: routing and independence, if we want free SRs which just control/dont route (RSR), binroute or not, major/minor modes or not
what we need to add: new generic bitmodes...

//////////////////////////////

catalogue files // we need overview of what we have:

- DONE: fixed some electronotes mode in probability.h and now we have all modes as generic and called with w!

but we still can't have minor modes as all ADcs/// so how to mix////

+but problem is pulsin (for N and C), and out (for N) - so adc modes have no pulse in, no out if used on LNR sides - should be FIXED now...+

DONE: genericise - only thing we need to watch is count, daccount and spdcount (new)

we can still have specific modes... we also got rid of slow/no_stop for CSR!

we also need to deal with probability.h and bit.hDONE

rung modes fixed as gate[0].dac

/////////////////////////////////
notebook notes+

- +TODO: simulation* sim.c+

- mix and match major and minor modes so are not all same /eg. not all prob. how?

- generic in: 

//FROM?//where from [ADCins/generators, DACins/generators [16 or so each], routes/returns] - how many bits? 6 maybe - and we need one param // combine?

4 bits typegen/2 bits[-eg.adc/dac/abstract/route]=6 bits

//IN?// as [strobe/toggle/bits[from]/probX.Y.Z] - how many bits? // combine?

strobe|toggle|bitsfrom1234|prob1234
1            |1bits/prob|2forwhere = 4 bits or more depending on prob modes 

or we fix as prob/bits only from 3/RSR... then we have 2 bits - but prob needs CV

//WHERE?//where in - route by route? eg, xor, logop - can also be abstracted as an IN?

*or these can be split across SRs: - held in potential as once we have them???*

eg. N is where from, feeds into IN? (L), then C is wherein? (or just first 2)...

but then what is IN against... and where? doesn't work out

with R as majormodes/back in or patterns for others (eg. we can't use DAC/bitss if there are no interesting DACs/bits)


** 1/4/2022 - see new .org file for today/new notes/concept

10 encodings below XxY ADCxDAC mix = or - and we would need 3 parameters: whichencx mix whichency

speed and length as 2 encs only...

*or: trial for overlap/mix across NSR and LSR! so one as ADC one as DAC in*
but that is different kind of mix..
// set up generator list so can be selected...

** 31/3/2022

list of encodings for ADC, DAC: parameter is depth/delayforonebit

16 encoders without comparator

- maximum 12 bits 1
- padded any number of bits 2
- fixed number of bits: 12,8,4 345
- one bit encoding 6
- equivalent bits 7
- energy equivalent bits (abs value) 8
- fixed 12 bits 2s complement: can also be 8,4 //9.10.11
- variable depth 2s comp //12
- fixed 12 bits 1s complement: can also be 8,4 //13/14/15
- variable depth 1s comp 16

- comparator is an encoding???? no?

generators can also just be in modeN (see example Nintone)

complemented by DAC decodings

list of abstract generators and abstract modes:

gens: 

*notebook notes:*

///question of so many params/// 

In modeN ADC is possible param so with all detached we have 3 params... max 2 in other modes

strobe/detach modes - frees speed and length as 2 params

///

- *how we manage routes - sync routes?*

tricky as who syncs? if all mode can do this?

- length of SR as distinct from param for ADC or DAC modes 

length is only relevant for entry into next SR (if there is), and for cycling

- what length and speed mean for each... (eg. in modeN we can free up speed easier)
- how to extrapolate from basic SR (eg. rungler) for each side: L and R should have basic prob modes

- slippage of bitstreams against each other 
// *also that instead of a route we combine two SR eg. N and L??? how? and what is their content///only if both are generators* tEST

- Q. detach ADC mode and leave it there?

also defining basic ADC modes and modes which are more fancy and involve other routings - see how these are divided across adcetc/modeN.h

x abstract modes ----
x ADC modes ---------> bits/params for these eg. depth. + binroute/from/cycle + prob/strobe/toggle + specials...
x DACin modes -------

- stop adding more modes!

** 30/3/2022

generators/bits, encodings if any --> bits, 12 bits/encodings (only for dac and adc so we need these in generators)

generators->prob/etc/mix

*TODO: other basic SR options*  

WIARD: noise/comp selects new input or loop back/inverted loop back (jumper) //options relating to new input: adc/dac, mix, routein - how to select these options

EN: LFSR SR bit is loaded/not loaded onto recycling SR. loading can be random (based on LFSR and set of probability switches)
DONE: as a generator, we have variations otherwise in moden for adc in 

- there were mistakes there which we need to fix from generator code...DONE - port electro to other sides

TRIADEX: see what we have, harder with limited params but what we can get generically from this: multiple bitmasks

///////////////////////////////////////////////////////////////////

DONE:1 and 2s complement for ADC, one DACinDONE

one's complementDONE

also encodings for 12 bit dac // so we can mix these////someDONE

*too many options/params: eg. speedfrom, adcin, mixwith dacfrom etc. stream, encoding*

dacfrom/speedfrom? but also dacfrom is param and for feedback we route from 2 so is different - changed in adcetc to 2 for dacs routed in

*DONE:use speedfrom so dacfrom and speedfrom are different and can be changed globally in modeR-TODO*

eg. gate[speedfrom[spdcnt][3]].dac vs. gate[dacfrom[daccount][3]].dac

- how to genericise rungler so is unfixed in routes... eg. that we can use NSR as oscillator approx... but speedfroms are fixed here....
and with rungler we need all to be kind of synced... but abstract out...

generic rungler: 
SR1: speedfrom 2, datafrom 3(route or dacNSR)XORloopback // route from C=3
SR2: speedfrom 1, osc/abstract
SR3: speedfrom 1, osc/abstract

speedfrom x

encode as:
binroute-9,0,2,0 
speedfrom-1,0,none/0,0

*but there is no sync of modes to use certain routes (count=binroute, spdcount=speed is that sync) - think about this*

out is SR4 with route/dac from any... CSR/generic or we add speedfrom x option

//////////////////////

from notebook?

x speedfrom
x [dacfrom]
x routefrom
x param from 
------------> recurse?

** 29/3/2022

- cut routes? from notebook - what this means/how/why? relating to rungler - to cut the binroute in... =0 but how to put back...

DONE: rungler options.

////

//bitwise not add one

for rungler:

SRN: speed from SRR, data from SRL - new route XOR with loopback

SRL, SRR: speed from SRN: (both run OSC with no binroute)

SRC: output from oscs or from SRN - select our input - route from...

implemented as: NLrung0, Lrung0, Rrung0 and CLrung0

variations around these eg. for L/R type of speed, detach and type of osc...we already have some of these, working on for LandR//DONE

+also idea that if we use ADCIN as CV then we can cut the loopback or is it normed?+

** 28/3/2022

*do we have fake feedback loop at fake speed?* - Ndraft1 heads in this direction

but thinking we can start to work this towards the fifth hidden serpent...

which could be fake feedback tail -> how long? speed - then modes (NLCR) which use this extended feedback, which can take different forms

*?* that in modeN we always run input at full speed and just select
bitn in on own speed - only question is modes which use multiple input

or just run one kind of adc?

*To start to simplify*

ADC/no input abstract modes: 22,23,24-LFSR, 28-clkbit, 29-osc, 30-osc, 31strobeTM, 34osc, 77osc/dac, 78osc/dac, 79osc/dac, 80osc/dac, 89impulses, 95patterns = 14

but most are not straight modes without CV/params - *we need very basic abstract modes here*

DAC input modes: 25,26,27,71,72,73,74,  also mixes of DAC/ADC in adcetc and in modeN to port from INTmodes/DONE  =7 


back to basics - detached TM modes (NLtm101)+, rework classic modes exactly, new
code draft layout

TODO: other bit encodings for negative in adcetc/modeNDONE

classics:
- TM, done - all variations to explore

- Rungler: NLrung + some variations TODO

Original: SR bit out XOR with OSC1 out AND OSC1 speed/freq is determined by SR (itself)

translated: cycling bit XOR with other SR out bit which is clocked by
SR/or DACspeed from itself (bit clock options are set BY SR itself) 

or:

cycling bit XOR with DACout from own/other SR vs. comparator=CV/DAC/DAC+CV/CLKCNT

WIARD: noise/comp selects new input or loop back/inverted loop back (jumper)

EN: LFSR SR bit is loaded/not loaded onto recycling SR. loading can be random (based on LFSR and set of probability switches)

TRIADEX: 

/////////////////////////////////////////////

new code draft layout:

// how to code a new prototype from/also a bitmapped/probbed mode from:

-bitstream /in/ (depth, other params) -routedbit/s from where/ROUTINGS/// - this is also a bitstream... but we have it seperate

parallel bitstreams...

-dotheycomein? - strobe/toggle/probability/ANDbitsotherSR -> using AND
from other downstream SR doesn't work for feedback reasons///

- *how they come in* splicings with other chains, mixing with other
  chains

At the moment we have prototype of:

  if (speedf_[w]!=2.0f){			
  if(gate[w].last_time<gate[w].int_time)      {
  GSHIFT_;	
							
  bitn=ADC_(0,SRlength[0],X,gate[0].trigger,dacfrom[daccount][0],param[0],  &gate[0].shift_); // parallel streams
  BINROUTEOR_; // parallell

  BITN_AND_OUTVN_; //out

gshift/bitn_in/binroute/addinandout!

sources[1]->entry[2]->logic][3]->where[4] (also 4 tails/routes here>>>)

incoming bits vs. interpreted bits

 they are bits - multiple GSR speeds...

ADC/DAC bits: deliver bits/generator, tap into stream ... 
OSC bits: they are bits, also can be streamed/accelerated...
BINROUTE bits: they are bits, can be multiple GSR speeds, where they come from=route
feedback bits: loopback bits


/////////////////////////////////////////////

*simple case of binroute or not?* how  to handle?

/////////////////////////////////////////////

*that DAC out can also have choice of non-interpolated modes eg. c0nov*

slowest speed is not 0.1Hz but 2Hz? 2Hz->14octaves->20Khz as our fastest

////////////////////////

- question of how to advance and finish SEG/Heavens/caput draconis ???

basics such as speeds and CV, layout, modes... survey all modes - what
are we missing?

characters of each tail/branch and new 5th branch...

TODO: split and join 2 branches at different speeds, brainstorm ways
of dealing with 4x tails...

** 25/3/2022

//quickTODO: sliding/splicing bits input adc_doesn't work as we tried
before - forms a block, prototype for new setup from notebook...

working on Ndraft0 - also that mode of fast adc then copy in is also interesting which is what that is as no feedback so far

NEW: N98adcordac, N99 (toggle dac or adc), NLsplice100

*PROGRESS: new org page for each mode - can also be towards manual*

** 24/3/2022

- *5th head of serpent* indicates extra feedback path - uncontrolled -
  sink for other SRs, or free running SR, controlled by? eg. like
  flipflop or generic SR... we can sample and use this 5th head!

what are its parameters?

- probability of feedback return is important

- almost as if there could be chains of ADC operations

SR as a chain.. specifying chain

N95 is now with dac choosing pattern to enter on strobe... *patterns can be geomantic*

- assessing modes 11/12 in DAC and general speeds of DAC...

*still question why length of ADC/DAC doesn't make any/much difference
to signal*

note also that oscillators are more effected by speed of NEXT SR - (eg
modeL)... as if they are unchanging they write the same information -
would be different if they were catching samples like 1/0/1/0 like a
DAC - can we try this! - towards trying to think more generic

DONE: Nflip mode... 

OSC modes can also have strobe or other prob/decider for loopback (dac
decider?)

ADC: *insertion of static bits* /overlap of bits from different sources (where
did we have repeating elements - from adc 87 on strobe) eg. we realise that 1010 from ^=1 (30)
could be static pattern 

on strobe we could enter one of y x-bit patterns (eg. 4 bit
geomantics)... NLpattern95 but we could have other splices (of ADC
etc)

SR keeps shifting/or looping and we insert bit only on speed... - that
is a bit like multiple speeds which we have already

N97 only - we insert 4 bits in on speed otherwise keeps on routing,
can also be route and cycle, other options

// how these new modes fit with generic ideas??? ... more about
splicing in, and seperating elements/shifts/speeds

a lot also about routing...

///modeN-> define abstract modes

*window of feedback... in modeR or N*

** 23/3/2022

- DAC16mode doesn't do much, sliding window, we will need to find use
  for length in DAC as doesn't do hardly anything and we don't use for feedback...

*maybe invert incoming adc and not dac out//or keep dac inverted*

*TODO*- different encoding/decodings for adc/dac eg. one's complement
= bitwise not, two's=one's+1, signed magnitude (MSB is sign 1 for - -
this works better for energies...) - more abstract modes?? what these
could be??

//cut below 2048, energy only/equiv we have but can also be bits,,,,

ADC - encoding, bit codings
DAC - decodings?

////

eg. process/subtractetc, how we interpret these bits

ADC- encodings/depth, how we deal with bits/coding bits (length?) (adcetc), this
becomes bitstream into length SR (moden), do these bits come in, how are they
treated, any other

abtract out routein/vs/adcin/abstractoscin/////

////

do we have comp against changing levelyes-20/otherpar- DONEcan also be detached mode

subtract changing level...Nintsub92 - detached? DONE NLsub92

comp at 2048=mode85

** 22/3/2022

- refining: *that some DACs can have reduced depth/bits=volume* (again
  there we don't need to match to length but then length does even
  less)

Q? modeN. 
0-7 - most basic ADC in
8-15 - strobe modes/abstract modes...
16-31 - detached modes, detached strobe modes

/////modeN
-bitstream in
-routedbit/s from///
-dotheycomein? - strobe/toggle/probability/ANDbitsotherSR -> using AND
from other downstream SR doesn't work for feedback reasons///

*(is just AND of bits with strobe/toggle/emerging bits) - probability as a bit*
*idea of SR of probabilities itself*

*bitstream can also choose wheretheycomefrom* see N91sw (again
question always of detaching feedback - one limb just for DACs or???)
- extra limb...

-howtheycomein?

for other modes we can have this for pulseins and routedins - make generic

/////////////////////////////

- reverted old adc, now back to new as was thinking on ADC noise but
  is caused by fact that 0v is 2048 so x bits, rather than 0 - lower 6
  bits are positive, top 6 negative (as is inverted) - is this a
  problem (on output 2048 is 0 though but just means absence of bits
  is not 0)...

- thus 0 bits in register is -5v DAC output (as inverts there), but
  input is inverted...

- how do we deal with this? for example with equiv bits? or we can use
  some lookups in some cases... (one bit audio in/out seems to work ok
  now...)

but we have no way of signifying pos or neg with bits/// trial
energy/abs->DONE/also as generator

-DONE/TODO: modeL/R where we don't add back in bitrr in gshift so just
  dies out (as kind of impulse)* Lnoggg test

** 21/3/2022

- *TODO: more mixes//bitmix add is an OR*

 *bitstream abstraction-question of sources, plan*

- 17,19 in adcetc as suspect - clean up adcetc with new ideas
  too.... 19isfaulty - replace new test case...DONE - also changes to
  int29mode

- oscillator has length of 1 and 0 bits so 2 sets of params to deal
  with or we have square 50/50 oscillator... 

- what we mean by impulse input? eg. strobe triggers x bits (1s, x
bits from adc, x bits from ...) NLpulse89

- DONE/TODO: sliding DACout from notebook, depth, whereitis and [shift <<]
  params - done to some extent as 16 in dacs

- TEST:N,L,C,R with sequential bits in from generators - Lstream,
  Rstream etc - TESTED fine

- added lookup for mixdivs72,72dacmix-check

** 18/3/2022

- fix adcg and adc mode 7 as this just gives LSBs and check all
  adcmodes, 6 is also same as 3 so replace both, 8 too DONE

- do we have cycling adc/bits in - new mode 8 in adc_

- to fix some of modeN which use old adc_buffer: 71, 72,
  72dacmix-DONE/ - 72dacmix is no good, 72 needs lookup for
  division/DONE - recheck dacmix

[dacmix works only with external pulse ins..., both can be refined]

/////////////////////////////////

thoughts on below - they are already close to bitstreams as they mostly
deliver one bit but we can see how they look more abstracted...

*also with stream model we can switch between streams and mix them,
logical op them, and have differing depths*

- notebook notes: 

[but do we really need?] for modeN idea of generators which keep track
  and deliver bits eg. adc generator, dac, osc generator, impulse generator ...
 - also so as samples can be distributed across L,R,C,N (at moment
   counters are all independent)
 - sample depth independent of length is important 
 
again:
- where the bits come from
- if they come in [according to prob/strobe/toggle/bit pattern]
- where they conme in?
- how/logical ops?

-  maybe abstract out routes in/binroute as the kind of function
   above - test more abstract version...

- impulses

*TODO: entry bit as logical op with a bit pattern (eg.100011101) from another SR!*
how this could work: *we can have a pattern from otherSR or incoming of where/if bits come in*
- if enter bit is an AND operation - we need to cycle bits from other
  reg and where do we do this

** 16/3/2022

*TODO: detach length of SR and bitdepth in modeN/adcetc...* - done to some extent with new generators

** 15/3/2022

*modeN as key*

towards generic treatment of bits from ADC, DAC, oscillator or other function, mix of these/feedback(=DAC?), route in // eg. 4 bits from osc into x length etc...

that we can treat routein as we treat in other SRs or as special ADCin case????

treatment of bits // function(ADC, DAC, OSCetc, routein, mix) they come from // length of SR 

/////

- towards more generic modeN (and other modes) - what are differences in macros (obvious for pulseins/outs we have or not)?

//where bits come from/if they come/where they come... sequential toggles of eg. 1010111 bits in


eg. we use a SR sequence to determine if (1or) we input bit from x. so /if/ is from: prob/comp, strobe/toggle, pattern

also other decisions from bits -> eg. which bits in/....

sequential->ins

*bits in from ADC, DAC, oscillator or other function, mix of these/feedback, switch these - mix/switch*

//////

->  if/prob/strobe/toggle of ->>> bits in from where/and where these bits go (logic of their inputs). eg. multiple bits in...
--> nature of the shift

[where is generic description below?] 

- where is our speed from?
- where do we get bits from?
- which bits
- where do we get prob of bits in
- where do bits come into
- how do we shift?

MODEN: route and DACs in - which DACs we can switch in, different bitstreams to switch...

*if we can abstract out dac, adc and routes in so is like SR bit streams in*

-// also check/catalogue dac modes:

dac:
66: any
67: 4 bits with delay of bits
0: any
1: any equiv
2: any/1bit
3: any/>7
4: any
5: any
6: 4 spaced bits
7: 4 spaced equiv bits
8: any/sieve
9: any/sieve
10: any/len-otherpar
11: any/sequential?
12: any/sequential?
13: any/mask
14: any/mask
15: any

- so we could have more fixed bits eg. 4 bits out, 8 bits out, 12 bits out, regardless of length (so then we should really detach length)...

** 14/3/2022

- *changed adc mode 3 as was same as 0 - check all logics... maybe better group them in modeN*

DONETODO: for adc-> 8 bit fixed modes (12bits and 4 we have),
*TODO:fixed equivalent bits in eg. 4 bits equiv...* then we need to
use length

//catalogue adc modes which have set bit depth(set), variable bit depth(any), restricted to <11 depth(<11)

adc: 
0: <11
1: any
2: any/1bit
3: any/pad 0
4: set4
5: 12 bits always cycle in to our length
6: any
7: any
8: any???
9: <11
10: <11
11: any
12: any
13: <11
14: <11
15: <11
16: any/1bit
17: any/otherpar+3
18: any/otherpar
19: any/otherpar
20: any/1bitcomp
21: <11 *TO FIX*
22: noADC-LFSR
23: noADC-LFSR
24: noADC
25: dac<11
26: dac/onebit
27: dac/any
28: clkin
29: 1bitosc
30: clkspeed
31: TMin
32: *TESTTODO*
33: <11adc/prob - *maybe move*
34: 1 bit osc
35: adc/prob
36: <11adc/prob
37: <11adc/prob
38: <11adc/prob 
39: 1bitadc/prob
66: <11adc mod otherpar
67: <11adc+otherpar
68: <11adc&otherpar
71: anydac
72: anydac
73: 4bitsin
74: anydac
75: adc/daccomp1bit
76: adc/daccomp1bit
77: 1 bit osc
78: 1 bit osc
79: 1 bit osc
80: 1 bit osc
81: 4bitsin
82: comp
101: <11adc
84: comp
85: comp
86: <11dac
87: 4bitsinadc
88: 4bitsinadc 

** 6/3/2022

- *TODO: double samples* so we hit 24 bits long/length is 3-24 then...

- do we already have double length 0-63 SRs - TEST NLdoublelengthDONE

// changed OUTV_ to OUTVN_ in modeN - as we have no pulse out in N!!! only in L, C and R!

- *where are we with extramodes.c and other source files? re-organise all when back*

** 2/3/2022

- *how to think length (again) for modeN and modeC*

modeN:

bit length/SR length - but maybe only for abstract modes does it make
a difference and any modes where we return/prob return, also q bit
length > real12 (our11)

- but at slower speeds there is a difference... (in length but)

** 26/2/2022

- look into 4 bit ADC in: adcetc.h CASE 81 4 bits in - does length change anything? *NO* - so we can detach this...

check basic adc modes - how much length changes things... and how central length is?

modeN/adc: probability of different dacs->

- changed NLcutfeedback86 so is more instant - switch between 2 DACs

check for adc modes where length makes a difference...

16
16 detached
dacspeed - mix of detach...
intspeed - speed and length? cvs free 2x CV...

** 24/2/2022

- fixed new adc for modes in adcetc.h // to TEST

- working through modeN - too many modes! how to make sense of this // order the modes in the file and how these can become more generic


- *TEST*: NLCVDACroute if CV>DAC - entry of new bit from [ADC, route
  or cycle] XOR cycle/route etc... - use what for this choice of
  route - detached - but does as adc or...

N87_4bits_strobein

Nint72dacmix - using dac for mix *NOTWORKING*

*TODO: mix DAC(1)(normed) feedback in - using CV, using DAC - do we have these kind of mixes already? in Nint72 but we could have more*

DONE: list of dacmode in modeN.h// uint8_t dacmodes[16]= { // which use DAC

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

** 22/2/2022

- get back into code and TEST new adc mode 86: cut feedback - eg. cut for CV count clk pulses/on off
// detached mode -> NLcutfeedback86 -> changed so switches between adc
and dac3

- R mode just zero in... (so no RSR feedback): Rnada in modeR.h - TEST

////UP////

** 19/2/2022

- returning to code... define character of each side starting with N, 16/16/16/16 modes - 

modes which use strobe to one side

N: is input and feedback -- RSR feedback//DAC feedback//normed ADC feedback//mix of...

L: passon, route only

C: output and entry?

R: feedback -> N // DAC value...

** 10/2/2022

- noise on adc in seems to be to do with adc mode/multiple bits 

newDONE:
- oscillators (as in 81 tests in adc) few bits repeating which could be pulled in on strobe from income (or from cv bits) - cycle k[reg]DONE as 87inadcetc///

- feedback as in manually cut from in to feedback(norm) pull cable
in software: feedback=dac[2]->adc cut to other dac or adc in or between 2 different dacsDONEabove NLcutfeedback86

challenge of mode N is number of ADCs - less so for modeC


** 9/2/2022

- thinking to re-work noisy ADC to one-shot //
REWORKED but still need to deal with mode/adc DONE - *TEST*


** 8/2/2022

- working in modeN.h to assemble preliminary list of modes there, refining

- added new multiplespeednew - test in modeN

-TODO: test multiple speeds in modeN, 

DONEdetach modes for strobes- 2 cases - need to select arrays of good adc modes and categorise

** 7/2/2022

- DONE:trial basic mode - split length so handles xor/or in - logopxxx has the xor/or option too

- *sort probability and route/bits files* // starting with modeN and cleaning up a bit

- we can have say 64 as mode with no adc in 

** 4/2/2022

DONE- SR in SR again - how to embed one in another properly - with constraints - LLLSWOP

- full generic bit interpreter

- *can use CVL to select dacfrom and also mask in certain modes...*

- *thinking of 0-15 as basic length/speed modes and 15-31 as detached modes*

** 3/2/2022

- fixed speed issues now in interpol code - slowest is around 1Hz with 2^14 octaves scale in log_gen/resources...

- how far did we get with bitmodes? bit.h defining now for modeL, expand and then port!

*thinking about how have whole other path - so feedback is one extra limb perhaps//isolate/un-isolate*

where do we change dactype for NLR?/ C? also is 3-5 bitsDONE - in bit.h - so changes own dactype...

** 2/2/2022

+hit problem with slower speeds and float - fix from test2.c - either reset at 8 or 1024 or reset in ENDER?! test...+

- do we have prob of bumping up local route: in modeL yes

- TODO: generic versions of major modes, start to classify eg. generic version of electronotes with different bits
- routes tagged with NOT/inversion bits

DONEport dacspeed modes from modeN.h // and one xtra one

DONEmodeN: prob modes done, port electronotes and probability modes to L as template

*port from L to R and C maybe new modes* also multiple speed modes are in L - some for R only, some for C
also maybe some new modes across N->

*TODO: port generic ones into R and C from L in probability.h - done for L?!!!!*

- various detached modes for probabilities and generic probs esp. in ADC


DONEcan also have XOR opps for routing tables, where do we get dac/sr from - how to change this, mixes of DACs, all recursions

** 1/2/2022

In modeN (also modeC bit not so critical there) we can't have so many ADC/DAC select modes for each possibility:

so:

- start with 8 total basic ADC/abstract modes in. further mode on Cv select lines only - with probs, other modes...

DONE: prob modes implemented - added probability.h for all sides

DONE: for modeN.h we can select ADC mode (adc or abstract) and use probs, *TEST* probability.h

DONE: port prob_bits mode over to N, added Lintgenericprobx in prob

- added strobe modes in adc/modeN.h - DONE: these could also be toggles toggle entry/no entry

DONEcheck all bit/route options and any implementations

- fixed major bug in new modesL modes - as we already gshifted out the cycling bit

notebook notes:
- DONEin modeN: how to mix between CV control of bits and SR/DAC control - as we need 2 CVs (mix and CV) - detach both (in CV mode or one in intmode)

- NLBURST0: bursts of DACin/ADCin to spawn/seed feedback - so trigger
  means CV length of ADC bits in, no trigger is ROUTEin at otherCV
  speed, +can also be prob of entry vs. no entry/route in - this is already in Nintprob2_0+

- can also be burst outs in modeCDONE


** 31/1/2022

- if binroute and dacfrom follow same count or we move these differently - have 4 bits binroute (16 options) and 4 bits dacfrom (16)

and SR also onto both routes//from DAC - these are done TOTEST - //but what of clkcnt - follows dacfrom/daccount

DONE in L:untether/leave at set speed of entry (also same for length) - run at that set speed but have dac at other speed/cv - see above eg. pass on speed/gshift etc, dac speed*

DONE: port in extra intmodes, 41, 47, 64, 67, 68, 69, 104, 105

added electronotes modes in N


** 30/1/2022

// some DONE from below... question of detach speed or not...

** 28/1/2022

*which way round probs should be?* depends on mode!

+test if we should put speed calc inside loop+ outside as we use in CVOPENing

*again Q of using DAC from 3 when 3 routes in to 0 - how to seperate or did we solve this?* lack of routeins/option of route in...

- DONEdetach length and place assign in headn,l,c,r - TESTed, so we can use CVL if we like... and leave length as is...
- DONEnew mode 82 in adc/moden with incoming bit as comp

- DONEcombine routing and probability modes - to some extent in
  LDACroutestrobe0 but tricky, also prob can be speed, prob of advancing the SR-DONE, or one aspect of the SR-DONE - could be more

new sets of modes where we keep old length and use a new CVL for:
- prob and routings, double speeds/slippage (can also be with DAC), possible triadex mode, how to scale and offset DACs for DACspeeds -  define more of these
-eg. for adc choose adc in cvspeed, dac same, or probs of adc etc... - DONE to some extent in modeN and modeL, modeC for dacsels

- DONEthink how Triadex could use 2 CVs///port to SR

- DONEprob of changing local routing table - in LintDACroute0 and some strobe version in modeN

- TODO: finish new intmodes in L, port newmodes from L to R, figure out calc for filter speeds
  (once we settle on speeds), define all bits, start to organise each set of modes...

*question also if LR pulses in should be XOR or OR? - OR seems better TODO/test/change - or options*


DONE: cycling bit XOR with --> [DACout from own/other SR vs. comparator=CV/DAC/DAC+CV/CLKCNT???] - N84 and some variations

DONE: INTmode: probability mode where CV fixes bits (of prob) and prob is against DAC/SR onlys ???????what means - ?prob is our LFSR - so we fix bits of this one...
Lintprobfixed0/1

DONE: use other SR bits to determine length of SR, eg. can be modded or...  NLSRlengthselL0 and companions

/////////////////////////////////////////////////////////////////////////////////////

*notation system and define/implement all prob modes:*

prob taken from [X] of [Y] bit [LOGIC_WITH] [Z]

eg. TO expand

for ADC:

[LFSR, CV, DAC, SR] against DAC, LRC: ADC_buffer[12], CV, and combinations (ADD, XOR etc) of these - see EN below]

otherDAC, ownDAC

STROBE - invert ADC BIT - XOR/OR routed
       - invert [ADC/xor/or/routed] - NONE
       - ADC BIT vs routed - NONE
       - ADC BIT vs [ADC/xor/or/routed] - NONE
       - ADC BIT vs invert [routed] - NONE
       - ADC BIT vs invert[ADC/xor/or/routed] - NONE

for abstract ADCs we can also have RETURNbit
       - ADC bits vs RETURNbit - XOR/OR routed
       - ADC bits vs [routed/xor/or/RETURNbit]
	 [and inv of 2 above possibly]

for others/L, R, C:

- invert RETURNbit - XOR/OR routed
- RETURNbit vs routed - NONE
- invertRETURNbit vs routed - NONE
- routed versus 0 - RETURNbit

EN: LFSR SR bit is loaded/not loaded onto recycling SR. loading can be random (based on LFSR and set of probability switches). 
*prob is sourced from LFSR ANDed with CV/DAC*

comparators for probability and ADC depending on INT/CV mode

/for prob:
1. if LFSR/SR/DAC<CV  // int mode - as DAC is not necessarily CV!
2.if LFSR/SR<DAC[x]  // cv/int mode
3.if LFSR/SR<DAC[x]+CV // int mode
4.if LFSR/SR/DAC<param[x] // cv mode


** 27/1/2022

try to categorise and clear up modes:

  probability/if_strobe/toggle modes

  ghosts/reflections/walkins

  route modes/bit modes

  what are outs/ins

- how can we detach SRlength as is used everywhere as length?DONE

- ported in all newmodes. 

** 26/1/2022

- thinking on scale/speeds - at the moment we have 0-5v CV input and
  covers 2^10 - so 10 octaves...we want say 13 or 14 octaves - 0.1Hz
  to 5K for 14 octaves/doublings

*can we have knob covering this and 0-10v as 1v/OCT*

*100k instead of 200k for -10v and 33k in loop - as in Tides! (and can we adjust/scale input cv)*

// 14 octs in 1024 =73 per octave =140K of cv in maybe approx... (for 730 max)

http://lushprojects.com/circuitjs/circuitjs.html?ctz=CQAgjCAMB0l3BWcMBMcUHYMGZIA4UA2ATmIxAUgoqoQFMBaMMAKACVwU9wwURCALDz5UIA2lEkwELAIYgUCQp24DsfXt27Zo2EAx16w8ePpgnMkBMQQoU4-Bkgoyk4yZYAnFcIX5foiaQ7D4C3MTKYVIg4vrG0dJeodxoqtxUTvAsAO5+3Mx8isoFUElF-EJqfIKSKLhwLADGCkog6jHt7VQC0JlB-WCMxPoovVZkxC4RkMRqkOTmkKy55SXlNcErrTXlUZstkSn+ezkHMSmtXadVbXw3G9ftNTeapQDmZ2ACQuWpUo8aLgxCI+YIAe0kG3OhHI8UWcDIhCUilqkmwLAhYCQULUCCQSHhMwwSMIKIgGiQ6KAA

or 100k cv in, 23k feedback, and -10v is 70k

- *how to scale and offset DACs for DACspeeds...(two controls - leave length as is maybe)*


** 25/1/2022

- from notebook - DONE:how we could have multiple/split speeds (leave one/length as set and update others on entry?, or use strobe also which maybe we have already)

2x CV, strobe, dacs

1. shifting/SR speed << (but if is not aligned with bitin?)
2. GSR copy speed (own GSR) //copy on strobe? see 37 in newmodes - L3 in modeL - in/outside loop as optionsDONE
3. advance incoming GSR speed - slidings
4. DAC out speed  - slipping

-- porting in from newmodes.c, DONE:4 bit shuffle to come in from modeN.h

** 24/1/2022

- TODOcheck new notebook Qs:

- DONE: added dac comparator mode, compare with itself DONE/TESTED
- DAC as param for some abstract ADC modes (22-31) checkDONE
- all modes have local route in to change - from strobe/bump, from CV. from DAC is already done or? - in modeN, R, L, C tested///DONE
- added Ndacghostincoming0 using incoming ghost for speed in modeN.h
- +fixed speed thing in macro.h a bit/back+ fixed some of adc so can have multiple w (eg. for oldbt etc)
- added ADC choices in intmode: LintselADC_63, RintselADC_63
- added binroute NOG macros to macros.h to test in modes (in all modeX.h): no movement of GSRs....DONE/TESTED

Benjolin style patch: 

R-OSC mode -> N-OSC mode ->L-route in->Nout, R clocks L, L is dacspeed for N and R // multiple OSCs, ADC in L and R... (not in C)

doesn't seem to really work out!

- *modeR/where - change dactypes for 0, 1,2,3 (inc. itself)*, [or intmode in each to change own dactype 0-15 (but no strobe so 3 bits) - but then rest is fixed]
// where we set this? where we reset to defaults... is it necessary to change this


////////////////////

- changed some of modeN to avoid interrupt disturbance for dac incomings

- also dacfrom array is tied to count and gives dac and fake clks... change for new rungling scheme 

- should have array of what we route into - added routeto array with count to use for some Gshift modes

** 21/1/2022

- +maybe makes sense only have DAC speed modes in LR!* else becomes too confusing/noisy and we keep NC as more mode selections and prob for+

- Tested Rdacspeed modes: *problem again is that if we use DAC1 to set it also effects speed of outgoing (unless we route differently 8,1,1,1) but that doesn't make sense*

- added Rmode which bumps on ghosts - variations of this and can also be intmode and dacspeed mode


- DONEghosts of ghosts - strobe records a ghost of incoming ghost and holds this till next strobe/advances it, records new one, holds for length time?

TODO: when we use dac this should be from a table which can also be bumped around by modeR *dacfrom* which also uses/matches count or should it be otherwise?
DONE- but we need to test this thoroughly - clkroutes also follow the same logic

** 20/1/2022

- last of all intmodes selects type of ADC/DAC (except those which use strobe or use param). For LR selects functions with no params or strobe/so no intmodes

- fix for pulse out on C1 (bitn initialised as 0)

R- for CV modes add in bump up global routes, SR as global routing table

L,N,C - // for CV modes add in bump up local routes, SR/ghostSR/DAC as
local routing table - we have some of these in modeN to model from, we
also have a CV intmode router there

- we can also have modes in all cases which use (mix/xor etc in) their own ghosts (as run by the following SR)


** 19/1/2022

*question of 32/32 split of speedcv/dac // int across all modes as gives more param control

- routing and dac control is most important, also which modes use strobe and which not

*question also is if we use right DAC for lowest fake clkin - this also feeds back in to top when it is running:*

- *wider question of multi functions of right hand dac and how this could be otherwise: functions as feed through, as fake clk, as dac feedback input*

--- answer is maybe to have different dac options (where we take from) set in modeR

Still working on modeN.h modes:

- DONEput generic one back in so we can do ADC+DAC opsDONE - to fill out in modeN - what variations do we have? 7 bits

- route could also be N->C N->L L->R R->N which is 8,1,1,2 test

thinking also how it could be to have 2 speeds - one for entry into R feedback and another into L, DAC:

so 2 branch speeds??? how could this work??? depends on routings and if we mean primary speeds then we would need to run one SR twice



//////////////////////////////

how to choose modeN modes now...

we have:

*- 16x or 32x CV modes*

DACin makes sense with mix or is just like normed feedback - but interesting if we can change type of gate[3].dac DONE Nint70

0-7adc basics with XOR

other ADC in

strobe ADCs in

abstract ones

DAC/ADC mixes in

*- 16x DAC+CV to work out -> what makes most sense?*

0-7adc basics with XOR

*- 16x or 32x INTmodes all must use CV! we have too many*

prob modes
special modes-params eg, route, selects

/// *or shall we have 32 INTmodes and reduce CV modes*

//////////////////////////////

- DONEin modeN.h but need to check all/fix modes: for modes which don't use strobe we stop normalled clock and use strobe pulse as input - try OR or XOR
- check if is inverted - is interrupt on falling edge so not inv

*question if for modes which use DAC in ADC if we should NOT route in DAC or at least have both options - tested in N27 and can work/run out*

** 18/1/2022:

TESTED on 19th:
//*TODO19* - retest 6x, 10, 12*, 13, 14, 15, 16*, 18*, 21*, 27*, 35, 36, 37, 38, 39
//-  new ADC modes: 71, 72*, 73, 74,-DAC ins have tendency run out...
// 66, 67, 68 to test-DAC

//- +XOR strobe = 80,81,82,83,84,85+ - now we have strobe scheme so we don't need add modes

add new ones from adc_ into modeN TODO

////////////////////////////

*what are the basic ADC modes?*

-7 here:

  case 0: // basic sequential length of upto 12 bits cycling in MSB first    
  case 1: // equivalent bits: we don't need limit on number of bits
  case 2: // variations on one bit audio - also phasey
  case 3: // basic sequential length as in 0 but with padding if >11 bits **
  case 4:  // special case for spaced bit entry depending on length
  case 5: // basic sequential length of upto 12 bits cycling in - can also be xbits from param, max bits etc...
  case 6: // padded version of SR of bitsin ??? - now is 6 - was 8

- +generic ADCg_ function to implement/TEST (as above) but mostly keep other ADC+ = we get rid of as is only useful for DAC which we have - add modes/MSB there DONE see above

- new ADC_ cases +63+, 64, 65/also int65, int66 tested - 64 not so exciting.
- tested/in progress adc_66,67,68: ADC intmode various mixes of ADC incoming plus/modulo/etc/XOR CV[0]*
- tested: ADC-prob can also be against DAC rather than LFSR - but always CV against - Nintprobdac1_0

- TESTED: in progress: can we have one intmode with CV selecting non-param ADC input modes, can have another mode list or shorter mode list with route bits

- TESTcan also have mix of dac[3] and adc in cv adc_ modes... 66, 67, 68

///TODO:

ADC modes: *prob of entry, prob of return for abstract modes* 22-31 and some others now/new ones... in modeN.h

- theone, it.c, draftdec, extramodes to all be checked for adcmodes, see also temp.org

/////////////////////////////////////

- *for LRC modes we can also have prob using generic top ADC_buffer[12]*


** 17/1/2022:

- DONE: inverting CV for param/int modes as now 0 is top TODO! DONE - to test, but not all work so, changed, and do we need to invert for prob intmodes? no

TESTed/ok dacspeed from itself - Ndacadditself - can also be other variants


modulo LR modes to code/test - done in Lmod and Rmod

TODO: define probability modes, define all bit patterns, ADC modes from all files inc. extramodes, 

prob modes for ADC/ignore cycling:

- invert ADC bit -and- xor/or in routed
- invert [ADC/xor/or/routed) 

- select ADC bit in or routed in
- select ADC bit in or [ADC/xor/or/routed)  

- select ADC bit in or INVrouted in
- select ADC bit in or INV[ADC/xor/or/routed)  

for others/L, R, C:

00 1-TM invert cycling bit - OR with BITIN (OR (routed^pulse)) // OR (routedORpulse) ??
01 2-BITIN or loopback
10 3-INV of above
11 4- BITIN or not into cycling


bit patterns: 

-- where we get bit from=routing, subjected to type of SR inc prob modes, what we do with routed in bits

still LR modulo to test: https://github.com/TuesdayNightMachines/CGS-Serge-Modular-Synth/blob/master/CGS%20Modulo%20Magic/CGS%20Modulo%20Magic%20Guide.md


** 13/1/2022:

- HEAD macro should be fixed but check this DONE
- methods for DAC speed modes: (and now we use CV[w] instead) -> we have now in modeN, to test and to port to other modes TESTED bit *maybe no addmax*

** 12/1/2022:

- dac+cv modes to resolve with new scheme - a lot depends on where we get dac from (cannot all be same but nice to choose - 4 options = 2 bits)

TODO: ADC_for_our_speed - top bits//rest bits as speed/mod for DAC? - DONE in modeN but don't use there

test adc pointerDONE, fill in modes and testings->ADC, DAC, all modes from draftdec, theone, earlier... 

FIXED bug in macro as HEAD CANNOT BE within another macro...( note -E is to show macro expansion, do we need to fix for modeN.h macros?)

1 bit audio is still odd - and length does nothing here *again length issue in adc and adc* - *re-test*

- question of slowest speed as we already have 2^10 for 5v (0.5v octave)

** 10/1/2022:

*TODO: test best fake clk scenario - later when have tidied and basic outlines*

test trigger codeDONE, test multiple ADC and DACS, new macros

problem with init of function pointers from outside file... -> pulled function pointers out of the struct and all fine now, we init them in draftspeed.c

** TODO: Latest notebook notes:

- bump speeds (clock bumped speeds, clock shifts it on one, CV bumps in INT modes (HOW?) )
- bump own routes by trigger (do we do this?) yes in case 16 in draftdec/port!
- more DAC driven routes, use of SR bits for routing/what else, more of RH
- modulo - how that would work? one SR/DAC modulo another?

** 9/1/2022 +:

- DONE: no speed more than 1.0f - how we generate this? increase main.c speed accordingly

xx=numpy.logspace(0, 10, num=1024, endpoint=True, base=2.0) # num is now many we want // in misc/log_gen.py

- simulate fractional speeds and testDONE.

- interpolate or not? as in just keep last value or interpolateDONE -> INTERPOLATE

- draft new structure mode: what we need here... we will need to
  change trigger codeDONE/tested, clkoutsDONE/tested 

- will need clean up all but just test now...

we changed dac out but will need to change adc for pointer as some modes change it in place...DONE/to test!

TODO/DONE/TESTED: we also need to include stop! in speeds - even now for C modes...

- Right and Left are now seperate 
- Right with mode DAC action, more influence. character as routings, DAC and feedback, other INS into right side too (can be more TRIADEX style_
- do we only use DAC2 as out so this can be incorporated...
- jump modes << or slow down, out per every x shifts... 


* diary sept 2021+

PLAN: put first draft together
from generic we had all modes/options as:

6 bits: 1 1 1 1 1 1
- top bit/speed
- 4 bits routing in
- 1 bit prob of inversion

incoming bit bits summary (4 bits) - eg. prob of:

- pulse (if we have) (1,3)  3 bits- mod below?
- routed in = all - 2 bits still - none, route, route/loop, loop
- return/loop = all
- ADC (0) - 3 bits for 0

route in and logop bits:
1111 4 route in bits x 3 logops = 2 bits per... 0, none, 1, xor, 2or, 3leak = 8 bits = 255 too much for CV


trial bits:
pulse/cv speed, input ADC/LFSR/no, output DAC/else?, type SR, type SR, type SR(3 bits of types=8), routing from (4 options)  
1               1     1            1                 1        1        1                           1 1 1 1 - 4 bits just to make it easier but could be less
[11 bits]

speed from DAC/which DAC?

*\\\\\\\\\\\\\\\\\\*

- idea for 1 or 2 versions with different modes... also why generic version is silent on early/first modes - no incoming bits or loopback/fixed
- or major/minor modes from left side???


*QUESTIONS:*

- lengths and changes
- major/minor modes from right hand side
- OR into top/ADC
- generic logics/ all/ logic bits

- if each SR is quite different? or stay generic? ADC and DAC are
  already different, maybe LR should be or can also be swopped,
  re-routed, more routing options on those sides perhaps as extra
  modes

L as delay/entry, R as feedback and DAC - what makes sense for each?

but then ADC and DAC become just about input and output??? ADC in is fine (but we need options to OR in sometimes for pure ADC style modes...)

// re-check generic bit options above

- resolve split personality of patterns and cv//audio filter/crusher (split of modes at top cleanly? or but then what of speeds...)

TODO: re-test ADCs, *fill in CV/DAC modes for DAC and decide/port new LR modes*

[possibly reduce volume of final dacout amplifier as is 10vpp - but leave so!]

2/1/2022:

new approaches: function pointers, try speed scheme from WORM so also oversampling  and interpolation - draftspeed2.c

trial with oversample etc (now divider is 32/32 or 32/64)... seems work fine but we don't get slow enough for CV speeds...
(for cv/dac modes - but that means fullspeed pulse modes will be slower by default??? or we slow down cv modes???)


how to implement function pointers...??? as bit selects???




/////////////////////////////////////////////////////////////////////////////////////

31/12/2021:

- back to testing with OR in on ADC modes (*use XOR for logical/nonadc ADC in modes*)

- tested all ADCs and DACs now - DAC section is a bit samey...

- if we use DAC3 for DAC modes input in ADC is very easy for feedback to run to 0...

    // maybe lose just cycle mode

30/12/2021:

TODO:
- DONE change default dac for all except w==2 to simpler (but we can't just & 4095 for shorter lengths)

- ONLY works for some so removed->try OR in of RIGHT side to top (logic in routings) - in mode 0 and ADCDACETC macro, add to ADCONLY
[OR in at top gives more natural effects but fails too many times - how can we keep as an option? with bits, as one ADC mode]

- DONEtrial of another approach to fake clocks (but would be better as own ghosts???)

question if right hand has more limited trigger or toggle modes

again clash generic LRupdown and more individual...

8 or 12 bit spacers CODE at home

- DONE: bump and toggle routes via trigger as LR case 16
- modulo? // addition of overlapping registers

case 19 to retest on 0 for incomingsDONE

looking at generic code and inputbit there which is not used - more suited to patterns/abstract

resolve split personality of patterns and cv//audio filter/crusher

generic: topbit is speedfrom, 4 bits route and 1 bit doit as prob mode or not!

29/12/2021:

- clk is now HSE and should be 180, we run with 32/16 divider and seems fine
- other small changes and fixes

28/12/2021:

- speed seems to be a big issue now...// how to speed up?

- but there will always be a slowest round of options so doesn't make sense just to speed up some of it if not all

-2. what is in main interrupt loop?
-1. how fast are other interrupts
DONE-0. are we running as fast as we can 180MHz or so... clk is now HSE and should be 180, we run with 32/16 divider and seems fine
1. not execute all DACs but just use SR (and what of shifting? - we simplify to new mode 66)

2. different structure so all in one go w0-3 and slow down all...
3. faster ADC, different structure//one by one? what does sampletime change?
4. generally faster codes, ifs, swicthes, leave out some things
5. check speed of generic code
6, mix of slower and faster modes
7. idea of major and minor modes still and mix between and how we can achieve this...

issue in general to resolve: 
- length as parameter for output (then we need to fix on length as 12/DAC or ignored, or CV so that parameter can have different functions in DAC).
- arbitrariness of modes and positions (L, R etc), again question of being between generic code and very specific modes...
- fake clocks

// also fake clk for lower sometimes gets stuck

- still working/testing ADC and DAC!

- confirming that for straight through length (above 11) doesn't change anything (also length of left pass through) - becomes one long sr

- re-check paddingsDONE- doesn;t seem to effect much as we still have freq of padding?

- how 8 or 12 bit spacers could work

// some problems programming, also had to slow down main.c TIM2 to 10 prescaler - not sure why?

26/12/2021:

- think in ADC of reversing for MSB or at least doubling a few modes - we already try a few, also think more about size and padding

24/12/21:

- think steppiness is from nature of SRs, implementing few other adc, dacs and also MSB dac for MSB first out so is first in and gets shifted right
- sigma delta also makes sense so phasing i guess is normal


*- how to get 8 bit spaced out from DAC?*

- thinking length for L and C is not so active but depends on modes, speeds and what they are used for...

how to have that extra no route in mode for Right side - just leave it in as there are enough options

23/12/21:

still need to test all ADCs and think on steppiness of DAC

*add more binroutes///*

[- add right hand mode 0 where it sets own GSR to 0! so no feed through...DONE/TESTED fine...but skews modes/left in anyways]

Run through of ADCs:

-  length-11 was correct

- mode 2/one bit audio ADC still has phasing despite a few changes...

- fixed dac mode 0 for shortest one bit length - still steppy and added one more dac mode

[why doesn't length of intermediate SR change much/anything - changes nothing if run at same speed // because gshoft is always new]

22/12/21:

-ADC remove cycle and replace with no pass thru//finish DONE-changed modes 0 and 1 for ADC!
re-ordering ADCs but re-check which ones need parameters - put param[0] for all...

- drafted minor/major mode structure in extramodes.c

TODO: re-test all ADC or/esp11, classify LR modes

- for INTMODES: how many speed options here? just keep as pure option so can have 16x INT modes and 3x4 DAC


/////

-removed case 15 from adc cv modes, 10,11,12,13 strobe modes as also boring

thought of only having 16 adc modes but makes no sense for routings - back to 31 but re-ordered and need to re-check params

7-13 are all strobe modes, 17 too - reduce number of strobe modes

15,19,24,25,28,29,33,34 not in CV modes

ADC group by:

-type of input (ADCbits?, LFSR, clock etc)
-strobes/otherparam

Important adc: xbits, one bit, 4bits in (case 16), padded + LFSR etc...


21/12/21:

- check each ADC/DAC in turn - note that modes in adcetc.h don't match the case!

ADC (0-19 now):

TODO: new adc with x bits ADC in subjected to LFSR - doesn't work but added versions of these

0 should have adc in and another mode no in with pass through so all 0s still runsDONE

tested up to 11 (12-19 todo), fixes trigger as static/is it needed?NO/replaced

DACs:

DAC: 2 (is a bit muffly at long lengths - can change divy to fix this in resources.c) RETEST

mode 18: toggle is more exciting for 11prob mode/// whether to change that toggle in LR modes? we did!

changes to case 10 in dac, 11 doesn't really work - replaced with 9, and we had to add missing param[2] in draftdec


///////////////////////////////////////

- DONE: added in normedd L,R,C clocks from Cspeed2 - using new count5 - seems to work// *can also have LR as DACs?? maybeDONE-TOTESTwithINTMODES*


- idea of major modes on R (say 4) - for different ways interpreting bits // different probs // as we have multiple dacs 

// base some on generic but we need to fix 0 no routes/in to default to 1

but problem is we cannot mix and match these... and we can kind of implement similar bit interpretations anyways

TODO: 

20/12/21:

0-15 filled - to test ADC and DAC as fixed and also all modes to find weak points
15-31 modes to fill and rest to figure out this week!

////

- grouping early strobes

proto for SR>DAC is: if ((LFSR_[w] & 4095 ) < dac[LFSR[w]]) // as that is 12 bits and shifted already 

change/d all modes in extramodes.c to use the dac[LFSR[w]] above rather than SR or both & 4095 but if SR is small...


which strobe=prob modes work best with DACout 4x4 in modes 16-31 // we use 00 and 11

4 bit mode works well but does it always need to coincide eg. all 4 bits - seems fine

- fixed bug with many [x] and not [w] outside loop 

- TODO-   // 4x4 bits prob of routing in GSR  so we need 4 probs of x bits?
- DONE: decide/ if implement simultaneous shiftsNO! stick with old one as seems most logical and we don't change order...

16/12/21:

- DONE: probability of advancing a GSR - as mode 14 test 

- DONE/not working as no entries...x bits of sr << y bits of gsr - shifting bits ORed in as/to new SR

15/12/21:

- // can also be change access bit but not cycling bit - also cycling version of this! TODO!->DONE/TODO: mode in which CV/pulse changes which bit ofghostSR we access - mode 13 works fine	
- TODO: also test with CV access for these bits

14/12/21:

- what are 4x4 DAC modes for 16-31: 1cycleandroute, 2/3probs, 4-4bitshuffle? - see temp.org for modes list

- TODO: probability of advance on trigger using CV as probDONE-tested

- organise modes we have in some kind of scheme: 

speed
incoming: routes, manipulate ghosts, change routes, basic routes
what we do with it: prob modes, where we get prob from, what logic we use and where we get choice of logic from?
special modes

or group by way of: strobe in cv, cv in intmodes ???


13/12/21:

- trial of changing way it updates = if new[w] - not sure which to use

  // testing for simultaneous shifter - but what of modes where we hold back the gshift eg. modes: 37, 48, 49

- DONE/TODO: mode in which CV/pulse changes which bit ofghostSR we access - mode 13 works fine


10/12/21:
- re-checked logic of ghostSRs and compared in test2.c

- question of order of SRs (w) - trial changes to tables of orders // test2.c first

// order does of course make a difference/depends also on routings

also how we can update/calculate simultaneously (how this works for feedback, or is a delay necessary?)
- more is that all runs at different speeds///

9/12/2021:

TODO: list regular and extended modes!

- added toggle/pulse prob modes 7,8,9,10,11

- added mode 12 with non-adc ADC_ in to LR - 3 diff possibilities:
  ADC-5, pure LFSR on length, 30 1 bit OSC, 32 clock/square (these
  could also be bits or bumped toggle options)


8/12/2021:

- *manual idea - we have say ascii layout on dot matrix and then subject this to shift register*

- moved the if (w==1 || w==3) // if pulsins[w]!=0) out of the macros as most of the time we don't need to test this - this is now LR[w]!

- for pulsin not so much difference of XOR, OR and we lose AND for zero pulsins... so leaks or xor it is and leaks needs changing probabilities

we try now with own SR as probability and this seems to work well for pulsins

?can also use GhostSRs for probs?

- trialing 2 different bit interpretations in draftdec - DONE

- if LR can have non-adc style inputs (eg. LFSR, pulses, clocks etc) XORed with incoming routing - how many options are here?* DONE
- this could be an INTmode!

- basic prob mode of entry of routed or not (into cycling). and just xor puls in...DONE - mode 6

7/12/2021:

- attempt grand mode with SR and many bits above - we have 8 bits route and logop and 5 bits probability DONE

- in ADC_ added cases 33 and 34, adc prob modes with adcpar (invcycle is more like ADC mode if is without routein)

- TODO: generic prob/strobe/toggle modesDONE

6/12/2021: 

- fixed major problem in MACROS draftdec // if else...
- one bit filter DAC always now has param and is mode 2 - so param can
  be cv/param for variable filter or can be calculated from
  speed/param

3/12/2021: listing modes in temp.org to plan out and also check gaps: conclusions:

how we can temporarily fill modes and change these later? macros but then we have \ always end of line to think of and no comments. maybe...

- question also of modes with global route table or which manipulate their own routetable

*we need more modes which take cv or dac and use this for routing, for probability tables, for logops*

- summarise again probability modes and all modes/cv/INT: = we have too many

32 CV modes, 16 CV+DAC modes, 16 INT modes (very basic and prob driven)

1. basic pass/cycle/passandcycle with logops for cycle and for bitsin

3x logops: xor, or, leaks...

1-pass in - xor pass, xor puls
2-cycle only - xor cycle, xor puls
3-pass and cycle - xor pass, cycle, and puls

4-xor pass in and or puls
5-xor pass in and leak puls
6-or pass in and or puls
7-or pass in and leak puls

8-xor pass in, xor cycle and or puls
9-xor pass in, xor cycle and leak puls
10-or pass, or cycle in and or pass
11-or pass in, or cycle and leak puls

// further permutations of these or just leave to CV/param bits for logops

2. prob modes: 

- where we get prob from. CV/int, DAC/cv&int, DAC+CV/int, param[x]/cv

prob<DAC:

1-inv routed bit/ xor puls
2-inv cycled bit/ xor puls
3-inv routed and cycled bit/ xor puls
4-inv routed, puls and cycle bit
5-inv puls and route in

6-xor cycle in with routed or not

limited selection as above with prob<param

less of pulsins and probs as gets too much

- prob of: -invert incoming bit (ADC/mode0/routed, cycle or pulse-ifwehave) or not
           - XOR bit in from->[cycled//ADCorLFSR//pulseifwehave]->routed in or not
           - incoming bit(routed,ADC,pulse-ifwehave) or cycling bit
           - as above with inverted cycling bit
           - changes/manipulations to the ghostSR

3. binary route/prob/etc. tables - CV as binary route/prob bits/

look again at binary routing tables and prob bits

4. experimental/overlaps/other functions 
5. use of strobe in cvmodes - doubles prob modes

so strobe can toggle or straight do: invert, XOR incoming, incoming or cycle, incoming or inverted cycle

6. use of CV in intmodes // these are probmodes so other uses

7. change global routings
8. maniplates of GSR // GSR on prob, on strobe

modes to add:

- clock101010-DONEinADC32
- toggle ADC entry or pass (0)... check in adc? ADD in modes
- where do we add prob of ADC entry bit - in mode itself - but this doubles up modes//how to deal with that
- prob to shift binary/routing tables

2/12/2021: 

also pulsin_logop  - placed pulsin within adc macrosDONE
and logop in routing (below) 

ghostSR manipulationsDONE

[[[what those manipulations could be - freeze itX, freeze its lengthX, reverse it - but how to reverse based on length - reverse lowest srlength bits
in draftdec, XOR it with SR DONE -> these can also be for circular routes too

1/12/2021: now draftdec

- *logop in routing too*

summarize: TODO: draft all modes in draftdec but we need 14 modes for DAC (lose 1=mode9)  and 29 (lose 3=modes15, 31and19) for ADC, fill in LR modes for these and test

but possibly mode prob modes in ADC or keep these more for INTmodes? think about

but we don't delete them

- check clksr in adc/dac, clksr is in ADC_ = 19, in DAC_ is 9 sieving out  - maybe dont use clksr/both or use clksr more in LR modes

prob for DAC modes, range of clkin params (how to measure?), 

manipulation of ghostSRs: -> eg. from seg2.org: - XOR whole ghost reg shifted by another into itself
 
- TESTED:full test of latest prototype: audioadc?, ADCsX/CVX, DACX, clkins, pulsoutsX, pulsinsX!

30/11/2021: 

*- probability modes for DAC modes are important*

- 333 and 334 tweaked and working, need to watch that we have GSHIFT already in ADCETCblah

29/11/2021:

*ADC_:*
- otherpar modes: 24(len), 25(len), 26(comp), 28(prob), 29(len), 30(lengthforosc), 31 (lengthforosc)
- REGG modes: 2/lfsr, 4/lfsr, 5/lfsr. 6/DAC. 11/lfsr, 12/lfsr, 13/lfsr, 19/dac, 27/lfsr, 

*DAC_:*
- otherpar modes: 10length, 12-5bits, 13mask, 14mask, 15beta 


for otherpar as len let's use otherpar=otherpar&31 rather than >>DONE and we restrict in all cases &4095

all otherpar assumed as 12 bits!

- that we don't need seperate modes for int/cv in adc_ or dac_ as they all use otherpar... we just need to decide which modes...

add modes 15 - param as bits 

MAJOR question is how we can constrain param as INTcounter to be 12 bits - DONEwe need to get an idea of range of param as we treat as 12bits? - param[]

  // crash detect ++ 32/64 in main.c is 14KHz //and/or speed check... we have 32 16 which is 4x14=56KHz

so TIM2 loop is 56000 per second - one second is 56000x2// count to check

1khz is 56 - rather 120 or so...

100hz is 1280 so for 4095 12 bits we have 25Hz

we need to constrain to 12 bits for otherparDONE


TODO/DONE: - modes which manipulate the ghostSRs! - what those manipulations could be - freeze it, freeze its length, reverse it - but how to reverse based on length - reverse lowest srlength bits


26/11/2021: 

- new additive test mode in draftnov.c to test and expand...

/////

18/11/2021: 

QUESTIONS:

- 0-31 all ADC modes - as loopback doesn't make so much sense, only thing would be probability which could be part of modes

(probability of entry or not of ADC bit) - doubles ADC modes though?
these make more sense in INTmodes (also where we have no strobe modes
so this reduces list)

arrange and organise

- again if we don't use redirection of LFSR[reg] then in some ADC modes - how we could work with this//? or replace with reggDONE

17/11/2021:

[fixing some of generic.c for performance use]

Question of max length bits in or padded bits in ADC

- where we also change logic of incoming pulsin bits? 

- test param in DAC for one bit filter/BETA - DONE DAC mode 15

start to fill in draft modes/organise ADC/DAC modes...

16/11/2021:

- shift x bits in/shift Gshift round DONE mode 67 in theone.c

- tested speed with clk and is fast enough so far (re_check after all switch/cases) - can even go faster:   TIM_TimeBase_InitStructure.TIM_Prescaler = 8 ???

- TODO: fill out adc/dac modes in new draft, 

- maybe port in more modes from it.cDONE

- and also maybe deal with ghost tapsDONE

  // try putting LFSR feedback into smaller coggSRs - mode 62 TESTED

- added  case 64:// as 63 but we try INTmode with CV changing length of incoming routes

65 with strobe as barrier DONE

- question of generic/global routing and feedback into itself????? 	if (tmp&0x01 || x==w){   // if we want self-feedback in route whatever... MAYBE
and/or variations of this?

15/11/2021:

- for all w==3 modes except route changers we need to set count back to 0

global routings:
INTmodes: CV as route (CV cycles through list or changes list then binroute would change) + fixed new routes

CVmodes: trigger bumps up binroute + fixed new routes, trigger toggles altroute/regular routes (also prob?)

DONE: fixed otherpar and strobe in DAC...

TODO: port in first it.c modes above// first a few attempts in draftnov

13/11/2021:

- case 59, generic routing with ADC working // test in case 59 w==3 global route changes...TESTED - in case 59 and works ok...

60 very generic routing with MACRO fill in/ 61 speedCV complemented by trigger

- check out macros with variables to throw in - test in case 60 now but possibly too generic or we need to add probabilities...

QUESTION of how to manage modes now - first finish ported in modes/all modes // check logicand then start to see how we can draft modes...

12/11/2021:

- case 58 approx generic mode is workings

- leaks using RSR is a bit odd, but we can have different leaks which could LFSR...

11/11/2021:

- thinking if to have global routes or just individual changes to
  routing table? could have global if have say 4 R modes multiplied by
  4 route modes for each section... test global routes...

- not to have several ADCs in/no multiple DACs - but still keep basic dacs for 12 bit length

10/11/2021:

Q is of a new structure

- LARGE notebook notes: possible to use Rmodes as global modes for:
  global routing changes, +multiple DACs out/mix+, +potential several  ADCs ins (in different modes)+. 

  In CVmodes we would either have fixed modes brought in or param, bump
  up routes. In INTmodes we could use CV for modes.

- probability also to bump/shift or otherwise modify routing/logic etc. tables (single or global)

prob mods bits/masks bits

defroute is the one which we use generally now - unless we are in multi-routing
modes? (or DO we make this global default, but is much slower - think about)

pass/cycle/cycle and pass as routing only

////

- TODO/some for finals: more param[x] modes perhaps, 

different speed options for projected CV+DAC modes 32-47, 

new prob modesDONE, 
check bit routings againDONE and added for testings new bit modes (bits for prob and logop)DONE

try out new routing (eg. bounce back)

can add more mixes in ADC (adc in/lfsr/otherdacs/mult dacs etc)

- removed intcnt but need to fix triadex mode 35 - q is what is range of param? FIXED

- added logopx which can just return our bitn

9/11/2021:

- possible multiple ADC in modes,,,, 

- added case 30: adc |(xor TODO) with length of bits, for INTmode this can also be CV-param

in ADC_ otherpar can also be CV for intmodes

- expanded ADC_ function for extra params but should decide on how many bits for otherpar (dac is 12 bits so) and then fix length/restrictions there

- added logic table bits and fixed leaks in logop for modes 25 and 26

- notebook notes: ADC bits choose: what is compared to what, what is source...???

- one INTmode for ADC/DAC could use CV to select 1 of 64 modes - but
  then we have problem of otherpar being different sizes, sources
  eg. from strobe, for len bits etc.

- mode also (maybe INTmode) to select different DAC modes for LRN too!

- to think about/test multiple DAC outputs - additive, sequential, what else? and how these are signalled...


8/11/2021:

- how to expand and contract routing for each SR. what is contracted=just-to-itself, most expanded= last one..., between=

long routes would be n-l-c-r-n

Q. of whether to have extra ADC/DAC modes available as CV options on 1 or 2 INT modes - see above - would also need to be another long case/switchDONE

- INT modes need to use speedCV (see list in notebook)
- so the 16 INT ADC/DAC modes need to use CV
- added modes, ADC prob mode...

6/11/2021:

- toggle/record/keep frozen bits and keep these ORED with the shift register as it cycles or does whateverDONE now as DACmode 15-TEST!

5/11/2021:

- reverse SR modes - 42 and 43 DONE 43 is not so good/reverse cycle round/// try combine with 42 -> 44 DONE which is better

- toggle/record/keep frozen bits and keep these ORED with the shift
  register as it cycles or does whatever - testing now as DAC but it
  should not mask itself???

4/11/2021:

- question also if we use dac[3] and this also does feedback in - maybe try dac2 or dac1

- also if we make use of dac[x] where do we set this to be other_than_default otherwise we may as well use SR instead (except in multiple dac mode)

//TODO: fix on multiple DACs and which DAC or SR we use by default for each SR...

- DONE: fixed param in DAC so we set par=param[x] or cv in the case! but we need to remember to always add this if need be!

- DONE: changed DAC_ with extra params, added ADC speed and comp modes, some work on DACs, seq DAC not so exciting...

- bit length can also be CV - how to put this in as DAC is quite fixed in macro

ADC modes:

- that we can use param other than LEN for bit length in some of ADC and DAC modes... (eg. CV also as param in INT modes with these)DONE

so we can have standard 12 bits (len==11) adjusted to length, full
length (whatever that is) regardless of len, and xbits from otherpar -
in these cases length doesn't do much...

DONEpadding for seq adc, dac and strobe/adc modes 

*basic routing modes:*

- route in from sr[x] 
- cycling bit
- LOGIC (or,and.xor,leaks) - route in from sr[x] and cycling bit // xor one would be rungler in adc mode with dac from other in, or would be CGS

and LOGIC of pulsins

TODO/check: *all classic probability modes:*
classify:

[prob modes for ADCin/w==0 prob of entry of bits/vs cycle etc, DAC modes can use regular prob mode]

prob to DO:
invert cycling bit (TM)
invert incoming bit (ADC or route or both)

take incoming bit (ADC or route or bothLOGIC)/OR/xor it with cycle bit (RUN)
take incoming bit (ADC or route or bothLOGIC)/OR/LOGIC it with cycle bit

incoming bit(ADC or route or bothLOGIC)/OR/cycling bit (EN/WIARD)
incoming bit(ADC or route or bothLOGIC)/OR/INVcycling bit

////
TM: cycle bit is noise vs. comp less than 1, otherwise invert cycling bit

RUN: ==not prob mod but could be made one: XOR cycle bit with input bit which
comes from oscillator [in benjolin the DAC out effects some parameter
of both clock and data] eg. DAC effects speed/clock of SR

WIARD: noise/comp selects new input or loop back/inverted loop back (jumper)

EN: LFSR SR bit is loaded/not loaded onto recycling SR. loading can be random (based on LFSR and set of probability switches)

*comparators for probability and ADC depending on INT/CV mode*

/for prob:
1. if LFSR/SR/DAC<CV  // int mode - as DAC is not necessarily CV!
2.if LFSR/SR<DAC[x]  // cv/int mode
3.if LFSR/SR<DAC[x]+CV // int mode
4.if LFSR/SR/DAC<param[x] // cv mode

can also use comp clksr_ as SR, and adjust routing of SR for comparators

/for adc:
compare to: CV, DAC, CV+DAC, to clksr_, to param - feed these into otherpar

could it make sense for DACs? DAC could be shifted by CV or by clksr_, other DACs.

CV modes which deal with CLKIN - as a bit // - as a condition // - as a PARAM

- clkin in can toggle entry/no entry of new bits, cycling etcDONE do also for ADC
- clkin in can bump up/shift left/right the routing table, speedfrom table, logic table, dac/adc table?
- clkin in can mask bits as for DAC etc. or SR etc - if we pull it in to a SR for each of N,L,C,R  but bwhen do we do this as can't be in INT
- clkin in can also slip/slow/bump up one CV speeded SR = slip, freeze or jog SR on CLKin

*how we use CV in INT modes (as we need to use it):*

- as comparator for ADC in (and for DAC?)
- for LR modes: as comp. for prob modes, to assign routings, as extra mode selector
- as modifier for CLKIN speed-divider?

3/11/2021:

- DONE: more macros but still need to test/re-test all

- if pulseouts should be after shifts ??? guess so...

- in ADC: why (length-3)? to get down to 1 bit so could also have option for full bits!

- tested speed/stop again for all modes? - TO IMPLEMENT as makes sense
- fixed case 3adc and case1dac so we can have as many bits as 32 for equivbits setupDONE/TESTED
///
- incoming clk bits as further SR in main TIM2 loop (question of speed
  of this now) - or do we just do this as ADC inputDONE but could also
  be custom oneDONE - use also as sieve (case 10 in DAC) - what other uses? as comparator for ADC in?

- strobe or copy clksr in // as adc option... question is how to strobe in - on a counter/length? added as adc case 19

maybe list the SRs that we have available...

shift_[x], Gshift[x], LFSR_[x], ADCshift[x], ADCGshift[x]??ghostforadc/strobe, GGshift[x], clksr[x]

how to swop between relevant ones?

- probability modes can also use DAC, clksr etc,,,  what we compare to what???

LFSR<CV(most), LFSR<DAC+CV (17), LFSR<DAC (18), LFSR<PARAM (19)

also maybe more use of comparator with these in ADC mode

////

- start on first 16 modes/check all ADC/DAC options

- tested speed/stop in case 0! add to templates
- new full 32 bit ADC mode with padded bits in - also add strobes and other ones using this 

2/11/2021:

bit entry SR (from each CLKIN) can also be used for TRIADEX style thing,

all SRs/and CV can select routing/logic/speed bits

ADC could also be used in probability modesDONE

templates for speed/dac modesDONE/, INT modes but also how we deal with split of modes for DAC/ADC? (if...)

test new speed options!TEST!DONE!

////TODO:

- TODOs from theone.c - eg. extra DAC modes but now we have too many modes/cases,,, maybe to simplify

LIST MODES so far! and notation of modes

- what modes we already have implemented? also what ADC/DAC - plan to finish/draft?

- feed back RSR could have stop/no motion at top of speed (but how to do this without an IF clause?)...

/////

TRIADEX notes (from below etc):

- in original: any of SR bits (from any SR), CLK and its divider go as 4 bits into parity generator
- we could use counters from clkins as indicator of which bits from which SR to parity-inDONE

////////////////////////////////////////////////////////////////////////////////////////////////////

1/11/2021:

- DAC_ re-test case 7 and 8 as possibly fixed mistake there...DONE

TODO: 

- macro for pulse outs DONE
- what we need to test/implement and list of modes...

19/10/2021:

basic modes: pass through or cycle is toggled by clkin bit

TO TEST/adc strobe modes a bit similar...

new adc strobe modes: 12,13,14,15,16 - don't notice so much... maybe replace with toggles TRY THIS!DONE

new dac strobe modes: 5 and 6... - 6 toggle one works ok


- hold last DAC value (or ADC/set of bits) on a CLKIN 1
- toggle hold on a CLKIN 1 

- these are like the strobe? strobe is different in both cases - in DAC case is just inverse of strobe

15/10/2021: how to think about squash and expand routings on level of individual SR

- DAC out from ADC in

route goes N->L->R->L->R so implies sequence - order through a
sequence, and a length of sequence but does this not need to be agreed
on across modes as each SR just takes care of WHERE it routes from... but this could for example cycle every X turn 

cycling of in routes!

0123
eg. for N/0 cycle would be: 3,2,1,3,2,1 (depending if we include itself- 3,2,1,0)

what would squash be? 3,2,1,0 to 3,2,1 to 3,2 to 3(R) and how we signal the squash...

14/10/2021: for 4 bit spacers maybe also have options for different routings... squashed routings, compacted routings

sketch out modes:
CVspeed:
1-15 -LR simple modes/all inc prob
      N 8xADC x2 - pass in/circle_and_pass or 16 ADC modes with pass in only!
      C 4xDAC x4 - pass in/circle only/circle and pass/prob

16-31 LR - exp modes
      NC - any match modes 4xADC, 4xDAC

CV+ADCspeed:
32-47 LR - modes mixed
      NC as 1or2

INTspeed:
48-63 LR - mix using CV params - prob,,,
      NC 4x ADC/DAC and prob modes    

13/10/2021:

- fixed 4 bit spacers i think... mode 27/28: xor returning, also 4 spaced equiv bits for DAC DONE/TESTED

- ADC as seperate condition in each mode, maybe DAC too, subset of basic ADC and DAC modes...

so eg. 4x basic ADC and modes would follow: circle, pass on, circle and pass, basic probabilities
and some more exotics...


12/10/2021:

plainer that input mode NSR is most fixed of all, we can have multiple
DACs out from anywhere, also everything does not necessarily need to
be on NSR

- array of certain values eg. dac for each mode, how to simplify if at all?

- probability modes with routing/adc selects for incoming bits

- spaced outTODO

- triadex muse: clocks/divisions/SR bits selected and XOred back in...

- how we select those options -> we need 4 bits back in (so 4 to select from other SRs, bits from own SR)...TODO

or ghost SRs - select 4x bits 0->SRlength from 4x SR? or just stick with itself - variations on parity bits

- inspired mode where we XOR in other SRs. -- and we use static SR or we wind through SRs... or multiple XOrs in -> modes20,21 DONE

//new defroute: uint32_t defroutee[4]={3,0,1,1}; // 0,1,2,3 NLCR - in this one 3 routes from 1 too
but how do we have this in modes as is same just not for RSR...

one option suggest as clkin flips that routing (or any routing, or advances routing table)... DONE


11/10/2021:

*Q. type of binroute - if this should be fixed/detached by function/CV?*

- what we can salvage from it.c: overlaps, SR in SR, how we could pick up or work with other ghost regs, revenants, various 4 bit in variations

starting to think about 4 bits in/out for different lengths: GENERATE:
array of masks, 4 values for spacings, SR with 4 bits in needs to
cycle on those 4 bits...

they need to be spaced out x bits apart depending on length - further array


/////////

- from AC: shifting array of ghost taps, otherwise lots of dependency on pulses we don't want

24:	// Insert pulses into SR at points determined by CV or by pulses in - very similar to mode 2 above - TESTED/WORKING!

25:
	// SR loops within SR at certain points?/sizes determined by CV or pulses in = basic SR of OR with incoming bits - TESTED/WORKING!

// pulse in means a divide/flip flop
// pulse in means double a step..

uses CV as speed/flipflop/clock divider in INT modes

using clock as on/off gating of functions

// also we can have one bit data with selection of params for BETA/low pass filter!

DONE: sketched out probability modes - to be filled in, further ADC modes and tests...

- how to reconcile multiple modes with multiple ADC/DAC options -
  reduce number of modes in those cases ...

- working through probability modes - to figure out how ADC options (and DAC) fit with these...
eg. with adc in mode do we do for all 

- also further question if we have multiple ADC ins? (ie. max one for each register?)

- 4 bits In/out with DAC/ADC

///

1-Basic modes/DAC/ADC modes
2-experimental modes DAC/ADC too: eg. *set parity points for LFSR or for entry from other SR... (4 parity points or more max?)*
3-probability modes
4-routing modes/extra speed modes

DAC and CV, INT and CV -> speeds

8/10/2021:

- adding ADC and DAC modes: some still to test like strobe driven...

- where we place probability code?

question of overall structure now:

speed/where we get speed from?

route/bits/in + modes which manipulate routing or SPEED table (with DACs, CV, INT/CLK options, SRCLK)

ADC/DAC types

special modes/emulations: prob modes

7/10/2021:

- modes 6,7,8 are quite destructive noisy with pass&loopback for DAC and ADC - so maybe remove these
- try counting pulses (12 bits=4096) within length of time for use as parameter...(q of speed...

main.c TIM2 32/16=// period 32, prescaler 8 = toggle of 104 KHz - so 50 KHz

- re-did param code so is now time between pulses...

- DONE/TESTEDtest equiv bits ADC code, add in onebit oscillator

4/10/2021:

First 5 modes done with LR/route/logic options and ADC/DAC options-> these also need new routes and logic

TODO: experiment more with leaky code and timings, triggerings of leaks...

/////

add in DACs into ADC and DAC modes/INT modes only if we use CV???

//for input modes
CV/param//+DAC as input
CV/param//+DAC as comparator for input
CV/param//+DAC as input spacings [where is placed into SR]

CV/param+DAC as output spacings

CV/param selects routing 
CV/param+DAC selects routing


Try to condense what we have here in segmodes into:

- ideas for modes to be implemented/tested:
- layout eg. speedfrom, routing, ADC/DAC:
- generic/functional ideas eg. how we count pulsins:
- ideas relating to LFSR, ADC, DAC etc...:
- file under OTHER:
- esoteric:

INT as signifier for interrupt/trigger modes

- re-routing is not so important - can be in INT selected from CV/DACplusCV
so CV/speed is more or less fixed routes only maybe with one exception

Q of more trigger modes?

- can route DAC(+CV if INT) -> ADC inputs

- different ways of counting pulseins (eg. reset generic counter on pulsein) or count gap between pulses = number of pulses in time xDONE

- swap over SRs on pulse in?!!

- INT mode: pulse ins (only have L and R) can toggle SR on/off - eg. hold it even against new CLK/INT

1/10/2021:

from below: for 1 or 2 of trigger modes: SR->bit speed (ANDed with CV/trigger) eg. if && bitx//and_train of pulses also (see below)

- idea that CLK pulsins could trigger train of x pulses at speed y
  (eg. y by CV, by DAC) - descending speed, speed from other SR, train
  from other SR - how to do this?DONE 104/105tested...for INT-DONE

////////////////

30/9/2021//1/10:

- possible SR modes adjust/set certain settings which stay that way until they are re-adjusted?

- that incoming bits/pulse bits could also be formed in SR which can be used (as DAC, as whatever)

- interrupt/trigger modes with CV as divider!

// question of how to organize/list modes as there are simply too many options even with fixed routings

eg. each has:
- basic/logic//type of SR eg. simple pass, loop, pass and loop, other logics, probability of bit in, of a flip

- for CSR we have DAC mode!
- and for NSR we have ADC/LFSR (2 options plus more esoteric options for special cases)

TO RESOLVE then:

1- question of NSR/PWM (which DAC we use - RDAC by default) and more about normed CLKS (L,R,N)
//RDAC for NSR/PWM and ghostSRs for normed clks (with speed of these from what, from RDAC?)

2- which DAC we use for speedCV+DAC// all the same? selected by what means, fixed but different eg. 
N-R
L-R
C-N
R-N
//as this answer also effects next:

3-how we deal with differing DACs across differing modes? do we need to 2x or 3x all modes for all differing DACs?
//just use basic mode for other DACs so we have a fixed dac table

4-list of modes and format for this for each N.L.C.R. also how we deal with N.L.C.R within cases...

5-special meta-modes for say bus of DACs etc.

6-what pulse can do in CV modes eg. PUSH on bits so is like speed plus pulse
7-what CV can do in pulse modes eg. comparator. as well as each as parameters...

other:
- pulses/clkin in can toggle entry/no entry of new bits, cycling etc
- pulses/clkin in can bump up/shift left/right the routing table
- pulses/clkin in can mask bits as for DAC etc. or SR etc
- pulses/clkin in can also slip/slow/bump up one CV speeded SR

29/9/2021:

- possibly we have static routing for R->N L->C and variable for L and R // with ADC/DAC options//but as we note above L and R also have DACs which are used...
 
as first set of modes: what are our modes - DAC/ADC/routings

- for some interrupt/trigger modes we can use CV for routing table...

but there is a problem if CSR CV is normed to speeds of others at the same time...

again question of NSR/PWM (which DAC we use - RDAC by default) and more about normed CLKS (L,R,N)

but as we no have less clk modes we can also use ghost SRs, but at what speed, speed of RDAC???

28/9/2021:

- new speed scheme/cv/dac to test now on speedc/lower one - seems to work well...

- BOM/pos/quote made 28/9 AM pcbcart/ordered30/9

27/9/2021/ notes from last days:

- back to testing in it.c (not generic but slowly port/change that code) - new speed scheme

RESOLVE:

- CV modifier in pulse modes

- fake CLK triggers from?

NSR - always TImx from DACx
L,C, R - from speedC-cv always

what else makes sense - ghostSR but is more complex!

- all simulated modes. eg. EN/electronotes - generalise as probability of new entry/just cycle/of inversion

- test as CV generator

- sequential SRs mean we can also slip one SR or double it (how to control this)

- DAC/multiple DACs -> DAC bus/mix or even one after the other (faster)??? but how do we decide on this:

eg. one SR has DAC out, any can have and is mixed, any can have and is sequential (as is meta-mode not just decided by SR) 

- interrupt modes as 48-63 last quarter...

Modes: // check if we can possibly hit more than 64 modes !?

0-15: CVspeed: NSR, CSR have ADC/DAC options and basic routes in, LSR and RSR have all routing bit possibles, basic logic ops
DAC is fixed from CSR, input bits from NSR

16-31: CVspeed: exp modes, all SR->rerouting options
DAC can be anywheres, ADC also (how many bits we have), resolve this!

32-47: CV+DAC:  simple modes, exp modes, all SR->rerouting options
where do we get speed DAC from - is it always RSR?

48-63: Interrupt/trigger modes as mix of all...

//address issues for each mode (selected) 

other:
- pulses/clkin in can toggle entry/no entry of new bits, cycling etc
- pulses/clkin in can bump up/shift left/right the routing table
- pulses/clkin in can mask bits as for DAC etc. or SR etc
- pulses/clkin in can also slip/slow/bump up one CV speeded SR

//////////////////////////////////

beckett/gray codes for routing ???

21/9/2021:

- how to go further, collate ideas and see how these fit or don't fit with generic model:

eg. in AC Cv modes was lots of use of pulses to do things which now we lose a bit...

or we divide across 2 sets of generic modes, or simply have generic modes for things like routings

- that incoming pulses can eg. change flip or not flip, change routing table, invert mode bits

seperate mode and mode bits: mode determines mode bits (on mode change)

- fixed small bugs (like static in one bit DAC), and routing for fake clks

20/9/2021:

- testing generic SR is it_generic.c

notes:

- had to break down loop though as speed was overlapping/effecting others, can tighten up and make faster from main.c TIM2 dividers
- that we should be able to make bitsize of dac independent from length - maybe?
- lists of modes/settings

- TODO: probability in generic code? TESTING but might work???


17/9/2021:

- question of how we work with probability within generic framework - as in TM etc...

// make it_gen.c + stripped version to test generic code!

16/9/2021:

- idea that CLK pulsins could trigger train of x pulses at speed x
  (eg. x by CV, by DAC) - descending speed, speed from other SR, train
  from other SR

- how to arrange:

CV speed
trigger speed
speed from other DAC (which one) with CV offset
SR->bit speed (ANDed with CV/trigger) eg. if && bitx
train of pulses also (see above)

[SR->fake triggers and mainPWM/normed in - but that is determined by other SRs] -> we need to sort this...
-> how these are all selected as all SR are independent

//MODE - where do I take my speed from?

to resolve fixed scheme eg. CSR->DAC out as we can't have 2x DAC outs simultaneously (or we have bus/mix)?

TODO: implement basic very generic SR for all cases, test if flag in clkin interrupt works so we can place all in main loop

1-Where do I get speed from? if from SR which one and 
1.5-shifting of which bits <<
2-where is the input bit from (LFSR, ADC type?)
3-what is routing for incoming SR bits, cycling bit
4-what is incoming pulsin bit if any?
5-XOR of logic op of all bits and re-insertion
6-DAC output for any purposes
7-pulses out if any

8-fake/pwm for normed clkins - how? or we keep standard?

options/ideas: DAC out runs at full speed and is changed by all/any, clkin interrupts flagged so all is in main loop

  // we can still have specialised SRs but they should all be repeatable
  // so can be placed in a loop!
  SEE:  generic.c

////////////////
how to resolve clock norming?

So we have PWM (TIMx) which norms to NSR clock - this is generated at the moment from RSR DAC

LSR, RSR and CSR have fake clocks - CSR should be from speedc/CV, LSR and RSR???

15/9/2021:

- testing and implementing arrays for puls ins and outs (left, right and c) DONE
- place into not-so-generic pasted LFSR round one at start// DONE

- implementation for Benjolin/halfDONE but need to think about how we
  can make generic one SR clocking another without failure in any loop, and/or generic use of fake clkins

- TODO: Benjolin in trigger mode using fake clks - FIGURE out how to prevent freeze (CSR will have speed)

- so start to think on what general modes for Vienna could be (before we get to rendering as all generic)

// using sigma delta for bit input an low pass out (see test.c)
// all modes with bits in and out

eg.
0-looping only/aka return only!
1-pass on only - straight through
2-pass on and return bitx

3-TM with pass on - trigger mode
4-TM with loop back
5-TM in TM pass on
6-TM in TM loop

7-Rungler XOR pass on
8-Rungler XOR loop back
9+Run with different speeds
10+Run with bits

11other exp modes/trigger modes//what else?

DACs,ADC types

TODO: always have NSR/PWM from RSR DAC for the moment - so to add to the basic/pastey!

13/9/2021:

- clock fake routes: R->L and L->R (output bits of SR to CLKINS), CSR is speed controlled (has to be) - TO TEST!
TESTING but tricky so made all from speed... NSR/pwm is from DAC

- make latest TM SR more generic/start to port to arrays/tables

11/9/2021:

finishing DAC and ADC generic options:
TODO// other options are: comparator, equivalent sets of x bits incoming 

possibly we don't use fake pulse ins for norming left/right - to test that these don't effect incoming
(but we do need to use CLKins normed for L,R,C) - test with incoming bits

10/9/2021:

inline int bits(uint32_t reg, uint32_t length){ // function returns bottom length bits of SR reg

and another inline function which returns different kinds of DAC from
a certain SR eg. standard DAC of x bits, equivalent dac of x bits,
what about one bit dac (more involved as takes time but we should have
a pointer to that value????

9/9/2021 

// always do DACs - but how these are handled according to length as we still want fixed number of bits

implementing TM in TM: slowly start to see how to abstract as work through and implement all modes

- TOWARDS: basic framework to use in Vienna! (using one bit DAC out
  tho which we could also include in routing tables and as an always?)

- each SR delivers DAC, how to do tables which don't allow for overlap of DACs eg.

1000
0100
0010
0001 for each table

structure for all eg. speed from routing table// all is defined by tables/arrays which can be routed

in test2.c speedroute as array of pointers to values...

pulsin bits L, R is XOR always with new bit

basic modes/expanded modes across split of cv/speed, pulse speed...

/////

how to make uncomplicated generic SR options which can interact across all sets of:

1st set: simple SR modes for each SR with fixed routing
1.5th: simple modes but with very specific configurable tables for routes eg. speed routes...
2nd set: generic SRs with configurable routings
3: complex routing with DAC, ADC etc.

generic as all routing is internal - we do not dictate to other SR...

// also from triadex muse:
--> this is an XOR of 4 bits - selected from clocking bits, on/off bit and from shift register feedback

that we can have XORs of bits from other SRs entering our SR
so table would be for 4 bits from 4x maxSRlength=32*4=128 (ignore lengths)

thinking about multiple routing for DAC, clock DAC and ADC??? how this might work as gives flexibility for timings

then we have x bits:

routing / DAC output / LFSR feedback / ADC IN 
1 2 3 4 / 5      /  6            /  7

extra bits: clock DAC/pulse for speed with any offset(CV), comp DAC ->9 bits, 

speed modes: CV as speed, CV plus DAC as speed, pulses, pulses from SR, combination of... see more below...

// and how would routing be for pulse modes: pulses, pulses from SR - but we can't use our own pulses
// we can't make this so generic as one set uses interrupts... also we can always reroute pulses with cables so...

CV plus DAC in CV modes, pulse plus SR in pulse modes????

routing table is for incoming SRs

abstract out LFSR perhaps as just the returning of bits (so is routing)
also we have entry bits, ADC bit/s, pulsin bits, returning bits

what bits come in, logic, what determines speed, other determing factors for specific SRs


speed/routing/logical ops (logical ops as also selected by bits, overlaying of masks)

- question of multiple DAC outs - what we do with them

if each SR has DAC out which can route somewhere, and ADC in

7 bits - which is 0-128 (test if we can reach on CV knob)

Other bits for pulse/cv and type of SR are fixed across multiple modes.

routing also DAC->speed of register x
pulses->speed of register x

seperate DACs for output, speed/NSR normy clock, other uses (comparator)

1 2 3 4 bits - question is if we combine multiple DACs???

how we deal with incoming bits/pulsin?

///

(or we have anyways routings which are flexible so maybe is ok. just that DAC out clock/speed effects feedback etc...)

// to have experimental modes in second half which do routing bits: in
pulse modes these could depend on CV, and in CV on pulse or RSR.

6/9/2021 - important thing is if we have routing table then what do we do if is
  zeroes for one route - we need always to preserve a default route

for first half of modes we fix top SR as in, left as through, right as feedback, bottom CSR as output


////

TODO from below:

- set up clockins for basic pass/recirculate SRs and test with norm of CSR DAC to top TIM1 NSR pulse-DONE
- start porting SRs - more generic from AC!

- test use of manipulated routing tables for one SR
- trial RSR as random register with various routings for simulation of electronotes and TM.
- in test2.c compare generic shiftings with coggs version (and also if we still need to do <<1 if routes to itself?)DONE, yes they are the same, and we do

- ghostSR in ghostSR in test2.c to trial//also various crossings of delayed ghosts with "real" SRs

from test2.c
// own routing means we have the shifted out bit already (route to self) - but we still need to shift

// we could also lag the ghost so is like a delayed revenant
// so example it only shifts itself if there is a pulse bit

////////////////further

// and cycling/circling array of ghosts which can come back or go forwards/backwards - when these ghosts are copied over (on event)
// with 256 cycles/copies - or we can have variable length of this shifting array

we can also determine cycle we use using another SR

** xxxxx

proof of concept generic routing in test2.c

default or not: CSR DAC out->top PWM/TIM1 which is normed to clock pulse for NSR

[we need to trial if this makes sense with routing]

// what bits make sense for SR definition to be changed by other processes?

eg. input types are fixed or not, routing yes

so we have several bit modes for different main SR types...

for example bits determining type and routing = 7 bits

- that we can choose (eg. RSR) to be specific controller or
  determining SR (eg. for random operations we refer to this one
  eg. for TM and electronotes determinings - to test this)

- routing bits (routing table as one SR?) - or routing bits flipped/changed by other SR, incoming pulses...

- generic: new inputs or not, or logiced with - returning bit or not or logic op (inv), parity settings

equals:

generic parity settings in array (0 for no feedback or tag array with meta-array for type of logical operation, or where it comes from)

trial bits:

pulse/cv speed, input ADC/LFSR, output DAC/else?, type SR, type SR, type SR(3 bits of types=8), routing from (4 options)  

1               1               1                 1        1        1                           1 1 1 1 - 4 bits just to make it easier but could be less

is already 8 bits which would be 255 modes!!! we have limit of 64 modes

+ additonal bits: advance on cogg, logical opps, type of ADC, type of DAC, OR of LFSR/ADC 

// and we just leave outpulses as generic/divide down on 2nd set

unless we have other ways of thinking of modes... (mode as itself shift_register, pulses as incrementing modes or is that all too complicated)



thinking to have special modes - at end of mode dial which implement this kind of thinking: even 3 or 4 last turns which inc bits

** how to make modes more generic/independent whilst keeping routing options and open-ness?*

- feedback thru RSR makes more sense for ADC in modes and less for LFSR so maybe this decides routing?

- what if each of the 4 SRs is totally generic (in/out can be from
  anywhere, routing is unfixed and modifiable in runtime,
  self-modifying) - so there could be multiple ins, mixed outs
  (busses)... how to test this as proof of concept?

- that NSR and CSR can be input and output buses

- what this means for eg. notion of coggs and dependencies on other
  SRs, digital style filters etc. maybe make small test - but problem is to have too many SRs types

but also means we can have routings maybe switchable from pulses or from CV

eg. switch routing on certain conditions...

as in we can mix use of arrays of (pointers)/srs and shiftregs with names which point to these...

** generic SR classifications to work on:

-routing
-what drives it on: pulses, bits/otherSR, values=speed // values from CV, values from DACs/SRs
-looping/input bits
-output bits
-question of overlap/coggs/SR

or:

-what drives it on: pulses, bits/otherSR, values=speed
-returning bits (eg. LFSR, no bits=pass_through)
-overlap (eg. LFSR in overlap, size of overlap)
-incoming bits - this is routing also and pulses in/ADC, and what is done to them (eg. flip them)
-output bits/DAC

or: shift x bits, length, entry new bits

and ADCpulsesDAC are attached in to this (as NSR, CSR)

** another attempt from notebook

1. basic division speed/pulse ->32 modes
2. output/input ADC/DAC/LFSR/others
3. type of SR-parallel/Turing.etc., logical opp (XOR,OR,AND, leaky)
4. what are incoming bits
5. outgoing bits

** code basis from test2.c

uint32_t *shift_[4], *Gshift_[4][4], coggs[4][4]; // gshift is 4 even though we don't use one

b=0; g=2; // n=0,l=1,c=2,r=3 // so feedback here is from c 
bitn = ((*shift_[b] >> (lfsr_taps[SRlength[b]][0])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][1])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][2])) ^ (*shift_[b] >> (lfsr_taps[SRlength[b]][3]))) & 1u; // 32 is 31, 29, 25, 24
// need to catch it
if (*shift_[b]==0)     *shift_[b]=0xff;
// copy now to ghost
//we need multiple ghosts for each possible shifter: eg. Gshift_rl, Gshift_rn, Gshift_rc (right ones for left, for n and for c)
*Gshift_[b][0]=*shift_[b]; 
*Gshift_[b][1]=*shift_[b]; 
*Gshift_[b][2]=*shift_[b];
*Gshift_[b][3]=*shift_[b]; // ghosts for l,c,r only but let's keep one spare
// what else it needs to know - for each queued SR we need one cogg=0 for reset as we reset each on reading
cogg[b][0]=0;
cogg[b][1]=0;
cogg[b][2]=0;
cogg[b][3]=0;
  
*shift_[b]=*shift_[b]<<1; // we are shifting left << so bit 31 is out last one

bitr=(*Gshift_[g][b]>>SRlength[b]) & 0x01;
*Gshift_[g][b]=(*Gshift_[g][b]<<1)+bitr; 

*shift_[b]+= bitn;// & bitr;// ^ (!(GPIOC->IDR & 0x0010)); // or goes to 1s, xor is risky, AND works... and clockbit PC4

//also we can make bit access (eg. GPIOC->IDR & 0x0010 - can we access register as pointer TEST??? WORKS!, counters speed etc. all arrays 0,1,2,3


* general //16/7/2021+

- AC has 64 modes so 64x64x64x64=16 million combinations
- speed CV to use in trigger mode (eg. length of overlap)
- divide into speedCV, trigger/pulse - so that makes 32 modes doubled up (what of SR effecting own/other speeds)

maybe with/without coggs as further option becomes 16 modes

NO freeze: freezing is not so interesting as just locks and gives continuous tone...

[note for SEG - electronotes wheel thing is passing down of bits so this could also be probability based (based on CV)!]

/// LOTS TO RESOLVE:
/////

- thinking also that coggs are a bit like small shift registers
  what could be done with these - rotating/looping SRs handle
  feedthrough of registers TODO! - also that this is more like overlap
  we had in mind - this seems to work

//////

- also odd patterns just realized unless we constrain lengths to odd numbers (which is even lengths) *TEST this - improves but maybe keep odd option//NO!
- reverted to older code 2/9 as if we constrain this favours 101010etc regular outcomes

- at high speeds timing of SR influences other timings

- kind of bug in all lfsr code (28/8/2021) as was passing on bitn
  which was LFSR feedback bit - still was interesting and keep for
  some modes or use that bitn for timing etc...

- also question as CSR is out but speed there determines speed of
  feedback so we should really have different paths:

as we have it is NSR->LSR->CSR->RSR->NSR

eg. NSR->LSR->CSR
            ->RSR->NSR

NSR->LSR->CSR // could be default routing but then we need to see about use of SRlengthc but length is important if we re-circulate???
///->RSR->NSR

NSR->LSR->CSR  ->NSR/or not
   ->RSR->CSR  ->NSR

others: NSR->CSR->LSR ->NSR
                ->RSR ->NSR

need to figure out how to select these from modes - see below

routing can be array of shiftregs

///what does it mean to have multiple routes -> route is only known to incoming SR which updates ghostSR which belongs to itself (so it can have all 4)

so routing table for each incoming SR would be 4 bits 1 1 1 1 N,L,C,R - excluding itself (try version which includes itself and doesn't shift)


//////

- do we always want same flow NSR->LSR->CSR->RSR->backtoNSR (at least
  do we always want feedback to NSR but then if not RSR would be
  redundant)... Q is how to signal different routing across independent modes:

if (routex==1) do this... // or pointers to entries - but we don;t really need pointers

/////

- see also AC modes.org!
- parallel bits input modes - eg. all x ADC bits are thrown into top or other SR

- speed can go to zero! signal this in array somehows... and speeds should be slower at one end

timing from speed-cv, pulse in, top reg(but no bits in), pulse AND
speedcv (divide, multiply, expect), pulse AND/OR/XOR top (again no
bits), from ghost registers (which can also be themselves clocked by
top register and then we can use bits in or?), timing also from SR->DAC


- question of range of speed - from slow CV (Hz?) to KHz for sigma/delta

- how we prevent running down to zero for SR on length change (trap this?)

variable stopping bits/zeroes

- left hand path/ right hand path: tree of life, kenneth grant and overlays for ...?

- how we deal with overlaps? some test code already but need to think through, could connect to length?


also pulse clock or cv advances number/x once eg for cycling ghost sr
or length of ghost sr, or we can have smaller degrees of that advance,
say 1/10 so is not such a big jump

- how clock pulses can be changed for speed - xor with other parts of
  SR, with returning bits (experiment with these timings), with speed bits????

- how to notate SR - black and white, left and right, that a ghost SR
  could decide how to route bits to left or right (but we use right
  for feedback but could still be interesting - general idea of
  routing bits eg ADC to one side, LFSR to other)

- for overlap: what comes out is only one bit (of course there could be pulses from earlier bits)
  try overlap with multiple << shift (same as or differing from overlap size)
  returning bits

- overlap also in sense that both overlap (XOR etc top and bottom overlapped SRs), what other kinds of overlap?

- how else to use our new multiple shift code?

- what we do with both clock and pulse in bits in CV mode and how we
  norm these bits (NSR clock is normed to TIM1 pwm which we will use
  speedCV/or DAC out as control for) - otherwise we have pulseouts normed to all other pulse/clock ins

[but none of these will advance so maybe sync all to this clock which frees up their own speedCVs]

- experimental modes for LSR, RSR and CSR only advance with cogg=0 from previous (maybe logic op with bit)???

* NSR, LSR, RSR, CSR

** NSR - top register - ADC in, CLKIN only, no pulse outs:

mode 0 is straight LFSR (or with ADC or)

- 1-LFSRnoise/2-ADC in/3-mix of LFSR and ADC //4-comparator? -to-LSR/or/RSR or both (do we decide that here = RSR is now designated as feedback)

[so that gives us 8 or so modes for each one - or 4 with new coggs setup]

+ comparator function for ADC ins (can we also use this for LFSR -
  ways that we can combine bits from that?) - comp only works when we
  have no speedCV/pulsein only - or we can have 

comp in as one bit only ADC in comped with CV?

- feedback of analogue output - eg. comparator using analogue out

- types of ADC (x bits, simple uncombined bits as in digfiltersim, equivalent bits), length in bits, delayed/stored bits

- pulse in/or speedCV and what CV does when pulse in/vice versa! (eg. number of bits, LFSR length if we have as extra)

- can also be clocked by CSR and/or ghosted noise SR 

- can be set of parallel SRs which feed into CSR, or just x bits from ADC go straight into CSR

- ADC with LFSR options: that we OR/XOR each incoming ADC bit with
  LFSR generated bit (from ghost LFSR), cases for parallel ADCs, that
  we weight incoming LFSR bits, that we use LFSR as DAC to
  add/subtract from ADC in, that we bulk XOR or just one bit per x
  incoming ADC bits, comparator of incoming DAC against LFSR/DAC

- number of bits in/out by CV or pulse counter(which wraps around)

- what to do if bits in/out is greater than length (options: put in anyways and lose top/bottom bits - shift if necessary // stop at length)

** LSR/RSR - regular shift register modes borrow from AC - CLKIN and PULSIN, 2 pulse outs/bits or flipflops: 

mode 0: feedthrough only - straight shift through with no return

LSR has entry from NSR and feeds into CSR
RSR has entry from CSR and feeds into NSR (so is the feedback register)

but now we look into different paths!

dark/light sides, left and right hand paths, mirrors (moon and sun), tree of life (Kenneth Grant - Nightside of Eden)

Question of how we work with entry of pulse ins: as togglers, pausers also, as extra
bits (but do we always have NSR entering in, maybe AND with extra bits
or other logic ops)

List leaky/decay possibilities...

- look at AC SRs and see what can be adapted for NSR/CSR as incoming bits and cycling bit or pulse in bit (or combinations of these)

- how we handle entry and overlap from NSR or CSR (logical ops, length of overlap)

- can also be clocked by bits from the NSR top register - but in this case we can't input bits from NSR as these will just be 1s!
 
- regular AC/SR modes

- just one way shift/delay - in one end, out the other (with/without bit degradation)

- looping SR with/without degradation

- leaking/decaying of bits, other logic feedbacks 

- micro-SRs in SRS - additional loops and feedbacks (that we can have loop in loop but also feedback in RSR to LSR and vice versa)

- regular and ghost LFSRs...

- latchings, holdings

- multiple flipflops of various descriptions for pulses out

- RSR is "clocking/logicopwithclocking" LSR and vice versa - need to test how this will work in all cases

** CSR - output register - CLKIN only, 2 pulse outs/bits or flipflops, DAC out: 

mode 0: basic DAC out

- type of DAC (eg. sigma/delta which is low pass of single stream of bits, x bit DAC)
- which of the bits are used for regular DAC: weighted, unweighted, spacings
- overlays, masks for DAC bits

- how we handle the pulseouts so this can also be extra/doubling up of modes

- DAC outs from SR

- electronotes just has standard weighting DAC, uniform (bits x X) from consecutive taps, and sets of spaced taps -> wide spacings)

what else for 64 modes divided by speedcv/pulsin = 32 still (in pulsin we have bit length for DAC)

- number of bits in/out by CV or pulse counter(which wraps around)

- what to do if bits in/out is greater than length (options: put in anyways and lose top/bottom bits - shift if necessary // stop at length)

* notes... from elsewhere/sketches

- extra SR for random ops and timings maybe - that we can copy other SR to this also...

- what second bits out can be - different taps, divided/flip_flop, diff tap and flip_flop, logical ops with other bit!

- drooling shift register legged caterpillars

- how to do digital filtering - x spaced bits enter, passed down straight SR (with/without bit degradation, any other fancy stuff)
and X spaced bits are sent to DAC from CSR. return bits (how to select) OR/XOR from output (as bits or via DAC/ADC feedback options) to NSR/top register.

- maximum SR length as 32?
- ghost SRs
- parallel entry of data/ADC, sudden mirroring of SRs?

- leaky, rotting and/or infectuous logic/sticky logic/slow logic others?, UFO stuff 

what other kinds of logic gates there can be (based on CA, ternary etc)?

timing of a slow logic leak? 

trigger->latch and slow leak, disappearance of ones, bit by bit (how we could also display this as side project)

- NLC 8 bit cipher simulation: only makes sense for NSR and CSR where we have many bits in

... strobe is always high on 4094 so bits go into SR and are out, but
option for data on strobe which means all SR only change on 1, CV
combines different bits and primitive XOR for 2nd bit/mix with data in...

basically data goes to out when strobe is high, low -> just shifts 

so strobe is pulse in which can latch (incoming-ADC or noise) bits on to NSR or CSR
(outgoings) - and this is different to speedCv/pulse_speed as SR is still operating...

- how to work with overlaps? 

- overlap XOR LSR and RSR

- sieves - that LSR can be used as a sieve or bitmask for
  RSR/others... - how we deal with sudden events such as this, freeze,
  copy, ghost etc. (on a pulse in?)

- marking bits which always stay frozen - concept of sieves, masks,
  ghosts, revenants (eg. slow drift or decay of bits from one set to
  another, frozen, prevous or ghosted - so bit by bit they shift back,
  question of how long they take to go back?)

question of recording position and lifetime for decay - we erase on
death from the list but list handling is slow (finite sets of arrays
and garbage collect in one interrupt?) or we can just record and keep one bit max per SR

- TM encoding for SR_as_tape operations
 
  walk_ins - what else can be borrowed from language, concepts from UFO
  encounters?

- pulse triggers exchange between ghost and real, what pulses might
  mean - primitive programming language like brainfuck

//interpret set of bits as instruction on pulse in - say an x bit
sequence (but how to work with bits rather than bytes)

instructions shift left or right the opposite SR (can also use bits as
mask to do this - so we interpret one SR as shifting the other on each
bit in)

The Infinite Abacus: Brainfuck's "grand-parent" language

A version with explicit memory addressing rather without stack and a
conditional jump was introduced by Joachim Lambek in 1961 under the
name of the Infinite Abacus, consisting of an infinite number of
cells and two instructions:

    X+ (increment cell X)
    X- else jump T (decrement X if it is positive else jump to T)

- reverse direction of register (what this means?)

- glue one LFSR onto end/beginning of another

** parallel SRs

- feed data into top of parallel LFSRs, data read out from all bit outs: test for 12 bits, 12 parallel streams

** two headed SR



* in progress/ideas/todo

- how we pass through SR bits at different speeds - top one resets cycling/circling counter which wheels through SR
- is [0 bit our output?
- smoothing and other aspects from AC to implement
- re-test function pointers/how to make code more modular?


* TODO/plan

- basic structure of the 4 SR and straightforward tests eg. ADC in,
  pass down SR, DAC out

- proof of concept for digital filter and what ideas come from this

- all basic SR concepts implemented

- brainstorm and tests of all concepts

- basic modes layed out and tested - first speed CV then pulse driven and fancier...

